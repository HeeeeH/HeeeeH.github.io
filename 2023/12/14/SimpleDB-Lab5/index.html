<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SimpleDB-Lab5 - Hyeee&#039;s Home</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hyeee&#039;s Home"><meta name="msapplication-TileImage" content="/img/pikachu.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hyeee&#039;s Home"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="0.实验目标在这个实验中，你将实现一个B+树形索引，用于高效的查找和范围扫描。我们为你提供了实现树形结构所需的所有底层代码。你将实现搜索、拆分页面、在页面之间重新分配 tuple 以及合并页面。 B+树的内部节点拥有多条记录，每个节点的内容包括节点当前值、以及左右子树的指针；相邻键之间共享一个孩子指针，所以拥有m个键的内部节点通常拥有m+1个孩子指针。叶子节点可以包括数据记录或者指向其他数据库文件"><meta property="og:type" content="blog"><meta property="og:title" content="SimpleDB-Lab5"><meta property="og:url" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/"><meta property="og:site_name" content="Hyeee&#039;s Home"><meta property="og:description" content="0.实验目标在这个实验中，你将实现一个B+树形索引，用于高效的查找和范围扫描。我们为你提供了实现树形结构所需的所有底层代码。你将实现搜索、拆分页面、在页面之间重新分配 tuple 以及合并页面。 B+树的内部节点拥有多条记录，每个节点的内容包括节点当前值、以及左右子树的指针；相邻键之间共享一个孩子指针，所以拥有m个键的内部节点通常拥有m+1个孩子指针。叶子节点可以包括数据记录或者指向其他数据库文件"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/d3a00fce8efb4b97b872a7fe1e9d2758.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/d871df755b3b456dbebf966ed6222c38.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/a1a5d27dafb04006b0dd77f67555268a.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/edfad0a006764b08b54f758bfc5b86e7.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/f98f1815e7274713b72c1c2c4c9c1819.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/6e74654c71e24e8f82cb1df7812e1b79.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/d033888439d94ab899ec23b76d7ce4ae.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/95cb46ed1e3b404289666544bb29440f.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/a839bbec73da47f481e86b055c76398a.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/f644d6d4a2854b7e993d4cbc867da176.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/dd57eeee9d124aff8af0253bf177e36b.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/e8a5dc33912d41e8a2ffd74fa25ceab8.png"><meta property="og:image" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/1701780989752-3bb916ad-cf7a-4bd4-8794-578424342e95.png"><meta property="article:published_time" content="2023-12-14T14:25:46.000Z"><meta property="article:modified_time" content="2023-12-14T14:25:46.000Z"><meta property="article:author" content="Hyeee"><meta property="article:tag" content="Java"><meta property="article:tag" content="DataBase"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://hyeee.me/2023/12/14/SimpleDB-Lab5/d3a00fce8efb4b97b872a7fe1e9d2758.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://hyeee.me/2023/12/14/SimpleDB-Lab5/"},"headline":"SimpleDB-Lab5","image":["http://hyeee.me/2023/12/14/SimpleDB-Lab5/d3a00fce8efb4b97b872a7fe1e9d2758.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/d871df755b3b456dbebf966ed6222c38.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/a1a5d27dafb04006b0dd77f67555268a.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/edfad0a006764b08b54f758bfc5b86e7.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/f98f1815e7274713b72c1c2c4c9c1819.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/6e74654c71e24e8f82cb1df7812e1b79.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/d033888439d94ab899ec23b76d7ce4ae.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/95cb46ed1e3b404289666544bb29440f.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/a839bbec73da47f481e86b055c76398a.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/f644d6d4a2854b7e993d4cbc867da176.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/dd57eeee9d124aff8af0253bf177e36b.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/e8a5dc33912d41e8a2ffd74fa25ceab8.png","http://hyeee.me/2023/12/14/SimpleDB-Lab5/1701780989752-3bb916ad-cf7a-4bd4-8794-578424342e95.png"],"datePublished":"2023-12-14T14:25:46.000Z","dateModified":"2023-12-14T14:25:46.000Z","author":{"@type":"Person","name":"Hyeee"},"publisher":{"@type":"Organization","name":"Hyeee's Home","logo":{"@type":"ImageObject","url":"http://hyeee.me/img/logo_pikachu.svg"}},"description":"0.实验目标在这个实验中，你将实现一个B+树形索引，用于高效的查找和范围扫描。我们为你提供了实现树形结构所需的所有底层代码。你将实现搜索、拆分页面、在页面之间重新分配 tuple 以及合并页面。 B+树的内部节点拥有多条记录，每个节点的内容包括节点当前值、以及左右子树的指针；相邻键之间共享一个孩子指针，所以拥有m个键的内部节点通常拥有m+1个孩子指针。叶子节点可以包括数据记录或者指向其他数据库文件"}</script><link rel="canonical" href="http://hyeee.me/2023/12/14/SimpleDB-Lab5/"><link rel="icon" href="/img/pikachu.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo_pikachu.svg" alt="Hyeee&#039;s Home" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-14T14:25:46.000Z" title="2023/12/14 22:25:46">2023-12-14</time>发表</span><span class="level-item"><time dateTime="2023-12-14T14:25:46.000Z" title="2023/12/14 22:25:46">2023-12-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span><span class="level-item">43 分钟读完 (大约6403个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">SimpleDB-Lab5</h1><div class="content"><h2 id="0-实验目标"><a href="#0-实验目标" class="headerlink" title="0.实验目标"></a>0.实验目标</h2><p>在这个实验中，你将实现一个B+树形索引，用于高效的查找和范围扫描。我们为你提供了实现树形结构所需的所有底层代码。你将实现搜索、拆分页面、在页面之间重新分配 tuple 以及合并页面。</p>
<p>B+树的内部节点拥有多条记录，每个节点的内容包括节点当前值、以及左右子树的指针；相邻键之间共享一个孩子指针，所以拥有m个键的内部节点通常拥有m+1个孩子指针。叶子节点可以包括数据记录或者指向其他数据库文件的指针。为了简单起见，我们实现的B+树的叶子节点只包括数据记录。相邻的叶子页通过左右同级指针链接在一起，因此范围扫描只需要通过根节点和内部节点进行一次初始搜索即可找到第一个叶子页，后续叶子页通过右(或者左)指针找到。</p>
<span id="more"></span>

<p><img src="/2023/12/14/SimpleDB-Lab5/d3a00fce8efb4b97b872a7fe1e9d2758.png" alt="在这里插入图片描述"></p>
<ul>
<li>B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</li>
<li>B+树相邻的叶子节点之间是通过链表指针连起来的</li>
<li>B+树中，内部节点与其父节点的key值不能重复，叶子节点与其父节点的key值可以重复</li>
</ul>
<p><strong>下面这幅图是SimpleDB B+ tree这部分整体架构组织图（来源：<a target="_blank" rel="noopener" href="https://cjdhy.blog.csdn.net/article/details/131962742">MIT 6.830数据库系统</a>）</strong><br><img src="/2023/12/14/SimpleDB-Lab5/d871df755b3b456dbebf966ed6222c38.png" alt="在这里插入图片描述"><br><strong>磁盘上Header Page是懒初始化的，因此出现的位置是不固定的，Internal Page和Leaf Page同样如此，之所以可以这样，是因为存在一个root ptr page,它起到的作用就类似文件系统中的超级块:</strong><br><img src="/2023/12/14/SimpleDB-Lab5/a1a5d27dafb04006b0dd77f67555268a.png" alt="在这里插入图片描述"></p>
<p>我们应该在lab4的基础上开始本次实验代码的编写，此外，报告中还为本次实验提供了额外的源码和测试文件</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><strong>B+树的单值查询</strong></p>
<ul>
<li>当查询key&#x3D;70的节点时，首先从读取根节点，判断得key&lt;75；</li>
<li>然后读取根节点的左孩子节点，将70依次与左孩子节点中的值进行比较，判断得key&gt;66；</li>
<li>则读取66的右孩子节点，key存储于该叶节点中，读取其中的数据。</li>
</ul>
<p><img src="/2023/12/14/SimpleDB-Lab5/edfad0a006764b08b54f758bfc5b86e7.png" alt="在这里插入图片描述"></p>
<p><strong>B+树的范围查询</strong></p>
<ul>
<li>当要读取[68,100]范围内的数据时，首先找到第一个大于等于68的节点，然后在叶节点中向后遍历。<br><img src="/2023/12/14/SimpleDB-Lab5/f98f1815e7274713b72c1c2c4c9c1819.png" alt="在这里插入图片描述"></li>
</ul>
<p>查看index目录下的BTreeFile.java文件，这是实现B+树的核心文件，你将会在该文件为本次实验编写所有代码。不像HeapFile，BTreeFile包含四种不同的页。正如你期望的那样，树的结点有两种不同类型的页面：叶子节点和非叶子节点。</p>
<p>非叶子节点在BTreeInternalPage.java中实现，叶子节点在BTreeLeafPage.java中实现。为了方便起见，BTreePage.java中已经创建了包含叶子节点和非叶子结点共同特性的抽象类。此外，header pages在BTreeHeaderPage.java中实现并且追踪文件中的哪个页面是被使用的。</p>
<p>最后，在每个BTreeFile开始都有一个指向树的根页和第一个header page的页；该单独的页在BTreeRootPtrPage.java中被实现。熟悉这些类的接口，尤其是BTreePage、BTreeInternalPage和BTreeLeafPage。在实现B+树的过程中需要使用它们。</p>
<h2 id="1-BTreeFile-findLeafPage"><a href="#1-BTreeFile-findLeafPage" class="headerlink" title="1. BTreeFile.findLeafPage()"></a>1. BTreeFile.findLeafPage()</h2><h3 id="a-要修改的文件"><a href="#a-要修改的文件" class="headerlink" title="a. 要修改的文件"></a>a. 要修改的文件</h3><ul>
<li>src&#x2F;simpledb&#x2F;index&#x2F;BTreeFile.java</li>
</ul>
<h3 id="b-实现说明"><a href="#b-实现说明" class="headerlink" title="b. 实现说明"></a>b. 实现说明</h3><ul>
<li><p>我们的第一个任务就是实现BTreeFile.java中的findLeafPage()函数，该函数通过给定的键查找合适的叶子页，主要用于搜索和插入。例如，假设我们提供了包含两个叶子页的B+树(如图1所示)，根节点是一个包含一个键和两个孩子结点指针的内部结点。给定键值1，该函数应该返回第一个叶子结点；同样地，给定键值8，该函数应该返回第二个结点。不太明显的情况是，我们给定键值6，可能存在重复的键，因此两个页结点上可能都包含键6对应的元组。在这种情况下，函数应该返回第一个叶子节点。</p>
<p><img src="/2023/12/14/SimpleDB-Lab5/6e74654c71e24e8f82cb1df7812e1b79.png" alt="在这里插入图片描述"></p>
</li>
<li><p>我们实现的findLeafPage()函数应该递归的搜索内部节点，直到它到达给定键值对应的叶子页。为了在每阶段找到合适的叶子页，我们应该迭代遍历内部节点的记录斌给比较记录与给定的键值的大小，以确定下一步往哪个方向走。BTreeInternalPage.iterator（）使用在BTreeEntry.java中定义的接口提供对内部页面中条目的访问。该迭代器允许我们遍历内部节点的键值，并且访问每个键的左右孩子页指针。当传入的BTreePageId的pgcateg()方法返回值与BTreePageId.LEAF相等时，表明这是一个叶子页。在这种情况下，我们仅需要从缓冲池中获取该页并返回它即可，不需要确保它实际上包含提供的键值f。</p>
</li>
<li><p>当提供的键值是null时，findLeafPage()方法必须处理这种情况。如果给定的值是空的，那么在递归的过程中就遍历最左侧的孩子节点，最终返回最左侧的叶子页。查找最左侧的叶子也对于扫描记录文件非常有用。当查找到正确的叶子页时，我们应该返回它。正如上面提到的那样，我们可以通过pgcateg()方法检查叶子也的类型。我们可以假设只有叶子页和内部节点才会被传递给该函数。</p>
</li>
<li><p>与其直接调用BufferPool.getPage()方法来获取每个内部页面和叶子页，建议调用代码中的包装函数BTreeFile.getPage()。它像BufferPool.getPage()那样工作，但是提供额外的参数去追踪脏页。在接下来的两个练习中，该函数非常重要，在这两个练习中，我们需要实际更新数据，因此需要追踪脏页。</p>
</li>
<li><p>findLeafPage()实现访问的每个内部（非叶）页面都应使用只读权限获取，但返回的叶页面除外，返回的叶页面应使用作为函数参数提供的权限获取。这些权限级别对于本实验室来说并不重要，但对于代码在未来的实验室中正常运行来说，它们将非常重要。</p>
</li>
</ul>
<h3 id="c-实现目标"><a href="#c-实现目标" class="headerlink" title="c. 实现目标"></a>c. 实现目标</h3><ul>
<li>通过BTreeFileReadTest.java中的所有单元测试</li>
<li>通过BTreeScanTest.java中的系统测试。</li>
</ul>
<h3 id="d-实现记录"><a href="#d-实现记录" class="headerlink" title="d. 实现记录"></a>d. 实现记录</h3><ul>
<li>查找值为field的元组所在的叶子Page：findLeafPage()<ul>
<li>若为叶子Page则直接返回。若field为空，则查找最左的叶子Page。递归查找，非叶子Page访问均加读锁，叶子Page访问加写锁。</li>
</ul>
</li>
</ul>
<h2 id="2-Splitting-Pages"><a href="#2-Splitting-Pages" class="headerlink" title="2. Splitting Pages"></a>2. Splitting Pages</h2><h3 id="a-要修改的文件-1"><a href="#a-要修改的文件-1" class="headerlink" title="a. 要修改的文件"></a>a. 要修改的文件</h3><ul>
<li>src&#x2F;simpledb&#x2F;index&#x2F;BTreeFile.java</li>
</ul>
<h3 id="b-实现说明-1"><a href="#b-实现说明-1" class="headerlink" title="b. 实现说明"></a>b. 实现说明</h3><ul>
<li><p>为了保证B+树中存储元组的顺序性并且保持B+树的完整性，我们必须将元组插入到包含键范围的叶子页中。正如我们上面提到的，findLeafPage()方法被用于寻找我们应该插入元组的正确的叶子页。但是，每个页都有槽数的限制，即使对应的叶子页已满我们也需要能向其中插入元组。</p>
</li>
<li><p>尝试向已满的叶子页插入元组会导致页分裂，以便元组平均地分布到两个新页中。叶子页的每次分裂，都需要将第二页中的第一个元组对应的新条目添加到父节点。有时，内部节点也可能已满，无法接受新条目。在这种情况下，父节点应该分裂并且向它的父节点添加一个新纪录。这可能导致递归地分裂并且最终创建一个新的根节点</p>
</li>
<li><p>在本次练习中，我们需要实现BTreeFile.java中的splitLeafPage()和splitInternalPage()方法。如果被分裂的页是根节点，我们需要创建一个新的内部节点作为新的根节点，并且更新BTreeRootPtrPage。否则，我们需要通过READ_WRITE权限读取父页面，如果有必要就递归地进行分裂，并且添加新记录。你会发现getParentWithEmptySlots()函数对于处理这些不同的情况非常有用。在splitLeafPage()方法中我们应该将键复制到父页，而在splitInternalPage()方法中，应该将键推到父页(如图2所示)。记住根据需要更新新页的父指针(为了简单起见，图2没有展示父指针)。<br><img src="/2023/12/14/SimpleDB-Lab5/d033888439d94ab899ec23b76d7ce4ae.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>分裂叶节点时，节点中的key值复制到父节点中（即叶节点和内部节点可以有相同的值）</strong></p>
</blockquote>
</li>
<li><p>当一个内部节点被分裂时，我们需要更新被移动的孩子页的父指针。你会发现updateParentPointers()对于这非常有用。此外，记住更新被分裂的叶子页的兄弟指针。最后，返回应该插入新元组或记录的页面，如提供的键字段所示。(提示：不必担心提供的键实际上可能位于要拆分的元组&#x2F;条目的正中心。应该在拆分期间忽略该键，只使用它来确定返回两个页面中的哪一个)<br><img src="/2023/12/14/SimpleDB-Lab5/95cb46ed1e3b404289666544bb29440f.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>分裂内部节点时，是将节点中的key值“挤到”父节点中（即内部节点之间的key值不能重复）</strong></p>
</blockquote>
</li>
<li><p>无论何时创建新页面，无论是因为拆分页面还是创建新的根页面，都可以调用getEmptyPage()来或取新页面。这个函数是一个抽象函数，它允许我们重用由于合并而被删除的页面。</p>
</li>
<li><p>我们期望使用BtreeAppPage.iterator()和BTreeInternalPage.iterator()与叶和内部页面交互，以迭代每个页面中的元组&#x2F;条目。为了方便起见，源码中提供了这两种类型页面的反向迭代器：</p>
<ul>
<li>BTreeLeafPage.reverseIterator() 和 BTreeInternalPage.reverseIterator()。</li>
<li>对于将页中元组&#x2F;条目的子集移动到其右侧兄弟节点的任务来说，这些反向迭代器非常有用。</li>
</ul>
</li>
<li><p>如上所述，内部页面迭代器使用BTreeEntry.java中定义的接口，该接口有一个键和两个孩子指针。它也包含一个recordId，用于标识基础页面上键和孩子指针的位置。我们认为一次处理一个条目是与内部页面交互的自然方式，但重要的是要记住，底层页面实际上并不存储条目列表，而是存储<em>m</em>键和<em>m</em>+1子指针的有序列表。由于<code>BTreeEntry</code>只是一个接口，而不是实际存储在页面上的对象，因此更新<code>BTreeEntry</code>的字段不会修改底层页面。为了修改页面上的数据，需要调用BTreeInternalPage.updateEntry()方法。另外，删除一个记录实际上仅仅删除了键和孩子指针，因此源码提供了<code>BTreeInternalPage.deleteKeyAndLeftChild()</code>和<code>BTreeInternalPage.deleteKeyAndRightChild()</code>函数来实现这一点。记录的recordId用于查找被删除的键和孩子指针。插入记录也仅仅插入键和孩子指针(除非它是第一条记录)，所以<code>BTreeInternalPage.insertEntry()</code>检查所提供的记录中的一个孩子指针是否与页面上现有的孩子指针重叠，并且在该位置插入条目将使键保持排序顺序</p>
</li>
<li><p>在splitLeafPage()和splitINternalPage()方法中，需要使用任何新创建的页面以及由于新指针或新数据而修改的页面来更新<code>dirtypages</code>集合。这是BTreeFile.getPage()派上用场的地方，每次获取页面时，BTreeFile.getPage()都会检查页面是否已经存储在本地缓存中，如果本地缓存中找不到请求的页面，则会从缓冲池中获取该页面。<code>BTreeFile.getPage()</code>如果使用读写权限获取页面，也会将页面添加到<code>dirtypages</code>缓存中，因为它们可能很快就会被弄脏。这种方法的一个优点是，如果在一个元组插入或删除过程中多次访问相同的页面，则可以防止更新丢失。</p>
</li>
<li><p>请注意，与<code>HeapFile.insertTuple()</code>不同的是，<code>BTreeFile.insertTuple()</code>可能会返回大量脏页，特别是在拆分任何内部页的情况下。您可能还记得以前的实验，返回脏页集是为了防止缓冲池在刷新脏页之前逐出脏页</p>
</li>
</ul>
<p><strong>Warning</strong>:B+树是一种复杂的数据结构，在修改B+树之前了解每个合法的B+树的必要属性很有帮助：</p>
<ol>
<li>如果一个父节点指向孩子节点，那么孩子节点必须指向同一个父节点</li>
<li>如果叶子节点指向右侧兄弟节点，那么右侧兄弟节点也需要指向左边这个兄弟节点</li>
<li>第一个叶子和最后一个叶子节点必须分别指向null</li>
<li>记录ID必须与它们实际属于的页匹配</li>
<li>具有非叶子节点的节点中<code>key</code>必须大于左子节点中的任何key，小于右子节点中的任何key</li>
<li>具有叶子节点的节点中<code>key</code>必须大于等于左孩子的所有key，小于等于右孩子的所有key</li>
<li>节点孩子或为非叶子节点、或为叶子节点</li>
<li>每个节点最多只有m个子节点，非叶子节点具有至少⌈m&#x2F;2⌉子节点</li>
</ol>
<p>在BTreeChecker.java中已经实现了检查上述属性的机制，该方法也用于在 <code>systemtest/BTreeFileDeleteTest.java</code>中测试我们的B+树实现，可以随意添加对该函数的调用，以帮助调试</p>
<p><strong>注意</strong></p>
<ol>
<li>checker方法应始终在树初始化之后、开始和完成对键插入或删除的完整调用之前和之后通过，但不一定在内部方法中通过。</li>
<li>树可能格式正确(因此通过checkRep())，但仍然可能不正确。例如，空树始终会通过checkRep()方法，但可能并不总是正确的(如果刚刚插入元组,则树不应该为空)</li>
</ol>
<h3 id="c-实现目标-1"><a href="#c-实现目标-1" class="headerlink" title="c. 实现目标"></a>c. 实现目标</h3><ul>
<li>通过BTreeFileInsertTest.java中的单元测试。</li>
<li>通过 systemtest&#x2F;BTreeFileInsertTest.java 中的系统测试。<ul>
<li>系统测试可能要花费几秒钟才能完成，这些文件会测试我们代码中插入元组和分裂也的正确性，并且处理重复的元组。</li>
</ul>
</li>
</ul>
<h3 id="d-实现记录-1"><a href="#d-实现记录-1" class="headerlink" title="d. 实现记录"></a>d. 实现记录</h3><ul>
<li>分裂Page：splitLeafPage()和splitInternalPage()<ul>
<li>为了保证增加节点后，B+树的高度不会太高，当Page中节点超过阈值时需要将Page中的元组分裂到一个新的Page中。方法返回加入的filed所在的Page。</li>
<li>使用倒序遍历，将原本Page中右边一半的元组加入到新的Page中。叶子Page需要更新左右兄弟指针，并向父Page插入新Page中的第一个元组；非叶子Page需要将分裂后左边Page的最后一个元组挤入父Page。之后更新脏页中的孩子指针，并记录脏页。</li>
</ul>
</li>
</ul>
<h2 id="3-Redistributing-pages"><a href="#3-Redistributing-pages" class="headerlink" title="3. Redistributing pages"></a>3. Redistributing pages</h2><h3 id="a-要修改的文件-2"><a href="#a-要修改的文件-2" class="headerlink" title="a. 要修改的文件"></a>a. 要修改的文件</h3><ul>
<li>src&#x2F;simpledb&#x2F;index&#x2F;BTreeFile.java</li>
</ul>
<h3 id="b-实现说明-2"><a href="#b-实现说明-2" class="headerlink" title="b. 实现说明"></a>b. 实现说明</h3><ul>
<li><p>为了保持树的平衡并且不浪费不必要的空间，B+树的删除操作可能会导致页重新分配元组，最终导致页合并:<br><img src="/2023/12/14/SimpleDB-Lab5/a839bbec73da47f481e86b055c76398a.png" alt="叶子节点页再分配"></p>
<p><img src="/2023/12/14/SimpleDB-Lab5/f644d6d4a2854b7e993d4cbc867da176.png" alt="非叶子节点页再分配"></p>
<p><img src="/2023/12/14/SimpleDB-Lab5/dd57eeee9d124aff8af0253bf177e36b.png" alt="叶子节点页合并"><br><img src="/2023/12/14/SimpleDB-Lab5/e8a5dc33912d41e8a2ffd74fa25ceab8.png" alt="非叶子结点页合并"></p>
</li>
<li><p>如果试图从小于半满的叶子页中删除元组的话，则会导致该页面从其兄弟节点中窃取元组或与其兄弟节点中的一个合并。如果页面的兄弟节点有多余的元组，则元组应该均匀分布在两个页面之间，并且父级条目应该进行更新(如图3)。但是，如果兄弟节点也是半满(如图4)，那么应该合并两个页，并且删除父节点的记录。反过来，从父节点中删除记录也可能导致父节点半满，在这种情况下，父节点应该从它的兄弟节点中窃取记录或者与他的兄弟节点合并。这可能会导致递归地合并，如果根节点的最后一个记录被删除的话，那么最终会删除根节点。</p>
</li>
<li><p>在接下来的练习中我们需要实现<code>BTreeFile.java</code>中<code>stealFromLeafPage()</code>,<code>stealFromLeftInternalPage()</code>, <code>stealFromRightInternalPage()</code>,<code>mergeLeafPages()</code> 和<code>mergeInternalPages()</code> 方法。在前三个函数中，如果兄弟节点有多余的元组&#x2F;记录，那么我们需要实现均匀地再分布元组&#x2F;记录。记住更新父节点中相应的key(仔细看图3).在<code>stealFromLeftInternalPage()</code>&#x2F;<code>stealFromRightInternalPage()</code>方法中，我们需要更新已经被移动的孩子的父节点。我们可以重用<code>updateParentPointers()</code>方法。</p>
</li>
</ul>
<h3 id="c-实现目标-2"><a href="#c-实现目标-2" class="headerlink" title="c. 实现目标"></a>c. 实现目标</h3><ul>
<li>通过BTreeFileDeleteTest.java中的一些单元测试（如testStealFromLeftLeafPage和testStealFromRightLeafPage）。</li>
</ul>
<h3 id="d-实现记录-2"><a href="#d-实现记录-2" class="headerlink" title="d. 实现记录"></a>d. 实现记录</h3><ul>
<li><p>使兄弟Page的元组数均分：stealFromLeafPage()和stealFromLeftInternalPage()和stealFromRightInternalPage()</p>
<ul>
<li><p>是为了删除节点后，若当前节点不满足Page中最小元组数，则需要看兄弟是否有多余的，如果有，可以直接向兄弟节点借；若没有，则需要合并结点。</p>
</li>
<li><p>从兄弟节点中借siblingNumTuples - (pageNumTuples + siblingNumTuples) &#x2F; 2个元组。若向左兄弟借，则对左兄弟进行倒序遍历；右兄弟则进行正向遍历。最后需要更新entry中的key值，并调用parent.updateEntry()、updateParentPointers()更新。</p>
</li>
</ul>
</li>
<li><p>void stealFromLaefPage()</p>
<ul>
<li><p>计算要steal的元组数（使其和兄弟Page中最终的元组数一致）</p>
</li>
<li><p>左兄弟从最后开始遍历，右兄弟从最左开始遍历</p>
</li>
<li><p>不断从兄弟Page中取出元组，插入到本Page</p>
</li>
<li><p>更新entry中的key值为较右Page中的第一个元组</p>
</li>
<li><p>调用parent.updateEntry(entry)更新parent信息</p>
</li>
<li><p>BTreeEntry中有一个Field类型的key和两个BTreePageId类型的child，以及一个RecordId类型的rid，可以看做B+树中非叶子节点的一个单元，每个单元保存key值并且指向两个孩子节点。BTreeEntry为InternalPageIterator遍历的单位，实际Page中没有保存这样一个结构。BTreeInternalPage中保存的是keys和children。</p>
</li>
<li><p>updateEntry()是通过传入的BTreeEntry来更新本Page中的keys和children信息。</p>
</li>
<li><p>stealFromLaefPage()中传入的参数entry代表的是兄弟节点和本节点所对应的父节点的entry，也就是其key为父节点中的key，两个child分别指向兄弟和自己。因此，steal完成后，对entry进行更新，指针和对应的rid（即PageId和该entry在该Page的位置）都不需要改变，只需要更新key。</p>
</li>
</ul>
</li>
<li><p>void stealFromLeftInternalPage()</p>
<ul>
<li><p>计算要steal的元组数（使其和兄弟Page中最终的元组数一致）</p>
</li>
<li><p>左兄弟从最后开始遍历</p>
</li>
<li><p>先将父Page中的entry插入本Page，更新孩子节点指针</p>
</li>
<li><p>不断从兄弟Page中取出元组，插入到本Page</p>
</li>
<li><p>之后更新父Page的entry，将左Page中的最后一个元组的key给父entry，调用parent.updateEntry(entry)更新parent信息</p>
</li>
<li><p>最后调用updateParentPointers，更新本Page中所有entry的父节点信息，保证子节点的parent都指向本Page。</p>
</li>
</ul>
</li>
<li><p>void stealFromRightInternalPage()</p>
<ul>
<li>基本与上相同，右兄弟从头开始遍历</li>
</ul>
</li>
</ul>
<h2 id="4-Merging-pages"><a href="#4-Merging-pages" class="headerlink" title="4. Merging pages"></a>4. Merging pages</h2><h3 id="a-要修改的文件-3"><a href="#a-要修改的文件-3" class="headerlink" title="a. 要修改的文件"></a>a. 要修改的文件</h3><ul>
<li>src&#x2F;simpledb&#x2F;index&#x2F;BTreeFile.java</li>
</ul>
<h3 id="b-实现说明-3"><a href="#b-实现说明-3" class="headerlink" title="b. 实现说明"></a>b. 实现说明</h3><ul>
<li><p>在<code>mergeLeafPages()</code>和<code>mergeInternalPages()</code>方法中，我们需要编写合并页的代码，有效地执行<code>splitLeafPage()</code>和<code>splitInternalPage()</code>相反操作。<code>deleteParentEntry</code>方法在处理不同的递归情况时非常有用。确保在删除页时调用<code>setEmptyPage()</code>方法以使它们可以被重用。与前面的练习相似，这推荐使用BTreeFile.getPage()方法获取页面并使脏页列表保持最新。</p>
</li>
<li><p>实现BTreeFile.mergeLeafPages()和BTreeFile.mergeInternalPages()。</p>
</li>
</ul>
<h3 id="c-实现目标-3"><a href="#c-实现目标-3" class="headerlink" title="c. 实现目标"></a>c. 实现目标</h3><ul>
<li><p>通过BTreeFileDeleteTest.java中的所有单元测试。</p>
</li>
<li><p>通过systemtest&#x2F;BTreeFileDeleteTest.java中的系统测试。</p>
</li>
</ul>
<h3 id="d-实现记录-3"><a href="#d-实现记录-3" class="headerlink" title="d. 实现记录"></a>d. 实现记录</h3><ul>
<li><p>合并两个Page：mergeLeafPages()和mergeInternalPages()</p>
<ul>
<li>将左Page中的元组全部加入到右Page，修改左右Page的兄弟指针，最后调用setEmptyPage()将右Page置空，并删除parentEntry。</li>
</ul>
</li>
<li><p>void mergeLeafPages()</p>
<ul>
<li><p>将rightPage中的所有元组插入到leftPage中</p>
</li>
<li><p>修改leftPage和rightPage右边的Page的兄弟指针</p>
</li>
<li><p>调用setEmptyPage()将rightPage置空</p>
</li>
<li><p>调用deleteParentEntry()删除父entry</p>
</li>
</ul>
</li>
<li><p>void mergeInternalPages()</p>
<ul>
<li><p>先将父entry插入到leftPage</p>
</li>
<li><p>再将rightPage中的所有元组插入到leftPage中</p>
</li>
<li><p>调用setEmptyPage()将rightPage置空</p>
</li>
<li><p>调用deleteParentEntry()删除父entry</p>
</li>
<li><p>最后调用updateParentPointers，更新leftPage中所有entry的父节点信息</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h2><ul>
<li>通过next-key lock，B+树可以防止在两次连续范围扫描之间出现幻读的问题。由于SimpleDB使用页面级、严格的两阶段锁定，因此如果B+树实现正确的话，那就可以有效地防止幻读发生。因此，我们的B+树实现代码应该通过<code>BTreeNextKeyLockingTest</code>测试.</li>
<li>此外，如果我们在B+树代码中正确地实现锁，那么我们的代码也应该通过单元测试<code>test/simpledb/BTreeDeadlockTest.java</code></li>
<li>如果所有练习都正确地实现，那么我们应该能够通过BTreeTest系统测试。通过该测试可能需要几分钟的时间。</li>
</ul>
<h2 id="6-Bonus-Exercise"><a href="#6-Bonus-Exercise" class="headerlink" title="6. Bonus Exercise"></a>6. Bonus Exercise</h2><ul>
<li>创建并实现一个名为BTreeReverseScan的类，该类在给定一个可选的IndexPredicate后，反向扫描BTreeFile。</li>
<li>你可以使用BTreeScan作为起点，但你可能需要在BTreeFile中实现一个反向迭代器。你也可能需要实现一个单独的BTreeFile.findLeafPage()版本。我们已经在BTreeLeafPage和BTreeInternalPage上提供了反向迭代器，你可能会发现它很有用。你还应该编写代码来测试你的实现是否正常工作。BTreeScanTest.java是一个寻找思路的好地方。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>BTreePage中有4种Page，分别为BTreeRootPtrPage、BTreeHeaderPage、BTreeLeafPage和BTreeInternalPage。其中，BTreeLeafPage为叶子节点，BTreeInternalPage为非叶子结点。</p>
</li>
<li><p>一个表中一个Field对应一个B+树，BTreeRootPtrPage中的root指向根节点。BTreeRootPtrPage只保存9个字节的信息，共3个属性：root为根节点对应的page number，rootCategory为根节点的类型（中间节点或叶子节点），header为BTreeHeaderPage对应的page number。</p>
</li>
<li><p>getParentWithEmptySlots中，若parentId.pgcateg()为ROOT_PTR，说明是根节点需要访问其父节点，也就是parentId无法直接获取到对应的Page，因此需要新建一个空节点，作为根节点的父节点，再返回这个新的节点。</p>
</li>
<li><p>BTreeHeaderPage为Header，多个Header组成一个Header链表，通过prevPage和prevPage可以获取到下一个HeaderPage。BTreeRootPtrPage中的header指向第一个HeaderPage的page number。Header除了指向上一个和下一个HeaderPage的指针外，其余空间全部用于位图，与HeapPage相同，每一bit都指明该tuple是否为空。</p>
</li>
<li><p>位图中tuple的顺序是物理存储的顺序，但是不是查找时的逻辑顺序。</p>
</li>
<li><p>原本BufferPool、TableStats等文件中，会将Page强转为HeapPage（或DbFile强转为HeapFile），在使用B+树存储时不适用。因此取消强转，需要时直接调用B+树的相关方法。</p>
</li>
<li><p>测试结果：</p>
</li>
</ul>
<p><img src="/2023/12/14/SimpleDB-Lab5/1701780989752-3bb916ad-cf7a-4bd4-8794-578424342e95.png" alt="image.png"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>SimpleDB-Lab5</p><p><a href="http://hyeee.me/2023/12/14/SimpleDB-Lab5/">http://hyeee.me/2023/12/14/SimpleDB-Lab5/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hyeee</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-14</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/DataBase/">DataBase</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/12/22/SimpleDB-Lab6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SimpleDB-Lab6</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/12/08/SimpleDB-Lab4/"><span class="level-item">SimpleDB-Lab4</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-14T13:25:26.000Z">2024-02-14</time></p><p class="title"><a href="/2024/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">计算机网络知识点整理</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-02T07:32:46.000Z">2024-02-02</time></p><p class="title"><a href="/2024/02/02/Icarus%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/">Icarus主题美化</a></p><p class="categories"><a href="/categories/%E5%85%B6%E4%BB%96/">其他</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-22T14:25:46.000Z">2023-12-22</time></p><p class="title"><a href="/2023/12/22/SimpleDB-Lab6/">SimpleDB-Lab6</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-14T14:25:46.000Z">2023-12-14</time></p><p class="title"><a href="/2023/12/14/SimpleDB-Lab5/">SimpleDB-Lab5</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-08T14:25:46.000Z">2023-12-08</time></p><p class="title"><a href="/2023/12/08/SimpleDB-Lab4/">SimpleDB-Lab4</a></p><p class="categories"><a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%85%B6%E4%BB%96/"><span class="level-start"><span class="level-item">其他</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%A1%86%E6%9E%B6/"><span class="level-start"><span class="level-item">框架</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"><span class="level-start"><span class="level-item">算法导论</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE/"><span class="level-start"><span class="level-item">项目</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DataBase/"><span class="tag">DataBase</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Django/"><span class="tag">Django</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lombok/"><span class="tag">Lombok</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nexo/"><span class="tag">nexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%BD%91/"><span class="tag">计网</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo_pikachu.svg" alt="Hyeee&#039;s Home" height="28"></a><p class="is-size-7"><span>&copy; 2024 Hyeee</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>