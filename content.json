{"posts":[{"title":"C++运算符重载","text":"关于运算符重载12345678Box operator+(const Box&amp; b){ Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box;} this为运算符前对象，b为运算符后对象。 如：Box3 = Box1 + Box2;Box1为this，Box2为b。也由此可知，运算符重载中传入参数只能放于运算符后。因此，对于想改变运算顺序的运算符重载，必须使用友元函数。而使用友元函数时，也要注意： 当重载为成员函数时，会隐含一个this指针；当重载为友元函数时，不存在隐含的this指针，需要在参数列表中显示地添加操作数。 参考资料：C++ 二元运算符重载C++ 操作符重载形式——成员函数 or 友元函数","link":"/2019/02/01/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"Django项目总结","text":"概述题目：基于bytom信息流的新闻聚合网站。问题说明：本系统首先需要通过网络爬虫爬取Bytom发布在各个平台的内容信息，通过对这些信息的分类，可以清晰的展示，帮助人们更好的获取到信息。因为种种原因报名了python程序设计挑战赛，所以才有了这个项目。事实证明，人可能要有点自知之明…不管怎样，过程中间还是学到了一些的（大概）。 忏悔本来准备时间是一个月，但是因为期中考、出去玩以及犯懒等等私人原因，到ddl前3天才真正开始做，导致各种睡眠不足，水课补作业补到头疼。下次一定不拖到ddl了（这个flag我就立这儿了）。 分工因为之前接触过一点前端（而且感觉比较简单好学一些…html、css什么的），所以初步定是我负责前端，另俩人分别负责后台和爬虫。结果负责后台的小伙伴咕咕了好久…所以后台最后也差不多是我和另一个人完成的。 反省在完成项目的过程中，有遇到许多小问题，感觉下次可以改进一些。 用github远程仓库因为全部从0开始学，有很多参考网上的代码，对于那个实际效果其实是不确定的，因此需要不断地测试（也有可能就我）。github可以记录每次更新的功能，还可以版本回退…是个好东西啊。（但我因为犯懒之前没搞…导致用了复制压缩包存档的蠢办法） coding代码托管现在才突然发现这个和git仓库是两回事…之前我一直以为是一个东西。不管怎样，反正多人合作的话，需要一个能共同记录的东西（对…因为之前没搞，导致各种qq文件满天飞，文件的重命名看得我心好累）。 规划好项目结构这次毕竟完成的很匆忙，很多功能直接照搬别人，但自己在写的过程中又会有很多想法涌现（最后因技术不到位夭折了…）。应该在一开始就确定整个项目的构建。（毕竟是第一次，我就原谅自己啦！） 好好学习还是懂的太少了…完成的很心累，因为很多是按照自己的思路来走，每一个小问题都需要上网查，还会有很多意想不到的bug…上网查找能力也要加强啊…在好不容易找到网上一篇思路基本类似的一系列文章的时候，那一部分的代码已经勉勉强强完成了（心痛）。 项目总结其实从这里才算步入正题… 思路基本照搬别人（学长）的想法。 功能：***1.***首页显示各网址及其跳转链接，并对根据网址获取来源添加对应的标签***2.***可通过导航栏对不同来源网址进行分类（这里学长是设置的只有用户登录才有这个功能，但我们是对所有用户开放）***3.***收藏喜欢的网页，并在可在个人收藏查看（学长设置的只有登录用户有这个功能，但因为一些原因，我们实现的是对所有用户开放，但非登录用户只有临时收藏的功能（一刷新就没了））***4.***用户的登录及注册功能 还存在的bug：***1.***页面跳转过程中闪现的情况***2.***页脚不固定在底部***3.***导航栏中因为出现滚动条导致的页面布局稍有变化（发现全是前端的锅…） 需完善的功能：***1.***用户注册时邮箱的格式验证及密码的长度、格式检测后期可以考虑实现的功能：***1.***对首页的各项链接通过不同的方式排序，例如发表时间***2.***对首页的各项链接进行分页展示（这个学长完成了）***3.***对各项链接可以进行搜索（这个前期的页面实现了…但因为时间不够技术不足等不可抗因素被暂时搁浅）***4.***用户登录后的功能完善，例如个人信息的更改***5.***实时爬取数据（这个我反正做不了…）***6.***对于不同数据展示评论、喜欢等人数（这个学长也实现了）7. … …（感觉可完成的还有好多好多啊…毕竟我们做的只是最简陋的还充满bug的小项目） 实际项目进程时间顺序：5.16以前：写爬虫的小伙伴好像开始的比较早…他应该之前就写了一些了。但我在这之前只是看过一些关于django的入门教程，以及红家的项目，参考了一下前端代码。5.16：看了学长的完成页面，参考一下，开始写页面。初步页面布局就废了我一个下午加晚上，所有功能都没有实现。5.17、5.18：基本完成功能。（我实在记不得了…果然还是用git的好！） 项目完成顺序：***1.***爬虫获取网页数据（后期也有完善）***2.***首页、用户登录、用户注册页面布局***3.***导航栏功能实现***4.***收藏功能实现（临时用户）***5.***用户登录、注册实现***6.***用户的个人收藏功能实现 完成过程中遇到的问题及解决办法***1.***前端布局中div、文本等居中问题解决办法：用flex布局、text-align、margin、绝对位置解决反省：css还是用不熟练，天知道我仅仅为了把东西布局到页面正中花了多少心思。可以考虑多参考其他网页的页面布局以及多练手。 ***2.***导航栏实现不同链接展示问题问题：一开始使用.append方法增加html内容，后来发现这样页面信息无法保存。解决办法：给不同标签的链接加上不同class，点击时分别显示对应的内容，其他的隐藏。反省：可能还是写得少看得少，这个办法我也是自己想的，不晓得其他人怎么解决的，不管怎样，最终效果达到了（就是过程充满艰辛…）。 ***3.***未登录时使用临时收藏夹跳出提示框题外话：一开始的提示框太难看了，又没法修改内容，于是想自己写一个。问题：提示框的出现用下降实现，但会有一直点就一直下降问题。解决办法：直接上代码$('.alert').css(&quot;top&quot;, 50+&quot;px&quot;).show().animate({top:&quot;+=20px&quot;}, 100);反省：嗯…写代码要靠脑子的（要么有强大的搜索能力应该也行…但我没） ***4.***临时收藏功能题外话：说了个实话，这个功能跟我一开始想的不一样…是因为一开始没考虑到记录用户到数据库的问题，所以想用这个实现，算阴差阳错吧。问题：一开始不知道怎么实现增加对应的div的class解决办法：直接上代码 12345678910$('.icon').on('click', function () { var b_src = $(this).attr('src'); if(b_src == '/static/imgs/collect1.png'){ $(this).attr('src', '/static/imgs/collect0.png'); $(this).parent().removeClass('hascolloect'); }else if(b_src == '/static/imgs/collect0.png'){ $(this).attr('src', '/static/imgs/collect1.png'); $(this).parent().addClass('hascolloect'); } }) 注：这不是最终完成代码，只截取了涉及本问题部分。（重点：用.parent()解决）反省：有的时候真是为自己的机智折服…（没别的本事，只能在这种小小的问题上高兴一下下） ***5.***登陆后显示功能列表题外话：显示的问题的话在网上找到了直接的解决办法问题：判断用户是否登录，若登录则显示功能列表，用本身logined的判断不成功解决办法：用$('#login').text().indexOf(&quot;Hello&quot;) &gt;= 0判断，完整代码如下： 12345678910111213141516171819202122$('.collect').hide();if($('#login').text().indexOf(&quot;Hello&quot;) &gt;= 0){ var timer; $('#login').mouseover(function () { clearTimeout(timer); $('.collect').show(); }) $('#login').mouseout(function () { timer = setTimeout(function () { $('.collect').hide(); }, 50); }) $('.collect').mouseover(function () { clearTimeout(timer); $('.collect').show(); }) $('.collect').mouseout(function () { timer = setTimeout(function () { $('.collect').hide(); }, 50); })} ***6.***用户的个人收藏传递到后台题外话：这个问题可多…我几乎是要从开始到放弃到自闭，好在后台数据库的问题小伙伴解决了，只剩前端传参的问题（虽然这也是个可大的问题…一开始小伙伴想到用form表单解决，解决是解决了，但带来的问题更多，我又不想修复这方面的bug，坚信ajax可以解决这个问题的！）问题：用ajax传参不成功（html500错误码）解决办法：上代码 12345678910111213function add_fav(fav_id){ $.ajax({ cache: false, type: &quot;post&quot;, url: &quot;{% url &quot;stars&quot; %}&quot;, data:{'fav_id': fav_id}, async: true, beforeSend:function(xhr, settings){ xhr.setRequestHeader(&quot;X-CSRFToken&quot;, &quot;{{ csrf_token }}&quot;); }, });}add_fav($(this).parents().children('.webid').text()); 注：我一开始一直以为是url的问题（实际应该也有问题），改了半天，检查发现提交到./star/这个地址去了，而不是我所想的使用view.py里的star这个方法。后来发现小伙伴一开始给的路径没配置好，这个方法本来就需要路径实现，最终url填的就是实现这个方法的路径。顺带一提，网上说cache: false,这一句去掉也会报html500错误码。且这一句不加会有跨域的错误。小问题1：传参数据不对问题描述：一开始用，检查的时候才发现获取不到信息。解决办法：我在前端页面加了一个不可见的标签，里面内容为,之后再用.text()获取里面的信息。反省：我真的想知道别人是怎么解决这个问题的…要不然我真觉得自己可机智了小问题2：后台获取信息有误题外话：这咱真不知道什么情况，咱也不敢问…我是看着小伙伴的代码直接复制粘贴的。解决办法： 1exist = record.fav.get(id=int(fav_id)) 改为 1234try: exist = record.fav.get(id=int(fav_id))except: exist = None 小问题3：对应修改的用户和实际信息不匹配解决办法： 1username = request.POST.get('username', None) 改为 1user=request.session['user_name'] 反省：咱啥也不知道… ***7.***用户数据传递到后台后，在前端显示收藏情况问题描述1：在个人收藏页面只显示收藏数据，点击导航栏又可以显示全部链接，需在同一个页面实现解决办法：用了两个for循环，分别加不同的class，在点击个人收藏后，隐藏包含全部链接的for循环的元素；点击导航栏时，隐藏包含收藏链接的for循环的元素。问题描述2：在点击导航栏后，需要判断元素是否为收藏，然后显示相应的图标。解决办法：在包含全部链接的for循环中加一层判断，再加一层包含收藏链接的for循环，如果两个元素相同，说明该元素被收藏，显示被收藏图标，否则在循环结束后显示未被收藏图标。代码如下（包含1、3问题的解决）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455{% for web in c_Webs %}&lt;div class=&quot;conitem con{{ web.type }} collectcon&quot;&gt; &lt;p class=&quot;urlitem&quot;&gt; &lt;p style=&quot;display: none&quot; class=&quot;webid&quot;&gt;{{ web.id }}&lt;/p&gt; &lt;img src=&quot;/static/imgs/collect1.png&quot; class=&quot;icon&quot;&gt; &lt;a href=&quot;{{ web.urls }}&quot;&gt; {{ web.title }} &lt;/a&gt; {% ifequal web.type 'bilibili'%} &lt;span class=&quot;from&quot;&gt;bilibili&lt;/span&gt; {% endifequal %} {% ifequal web.type 'jianshu'%} &lt;span class=&quot;from&quot;&gt;简书&lt;/span&gt; {% endifequal %} {% ifequal web.type 'weibo'%} &lt;span class=&quot;from&quot;&gt;微博&lt;/span&gt; {% endifequal %} {% ifequal web.type 'github'%} &lt;span class=&quot;from&quot;&gt;github&lt;/span&gt; {% endifequal %} &lt;/p&gt;&lt;/div&gt;{% endfor %}{% for web in Webs %}&lt;div class=&quot;conitem con{{ web.type }} normalcon&quot;&gt; &lt;p class=&quot;urlitem&quot;&gt; &lt;p style=&quot;display: none&quot; class=&quot;webid&quot;&gt;{{ web.id }}&lt;/p&gt; {% if c_Webs %} {% for item in c_Webs %} {% ifequal web item %} &lt;img src=&quot;/static/imgs/collect1.png&quot; class=&quot;icon hascollect&quot;&gt; {% endifequal %} {% endfor %} &lt;img src=&quot;/static/imgs/collect0.png&quot; class=&quot;icon nocollect&quot;&gt; {% else %} &lt;img src=&quot;/static/imgs/collect0.png&quot; class=&quot;icon nocollect&quot;&gt; {% endif %} &lt;a href=&quot;{{ web.urls }}&quot;&gt; {{ web.title }} &lt;/a&gt; {% ifequal web.type 'bilibili'%} &lt;span class=&quot;from&quot;&gt;bilibili&lt;/span&gt; {% endifequal %} {% ifequal web.type 'jianshu'%} &lt;span class=&quot;from&quot;&gt;简书&lt;/span&gt; {% endifequal %} {% ifequal web.type 'weibo'%} &lt;span class=&quot;from&quot;&gt;微博&lt;/span&gt; {% endifequal %} {% ifequal web.type 'github'%} &lt;span class=&quot;from&quot;&gt;github&lt;/span&gt; {% endifequal %} &lt;/p&gt;&lt;/div&gt;{% endfor %} 注：其中一长串的ifequal判断是用来加文本标签的，与本问题无关问题描述3：在实际写的过程中，因为问题2的解决方法带来了新的问题，就是根据循环中相同两个元素相同的次数会显示对应次数的图标。解决办法：给所有图标加上class注明该图标是否被收藏，若被收藏则不显示未被收藏的图标。代码如下： 123if($('.icon').hasClass('hascollect')){ $('.hascollect').parents().children('.nocollect').hide();} 反省：有的时候真是不知道是自己太傻，没见过真正有效率的解决方法，还是说有点机智，对于各种bug都想到了解决方法…***8.***最后发现一个…凡是实现不同显示的问题，都可以用添加、删除class解决！ 个人总结因为这个真的耗费了挺大心力的…（虽然主要是因为前期不作为导致后来赶工赶得要死）在星期四、星期五基本满课，以及上周末犯懒没写物理作业的极度困难情况下，硬是挤出时间（在水课上写了好多…）勉勉强强完成了这个项目（虽然后面改bug的时候已经超过截止时间了…）最后写这个总结也花了我一上午…总的来说还是有收获的吧，果然还是要好好学习啊…接下去我又要面对各种因为这个而拖欠的作业了…以及期末各种大作业。啊，人生…","link":"/2019/05/01/Django%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"Effective C++笔记","text":"01：把c++视为一个语言联邦02：尽量以const, enum, inline替代#define1. 对于单纯变量，最好用const对象或enum替换#define​ #define由预处理器进行处理，因此可能不被编译器看见。当获得编译器错误信息时无法追踪（通过#define定义的变量可能未进入记号表）。而使用const对象则不会出现这样的问题。 ​ 并且，#define无法限制作用域。当需要定义class的专属常量时，可以通过const定义，并且为了保证此常量至多一个实体，可以将其定义为static类型。 ​ 旧式编译器可能不支持static在声明式中获得初值，那么可以将初值放在定义式。在此情况下，如果class编译期间需要用到class的常量（例如用class常量来定义class内数组的大小），则可以使用“the enum hack”补偿做法，这是因为一个属于枚举类型的数值可以被当作int使用。例如： 12345class GamePlayer {private: enum { NumTurns = 5}; int scores[NumTurns];} ​ “enum hack”某些方面比较像#define，比如取地址不合法，也不会导致非必要的内存分配。 2. 对于形似函数的宏，最好用inline函数替代#define​ 宏不会带来函数调用的额外开销，但是容易出问题。比如必须记住给所有实参加上小括号，但即时加上括号也会出现问题，例如： 12345#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))int a = 5, b = 0;CALL_WITH_MAX(++a, b); //a被累加2次CALL_WITH_MAX(++a, b + 10); //a被累加1次 ​ 可以使用template inline函数代替，这样不需要给每个实参加上小括号，也不需要操心参数被运算多次，例如： 12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a, const T&amp; b){ f(a &gt; b ? a : b);} 03：尽可能使用const1. 将某些东西声明为const可以帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型和成员函数本体。​ const允许指定一个语义约束，即该对象不可被改变，而编译器会确保这项约束。通过返回const对象，可以避免一些错误，例如： const Taritonal operator* (const Rational&amp; lhs, const Rational&amp; rhs)返回const对象，如果用户将 if (a * b == c) 误输入成 if (a * b = c) 时，编译器可以察觉这种错误。若不返回const对象，则对返回值赋值的行为是允许的，也就是编译器会通过这种错误的行为。 ​ 因此，除非需要改变参数或对象，否则应该将其声明为const。 ​ 可以将成员函数声明为const，这将能改动对象和不可以改动对象的函数区分开来。并且，将成员函数声明为const有利于提高c++程序效率（通过pass by reference-to-const的方式传递对象）。两个只有常量性不同的成员函数（即一个为const成员函数，另一个不是）可以被重载。具体调用哪个函数取决于处理的对象是否为const。 2. 编译器强制实行“bitwise constness”，但编程时应该更多采用“logical constness”。​ “bitwise constness”指的是const成员函数不改变任何一个non-static的成员变量。但是一些成员函数不具备const性质却不会引起编译器错误。例如： 若指向非常量的常量指针，只有指针属于对象，则改变该指针所指向的对象不会引起编译器错误（常量指针只确保指针指向同一个对象，不保证指向的对象的内容不改变）。例如： 1234567class CTextBlock {public: char&amp; operator[] (std::size_t position) const { return pText[position]; }private: char* pText;} 这样一个const成员函数，它的返回值实际上可以被改变。这就导致了编译器无法提示的错误。 ​ “logical constness”指的是const成员函数可以修改其对象内的某些内容，但是客户端无法侦察到（读了好多遍没读懂，应该是这个意思吧）。 ​ （这里有个例子，但我没搞明白为什么这个成员函数需要修改对象但是却声明为const，然后再通过mutable来消除const的约束） 3. 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。​ 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本是个安全的做法，即使在这个过程中需要转型。因为const成员函数相当于保证了绝不改变对象，但是non-const成员函数并没有保证。因此令non-const版本调用const版本成员函数不会带来风险，但是反之则可能会使const成员函数改变对象，造成错误。 ​ 例如： 123456789101112131415161718class TextBlock {public: const char&amp; operator[](std::size_t position) const { //边界检测 //日志数据访问 //检验数据完整性 return text[position]; } char&amp; operator[](std::size_t position) { return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt;(*this) [position] ); }} ​ 添加const的转型为安全转型，因此使用static_cast，移除const是通过const_cast完成。 04：确定对象被使用前已经先被初始化1. 为内置型对象进行手工初始化，因为C++不保证初始化它们。​ 读取未初始化的值会导致不确定的行为。如果使用C part of C++且初始化可能带来运行成本时，就无法保证初始化。 ​ 对于内置类型，手工完成初始化；对于其他类型，在构造函数内保证将对象的每一个成员初始化。 1int x = 0; //内置类型初始化 2. 构造函数最好使用成员初始列，而不要在构造函数内使用赋值操作。初始列列出的成员变量，其排列顺序应该和它们在class中的声明次序相同。​ 赋值和初始化操作容易混淆。例如： 123456789class ABEntry {public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;}; 赋值操作： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0;} 成员初始列： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) :theName(name), theAddress(address); thePhones(phones); numTimesConsulted(0){ } ​ 两个构造函数的结果相同，但是成员初始列的效率较高。赋值操作首先调用默认构造函数为theName、theAddress和thePhones设初值，然后再赋予新值。而成员初始列是以name、address和phones为初值对theName、theAddress和thePhones调用拷贝构造函数。因此后者较为高效。 ​ 并且，成员初始列也能够调用默认构造函数，只需要不指定初始化实参即可。例如： 123456ABEntry::ABEntry() :theName(), theAddress(); thePhones(); numTimesConsulted(0) // 这里不知道为什么不调用默认初始化函数{ } ​ 如果成员变量是const或者引用类型，则一定需要初值，而不能被赋值。 ​ 如果class内有多个构造函数，可以将一些“赋值表现和初始化一样好”的成员变量不使用成员初始列，而是改用赋值操作。并且可以将赋值操作移到某个函数（通常private）来供所有构造函数调用。 3. 为避免“跨编译单元的初始化次序”问题，使用local static对象替换non-local static对象。​ C++有固定的“成员初始化”次序：基类早于派生类被初始化，成员变量以声明的次序初始化。因此，成员初始列最好以成员变量的声明次序为次序。但是对于不同编译单元的“non-local static”对象，仍然可能出现初始化次序的问题。 ​ 编译单元指的是产出单一目标文件的源码，通常是单一源码文件加上包含的头文件。static对象的生命周期是从构造出来到程序结束。函数内的static对象称为local static对象，其他称为non-local static对象。因此，可能遇到的问题是：某个编译单元对象的初始化用到了另一个编译单元的non-local static对象，但是不能保证该non-local static对象已经被初始化，因此可能结果出错。例如： 123456class FileSystem {public: std::size_t numDisks() const; ...};extern FileSystem tfs; 12345678910class Directory {public: Directory( params ); ...};Directory::Directory( params ) { std::size_t disks = tfs.numDisks(); ...}Directory tempDir( params ); ​ 如上，想要程序正确运行就需要确保tfs在tempDir之前初始化，但是C++对这里的次序并没有明确定义，也就是无法保证。 ​ 解决方式是使用单例模式的一个常见实现方法：将non-local static对象放在函数内实现，函数再返回一个引用对象指向它所含的对象。因为C++保证函数内的local static对象会在“函数调用期间”“首次遇到该对象的定义式”的时候被初始化，因此可以保证通过函数调用获取的对象的引用一定完成了初始化。并且，如果不调用这个函数，那么构造函数和析构函数的成本也不需要了，相比于local static对象可以节省开销。用例如下： 1234567891011121314class FileSystem { ... };FileSystem&amp; tfs() { static FileSystem fs; return fs;}class Directory { ... };Directory::Directory( params ) { std::size_t disks = tfs().numDisks(); // 调用tfs对象改为调用tfs()函数 ...}Directory&amp; tempDir() { static Directory td; return td;} ​ 但是这种含有static对象的函数在多线程系统中存在不确定性：任何一种non-const static对象（不管local还是non-local）在多线程环境下“等待某件事发生”都会存在麻烦。处理这种麻烦的方式之一是：在程序的单线程启动阶段手工调用所有这种返回引用对象的函数，这样就可以消除初始化有关的“竞速形势”（race conditions）。 05：C++默默编写并调用的函数编译器可以为class自动创建默认构造函数、拷贝构造函数、拷贝赋值函数和析构函数。 所有构造的这些函数都是public且inline的。 只有当这些函数被调用的时候才会被编译器创建出来。 除非class的基类自身声明了virtual析构函数，否则编译器产生的析构函数是non-virtual类型。 只要自己声明了一个构造函数，那么编译器就不会自动创建默认构造函数。 编译器创建的拷贝构造函数和拷贝赋值函数只是单纯将来源对象的每一个non-static成员变量拷贝到目标对象。例如 12345678910template&lt;typename T&gt;class NamedObject {public: NamedObject(const char* name, const T&amp; value); NamedObject(const std::string&amp; name, const T&amp; value); ...private: std::string nameValue; T objectValue;}; 12NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2);NamedObject&lt;int&gt; no2(no1); // 调用拷贝构造函数 ​ no2是通过拷贝构造函数初始化的：no2.nameValue以no1.nameValue调用string的拷贝构造函数，no2.objectValue这里的类型为内置类型int，因此通过“拷贝no1.objectValue内的每一个bit”来完成初始化。 如果编译器自动创建的拷贝构造函数和拷贝赋值函数不合法，那么就不会自动创建。例如： 123456789template&lt;typename T&gt;class NamedObject {public: NamedObject(std::string&amp; name, const T&amp; value); ...private: std::string&amp; nameValue; // 修改为指向string的引用 const T objectValue; // 修改为const类型}; 12345std::string newDog(&quot;Persephone&quot;);std::string oldDog(&quot;Satch&quot;);NamedObject&lt;int&gt; p(newDog, 2);NamedObject&lt;int&gt; s(oldDog, 36);p = s; ​ 如果自动创建了拷贝赋值函数，那么p.nameValue就改为s.nameValue，也就是引用的指向被改变了，但是这是不合法的。因此C++不会为NamedObject自动创建拷贝赋值函数。对于含有const成员的class，编译器也不会自动创建。此外，对于将拷贝赋值函数声明为private的基类，其派生类将不会被自动创建拷贝赋值函数。 06：若不想使用编译器自动生成的函数，则该明确拒绝​","link":"/2023/02/01/Effective%20C++%E7%AC%94%E8%AE%B0/"},{"title":"Effective Modern C++笔记","text":"零. 绪论 左值和右值 概念上，右值对应的是函数返回的临时对象，左值对应的是可指涉的对象（通过名字、指针或左值引用） 甄别方式：能取得地址的为左值。 右值引用类型的形参，该形参本身也是左值。 任何形参都是左值 若某对象是依据同一类型的另一对象初始化出来的，则该新对象称为原对象的一个副本。右值的副本通常由移动构造函数创建，左值的副本通常由复制构造函数创建。 函数对象 指某个对象，其类型支持operator()成员函数。 lambda表达式 创建的函数对象称为闭包。 定义和声明 定义可以当声明用。 函数的形参类型和返回值类型视为函数签名，而函数名字和形参名字不属于函数签名。 一. 类型推导01. 理解模板类型推导​ 在编译期，编译器会通过expr推导两个类型：T的类型和ParamType的类型。这两个类型完全往往不一样，因为ParamType通常包括一些修饰词。 123456// 函数模板template&lt;typename T&gt;void f(ParamType param);// 函数调用f(expr); ​ T的类型的推导结果需要分三种情况讨论： ParamType具有指针或者引用类型，但不是万能引用。 ParamType是一个万能引用。 ParamType既不是指针也不是引用。 - 在模板类型推导过程中，具有引用类型的实参会被当作非引用类型来处理，即其引用性会被忽略。 ​ ParamType具有指针或者引用类型，但不是万能引用时，推导过程如下： 若expr有引用类型，则忽略引用。 对expr和ParamType的类型进行模式匹配，得到T的类型。 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为int&amp;f(cx); // T类型为const int，param类型为const int&amp;f(rx); // T类型为const int，param类型为const int&amp; ​ 向T&amp;类型模板传入const对象是安全的，因为常量性会称为T的类型的一部分。 ​ 若是传给右值引用形参，则推导过程与左值引用相同。 ​ 若把形参类型加上const，则结果如下： 12345678910111213// 函数模板template&lt;typename T&gt;void f(const T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为const int&amp;f(cx); // T类型为int，param类型为const int&amp;f(rx); // T类型为int，param类型为const int&amp; ​ 若param为指针，则推导过程也相同： 1234567891011// 函数模板template&lt;typename T&gt;void f(T* param);// 声明变量int x = 27;const int *px = &amp;x;// 函数调用f(&amp;x); // T类型为int，param类型为int*f(px); // T类型为const int，param类型为const int* - 对万能引用进行推导时，左值实参会进行特殊处理。 ​ ParamType是一个万能引用时，类型推导过程如下： 若expr是左值，则T和ParamType都被推导为左值引用。 若expr是右值，则推导过程与之前相同。 ​ 在expr为左值的情况比较特殊：首先，这是唯一一种T被推导为引用类型的情况；其次，声明的时候采用右值引用语法，但类型推导却是左值引用。 ​ 例如： 1234567891011121314// 函数模板template&lt;typename T&gt;void f(T&amp;&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // x为左值，T类型为int&amp;，param类型为int&amp;f(cx); // cx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(rx); // rx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(27); // 27为右值，T类型为int，param类型为int&amp;&amp; - 对按值传递的形参进行推导时，若实参类型中带有const或volatile修饰，则忽略该修饰词。 ​ ParamType既不是指针也不是引用时，其实就是按值传递，无论传入什么，param都会是一个副本。推导过程如下： 若expr有引用类型，则忽略引用； 若expr是const对象，则忽略const； 若expr是volatile对象，则忽略volatile。 ​ 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T和param类型为intf(cx); // T和param类型为intf(rx); // T和param类型为int ​ 虽然cs和rx有const属性，但是param是完全独立于它们的存在，是它们的副本，因此可以忽略const属性。 ​ 但是const属性只有在按值传递时被忽略，若形参为引用或者指针则const会被保留。但是要额外考虑expr时指向const对象的const指针这种情况： 123456789// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量const char* const ptr = &quot;pointer&quot;;// 函数调用f(ptr); // T和param类型为const char* ​ 也就是说，ptr自身的const属性会被忽略，但是指向对象的const属性会被保留。 - 在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非被用来初始化引用。 ​ 某些情况下，数组会退化成指向其首元素的指针。例如： 12const char name[] = &quot;J. P. Briggs&quot;; // name类型为const char[13]const char *ptrToName = name; // 数组退化成指针 ​ 当数组传递给按值形参的模板时，形参T的类型会被推导为指针类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T param);// 函数调用f(name); // T类型为const char* ​ 但是如果按引用方式传递参数，形参T类型就会被推导为实际的数组类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 函数调用f(name); // T类型为const char[13]，param类型为const char (&amp;)[13] ​ 因此可以用这个能力创建出模板推导数组含有的元素个数： 123456789// 该数组形参未起名字，因为不需要template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;}// 调用函数构建相同大小的数组int keyVals[] = { 1, 2, 3, 4, 5, 6, 7 };std::array&lt;int, arraySize(keyVals)&gt; mappedVals; ​ 除了数组外，函数类型也会退化成函数指针。推导过程与数组相同。例如： 12345678910void someFunc(int, double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc); // param的类型为函数指针，具体为void (*)(int, double)f2(someFunc); // param的类型为函数引用，具体为void (&amp;)(int, double) 02. 理解auto类型推导- 一般情况下，auto类型推导和模板推导是一样的。但是auto类型推导会假定使用大括号的初始化表达式代表std::initializer_list，模板类型推导不会。 ​ 一般情况下，auto类型推导和模板推导是完全相同的。例如： 1234567auto x = 27; // x类型为intconst auto cx = x; // cx类型为const intconst auto&amp; rx = x; // rx类型为const int&amp;auto&amp;&amp; uref1 = x; // x类型为int，且是左值，则uref1类型为int&amp;auto&amp;&amp; uref2 = cx; // cx类型为const int，且是左值，则uref2类型为const int&amp;auto&amp;&amp; uref3 = 27; // 27类型为int，且是右值，则uref3类型为int&amp;&amp; ​ 但是以下这种情况不同： 12345678910111213141516171819// C++98中的初始化方式int x1 = 27;int x2(x1);// C++11中新增了用大括号初始化的方法，结果与上面相同。int x3 = { 27 };int x4{ 27 };// 通过auto推导类型auto x1 = 27; // 类型为intauto x2(x1); // 类型为intauto x3 = { 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27auto x4{ 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27// 通过模板推导类型auto x = { 11, 23, 9 }; // auto推导类型为std::initializer_list&lt;int&gt;template&lt;typename T&gt;void f(T param);f({ 11, 23, 9 }); // 模板推导类型错误，代码不能通过编译 ​ 对于大括号初始化的表达式，auto类型会推导为std::initializer_list&lt;T&gt;类型（T的类型推导为模板推导，也就是需要用到两种类型推导），而模板推导类型则会失败，编译错误。 - 在函数返回值或者lambda表达式形参中使用auto，意思是使用模板推导而不是auto推导。 ​ C++14允许使用auto说明函数返回值或者lambda表达式形参的类型需要推导，但是这里是用模板推导类型的。例如： 123456789// 函数返回值为autoauto createInitList() { return { 1, 2, 3 }; // 错误，无法完成类型推导}// lambda表达式形参中使用autostd::vector&lt;int&gt; v;auto resetV = [&amp;v](const auto&amp; newValue) { v = newValue; };resetV({ 1, 2, 3 }); // 错误，无法完成类型推导 03. 理解decltype- 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。 ​ C++11中，decltype的主要用途大概在于，声明返回值类型依赖于参数类型的函数模板。例如C++11中利用返回值类型尾序语法（trailing return type syntax）声明返回值的类型，这样的好处是，在指定返回值类型时可以使用函数形参。例如： 12345678910111213141516// C++11中使用返回值类型尾序语法（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt; decltype(c[i]) { authenticateUser(); return c[i];}// C++14中可以直接使用auto推导类型（有错误，不能正确运行）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 一般来说，含有类型T的对象的容器，其operator[]会返回T&amp;。std::deque是这样，std::vector几乎总是这样，只有std::vector&lt;bool&gt;不返回bool&amp;，而是返回全新的对象。因此，对于第二段代码，operator[]会返回T&amp;，但是auto类型推导的过程中会忽略expr的引用性，这样返回值类型就变成了T。作为函数的返回值，这里的T为右值，因此无法被赋值，因此有错误。 - C++14支持的decltype(auto)，这样的类型推导使用decltype的规则 ​ 想要authAndAccess返回左值，则可以对返回值使用decltype类型推导。可以通过decltype(auto)来使用decltype的规则进行类型推导。因此可以修改为： 1234567// C++14中可以直接使用auto推导类型（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 但是这样仍然有改进空间。这是因为，容器的传递方式是对非常量的左值引用，但是右值是无法绑定到左值引用的（除非是对常量的左值引用），这样就不能往函数中传递右值容器。可以通过重载维护两个函数，分别声明左值引用形参和右值引用形参。然而，也可以通过万能引用，这种引用形参既能够绑定到左值也能够绑定到右值。 ​ 使用万能引用的话需要应用std::forward（*不知道是什么）。这样可以得到最终修改的版本： 12345678910111213141516// C++14中可以直接使用auto推导类型（最终版）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];}// C++11中使用返回值类型尾序语法（最终版）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp;&amp; c, Index i) -&gt; decltype(std::forward&lt;Container&gt;(c)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} - 对于类型为T的表达式，除非该表达式仅有一个名字，否则decltype得出类型为T&amp; ​ 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。但是对于一个不仅仅是T的名字的表达式，decltype得出类型为T&amp;。例如： 12345678910111213// decltype(x)为int，f1返回intdecltype(auto) f1(){ int x = 0; return x;}// decltype((x))返回int&amp;，f2返回int&amp;decltype(auto) f2(){ int x = 0; return (x);} ​ 这不仅仅是返回类型的错误，f2实际上返回了局部变量的引用，这是非常危险的行为。 04. 掌握查看类型推导结果的方法- 利用IDE编辑器、编译器错误信息和Boost.TypeIndex库常常能查看到推导得到的类型。 - 有些工具可能不准确，因此理解C++类型推导规则是必要的。 ​ 采用那种工具查看类型推导结果取决于在开发过程中的哪个阶段需要该信息： 代码撰写阶段：IDE编辑器 ​ 鼠标悬停时可以查看。原理是让C++编译器在IDE内执行一轮，因此代码需要处在可编译的状态。例如： 123const int theAnswer = 42;auto x = theAnswer; // x类型为intauto y = &amp;theAnswer; // y类型为const int* 编译阶段：编译器诊断信息 ​ 可以通过该类型导致某些编译错误，而报告错误的消息几乎肯定会提及导致该错误的类型。例如： 123// 声明类模板，但是不定义它。template&lt;typename T&gt;class TD; ​ 这样就可以通过TD查看x和y的类型： 12TD&lt;decltype(x)&gt; xType;TD&lt;decltype(y)&gt; yType; ​ 这样编译器会报错，错误信息中会指出x和y的类型。 运行阶段：运行时输出 ​ 可以通过typeid和std::type_info::name查看类型信息，例如： 12std::cout &lt;&lt; typeid(x).name() &lt;&lt; '\\n'; // GNU和Clang：x类型为i，即intstd::cout &lt;&lt; typeid(y).name() &lt;&lt; '\\n'; // GNU和Clang：y类型为PKi，即int const*(PK: pointer to konst const涉及到常量的指针) ​ 但是这样有可能会输出不准确的信息，例如： 12345678template&lt;typename T&gt;void f(const T&amp; param);std::vector&lt;Widget&gt; createVec();if(!vw.empty()) { f(&amp;vw[0]);} ​ 通过typeid和std::type_info::name查看T和param的类型： 1234567template&lt;typename T&gt;void f(const T&amp; param) { using std::cout; cout &lt;&lt; &quot;T = &quot; &lt;&lt; typeid(T).name() &lt;&lt; '\\n'; // T = class Widget const * cout &lt;&lt; &quot;param = &quot; &lt;&lt; typeid(param).name() &lt;&lt; '\\n'; // param = class Widget const *} ​ 输出结果如上，但是结果是错误的。param的类型为const Widget * const &amp;，但是被报告成const Widget *。这是因为通过这种方式推导得到类型和向函数模板传参是一样的，按值传参时会忽略掉const、volatile和&amp;这些修饰词。 ​ 可以通过Boost的TypeIndex库查看，虽然这不是标准C++的一部分（IDE和TD也不是）。使用方法例如： 12345678910111213#include &lt;boost/type_index.hpp&gt;template&lt;typename T&gt;void f(const T&amp; param){ using std::cout; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;T = &quot; &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; '\\n'; // T = Widget const* cout &lt;&lt; &quot;param = &quot; &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; '\\n'; // param = Widget const* const&amp;} 二、auto05. 优先选用auto，而不是显式类型声明- auto变量必须初始化。使用auto基本可以避免因为类型不匹配而导致的兼容性和效率问题，还可以简化重构流程，并且代码量更少。 - auto类型也存在着一些问题（如02和06） ​ auto类型可以节省代码量，不用费大心思思考变量类型，例如： 12345678910template&lt;typename It&gt;void dwim(It b, It e) { while(b != e) { auto currValue = *b; // 等价于 // typename std::iterator_traits&lt;It&gt;::value_type currValue = *b; ... }} ​ 另外，对于std::function，使用auto类型也有非常大的优势。例如： 1234auto derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ std::function是C++11标准库中的一个模板，把函数指针的思想加以推广，可以指向任何可以调用的对象。比如，std::function可以指向lambda表达式。上述用例就可以表示为： 12345std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ 但是跟auto类型声明相比： auto声明的变量所要求的内存量与lambda表达式相同，而std::function声明的变量是其实例，所以占有固定内存。因此，std::function一般占用更多内存。 编译器一般会产生间接函数调用，通过std::function调用lambda表达式几乎必然会比auto声明更慢。 另外，auto声明还可以避免一些不明确类型所产生的错误。例如： 12std::vector&lt;int&gt; v;unsigned sz = v.size(); // v.size()为std::vector&lt;int&gt;::size_type，向unsigned隐式转换。 ​ std::vector&lt;int&gt;::size_type是无符号整型。在32位Windows上，unsigned和std::vector&lt;int&gt;::size_type尺寸相同，但是64位Windows上，unsigned是32位而std::vector&lt;int&gt;::size_type是64位，因此可能出错。 ​ 再比如： 123std::unordered_map&lt;std::string, int&gt; m;for(const std::pair&lt;std::string, int&gt;&amp; p : m){ ... } // 代码有问题for(const auto&amp; p : m){ ... } // 用auto声明可以避免这个问题 ​ 这里std::unordered_map的键值部分是const，也就是里面的键值对类型实际上为std::pair&lt;const std::string, int&gt;。上述代码实际上会对m中每一个对象进行复制操作，将p绑定到产生的临时对象上。 并且，auto可以简化重构流程。比如函数本来声明的返回类型为int，后续改为long时，使用auto声明返回值只需要重新编译便可以直接更新。 06. 当auto推导的类型不符合要求时，使用显式类型的初始化方法- “隐形”的代理类型可能会导致auto推导出“错误的”类型 ​ 举例来说： 123456789std::vector&lt;boo&gt; features(const Widget&amp; w);Widget w;bool highPriority = feature(w)[5];processWidget(w, highPriority);// 若使用auto类型声明auto highPriority = feature(w)[5];processWidget(w, highPriority); // 未定义的行为 ​ 实际上，highPriority的返回值不是bool类型。对于其他类型，std::vector::operator[]都返回容器内一个元素的引用，但是std::vector&lt;bool&gt;返回的是std::vector&lt;bool&gt;::reference对象。这是一个代理类的实例。代理类指的是为了模拟或者增广其他类型的类，比如智能指针也是代理类。有些代理类比较明细那，但是有些是“隐形代理”，难以察觉。这种类的对象往往生命周期只有单个语句，因此容易出现创建这种类型容易出现未定义的行为。 ​ 在上述例子中，auto实际推断的类型是std::vector&lt;bool&gt;::reference，是一个临时对象，在语句结束时就被析构，因此之后会产生未定义的行为。 - 带显式类型的初始化方法可以强制推导出想要的类型 ​ 可以通过带显式类型的初始化方法来避免上述问题。使用方法如下： 1auto highPriority = static_cast&lt;bool&gt;(feature(w)[5]); // std::vector&lt;bool&gt;::reference被强制转换为bool类型 ​ 除了能够避免隐形代理类产生的问题，还可以用来强调变量进行了类型转换。例如： 1234567double calcEpsilon();// float的精度足够，并且在意变量的存储空间大小的情况下，可以用float类型存储该返回值float ep = calcEpsilon();// 与上面意思相同，但是强调了“降低返回值精度”auto ep = static_cast&lt;float&gt;(calcEpsilon()); 三、转向现代C++07. 创建对象时注意区分()和{}To be continued","link":"/2023/04/04/Effective%20Modern%20C++%E7%AC%94%E8%AE%B0/"},{"title":"GitHub下载速度太慢的解决方式","text":"一、修改host文件1.访问https://www.ipaddress.com/。 2.查询github.com和github.global.ssl.fastly.net的对应ip地址。 3.进入目录C:\\Windows\\System32\\drivers\\etc，以管理员权限打开hosts文件。 4.将查询到的ip地址加入hosts文件。例如： 12140.82.112.4 github.com199.232.69.194 github.global.ssl.fastly.net 5.在powershell打开执行命令，刷新DNS 缓存。 1ipconfig /flushdns 二、从gitee下载1.点击从GitHub\\GitLab导入仓库。 2.输入Git仓库URL。 3.直接执行git clone xxxx(gitee仓库的地址)。","link":"/2020/12/13/GitHub%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"},{"title":"IDEA已有maven插件但mvn出错","text":"mvn命令找不到是因为maven环境变量未配置，因此需配置环境变量。 1.找到IDEA下的maven位置例如：D:\\IntelliJ IDEA 2019.3.3\\plugins\\maven\\lib\\maven3 2.配置环境变量（1）右键此电脑的属性。 （2）点击高级系统设置。 （3）点击环境变量。 （4）点击新建。 （5）输入变量名MAVEN_HOME和变量值（IDEA下的maven位置）。 （6）点击编辑。 （7）点击新建，新增%MAVEN_HOME%\\bin项。 （8）点击确定，完成环境变量设置。","link":"/2020/12/13/IDEA%E5%B7%B2%E6%9C%89maven%E6%8F%92%E4%BB%B6%E4%BD%86mvn%E5%87%BA%E9%94%99/"},{"title":"Icarus主题美化","text":"本文面向前端小白！仅记录自己修改的部分！ 个人主题配置​ 主要就是修改_config.icarus.yml文件，具体主题配置可以参考Icarus用户指南。 网页显示的图标 123# _config.icarus.ymlhead: favicon: /img/pikachu.svg Logo修改 12# _config.icarus.ymllogo: /img/logo_pikachu.svg 网页显示的标题 12# _config.ymltitle: Hyeee's Home 网页显示的语言 可以在node_modules\\hexo-theme-icarus\\languages目录下查看可用的语言 PS：如果找不到相应的语言，会自动选择德语（经验之谈） 12# _config.ymllanguage: zh-CN 个人信息修改 1234567widgets: - author: Hyeee author_title: '|ू･ω･` )' location: Hangzhou, China avatar: /img/avatar_pikachu.jpg follow_link: https://github.com/HeeeeH 其他一些七七八八的，比如cookie、赞赏、评论什么的不太会就先全部注释掉啦 加入背景图片 将背景图片放到node_modules\\hexo-theme-icarus\\source\\img目录下 修改node_modules\\hexo-theme-icarus\\include\\style\\base.styl文件，在body样式下加入以下几行 12345body ... ... background: url(../img/background_op.png) no-repeat background-attachment: fixed background-size: cover background的属性说明 url：图片路径（这里填的是相对路径） attachment ：图片是否滚动（fixed为 不滚动，scoll 为滚动） size：图片大小（原始尺寸为 auto ，覆盖为 cover ，拉伸为 contain 等） PS：背景图片的不透明度有点难调，所以我选择PS手动调节(。-`ω´-) 标签颜色更改​ 主题的颜色定义在node_modules\\hexo-theme-icarus\\include\\style\\base.styl中，可以将$primary直接修改为想要的颜色。例如： 1$primary ?= $yellow ​ 但是这样的修改不全面，还有很多地方的颜色是硬编码。这里记录一下我修改的地方： base.styl: $navbar-item-active-color $menu-item-active-color $menu-item-active-background-color article.styl article &amp;.media color article &amp;.media a &amp;:hover color helper.styl .link-muted &amp;:hover color navbar.styl .navbar-main .navbar-item &amp;.is-active color .navbar-main .navbar-item &amp;.hover color PS：找不到对应元素的标签或class怎么办？ 可以通过F12，选中页面元素查看对应元素的标签以及class，然后直接修改在自定义的custom.styl中。 // 例如修改导航栏悬浮时的颜色 a.navbar-item:hover, .navbar-link:hover, a.navbar-item.is-active, .navbar-link.is-active { background-color: #fafafa; color: #ff9600; } 12345- 再在node_modules\\hexo-theme-icarus\\source\\css\\style.styl文件中引入custom.styl。 - ```stylus @import './custom' TODO 夜间模式 评论 参考文章icarus用户指南-主题配置 活用 Bulma 美化 Icarus 文章 icarus主题自定义 Hexo-icarus主题黑夜模式以及背景","link":"/2024/02/02/Icarus%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"title":"Java刷题基础语法","text":"一、Java集合概览​ Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。 ​ Java 集合框架如下图所示： List：存储的元素是有序的、可重复的。 ArrayList：Object[] 数组。 Vector：线程安全，使用 synchronized 进行同步，了解即可。 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。 Set：存储的元素不可重复的。 HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。 Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 PriorityQueue: Object[] 数组来实现小顶堆。 DelayQueue:PriorityQueue。 ArrayDeque: 可扩容动态双向数组。 Map：使用键值对（key-value）存储。key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 HashMap：JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：LinkedHashMap 在 HashMap的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。 二、常见数据结构及用法1. 数组1）赋值 初始化时直接赋值 1int[] intArray = new int[]{1, 2, 3, 4}; 通过 Java Util 类的 Arrays.fill(arrayname,value) 12345int[] intArray = new int[10];// Arrays.fill(arrayname, value) Arrays.fill(intArray, 100);// Arrays.fill(arrayname, starting index, ending index, value) Arrays.fill(intArray, 3, 6, 50); 注：Arrays.fill只能给一维数组赋初值，二维数组需要循环赋值。如下： 1234int[][] intArray = new int[10][10];for(int i = 0; i &lt; intArray.length; ++i) { Arrays.fill(intArray[i], 100);} 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intArray.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intArray) { System.out.println(a);} 3）数组复制 直接赋值（没有拷贝） intArray2和intArray1是指向同一个数组对象的。 12int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = intArray1; System.arraycopy（浅拷贝） 方法：arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = new int[5];System.arraycopy(intArray1, 0, intArray2, 0, intArray1.length); Arrays.copyOf和Arrays.copyOfRange（浅拷贝） 方法：copyOf(T[] original, int newLength)和copyOfRange(T[] original, int from, int to) 如果newLength不合法，即小于0，那么抛出NegativeArraySizeException异常 如果newLength小于源数组长度，则复制指定长度的数组元素 如果newLength大于源数组长度，则新数组中超出源数组长度的元素则是默认值 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = Arrays.copyOf(intArray1, intArray1.length);int[] intArray3 = Arrays.copyOfRange(intArray1, 0, intArray1.length); 对象拷贝（Object.clone） clone()比较特殊，对于对象而言，它是深拷贝，但是对于数组而言，它是浅拷贝。拷贝数组时会返回一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 4）Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 能够给数组赋值、对数组排序、比较数组和查找数组元素。具体如下表： 方法 说明 int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。也可以调用**binarySearch(Object[], int fromIndex, int toIndex, Object key)**在指定位置查找给定值。 boolean equals(long[] a, long[] a2) 若两个数组以相同顺序包含相同的元素，则两个数组是相等的。适用于所有的其他基本数据类型。 void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。适用于所有的其他基本数据类型。 void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。适用于所有的其他基本数据类型。可以传入方法指定按照特定方法排序。例如，Collections.reverseOrder()进行反向排序；String.CASE_INSENSITIVE_ORDER进行忽略大小写排序。 String toString(Object[] a) 能将数组中的内容全部打印出来。适用于所有的其他基本数据类型。 举例如下： 12345678910111213int[] intArray = new int[5];// 调用Arrays.fill进行赋值Arrays.fill(intArray, 4);// 调用Arrays.sort进行排序Arrays.sort(intArray);// 调用Arrays.sort从指定位置进行排序Arrays.sort(intArray, 2, 4);// 调用Arrays.sort进行反向排序Arrays.sort(intArray, Collections.reverseOrder());// 调用Arrays.binarySearch查找指定元素System.out.println(Arrays.binarySearch(arr, 30));// 调用Arrays.toString打印数组元素System.out.print(Arrays.toString(intArray)); 5）数组与List之间相互转换- 对象数组转为基本数据类型数组 stream流执行转换 1int[] intArray = integerArray.stream().mapToInt(Integer::valueOf).toArray(); - 基本数据类型数组转为对象数组 stream流执行转换 1Integer[] integerArray = Arrays.stream(intArray).boxed().toArray(Integer[]::new); - 对象数组转为List 最常见方式，但不支持增删（会抛异常） 1List intList = Arrays.asList(intArray); 数组转为List后，支持增删改查的方式 1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(Arrays.asList(intArray)); 通过集合工具类Collections.addAll()方法（最高效） 12ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(intArray.length);Collections.addAll(intList, intArray); 使用stream中的collector 1List&lt;Integer&gt; intList = Arrays.stream(intArray).collect(Collectors.toList()); - List转为对象数组 toArray()方法，需要传入对应的对象数组构造函数并指定数组的长度 1Integer[] intArray = intList.toArray(new Integer[intList.size()]); stream流的toArray()方法，需要传入对应对象的构造方法的方法引用 1Integer[] intArray = intList.stream().toArray(Integer[]::new); - List转为基本数据类型数组 stream流执行转换 123456// 方法引用int[] intArray1 = intList.stream().mapToInt(Integer::intValue).toArray();// lambda表达式int[] intArray2 = intList.stream().mapToInt(i-&gt;i).toArray();// 先使用filter过滤int[] intArray3 = intList.stream().filter(integer -&gt; integer!=null).mapToInt(i-&gt;i).toArray(); - 基本数据类型数组转为List stream流执行转换 123List&lt;Integer&gt; intList1 = Arrays.stream(intArray).mapToObj(Integer::new).collect(Collectors.toList());// 采用boxed装箱List&lt;Integer&gt; intList2 = Arrays.stream(intArray).boxed().collect(Collectors.toList()); 利用CollectionUtils集合工具类进行转换 1List&lt;Integer&gt; intList = CollectionUtils.arrayToList(intArray); 2. 列表 List1）Collection通用方法： Collection 接口 方法 元素个数 size() 是否为空 isEmpty() 是否包含某元素 contains(Object o) 迭代器 iterator() 清空所有元素 clear() 转为数组 toArray() 增加元素 add(E e) 删除元素 remove(Object o) 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intList.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intList) { System.out.println(a);} for-each遍历 1intList.forEach(a -&gt; System.out.println(a)); 3）排序 使用List.sort排序。 可以使用lambda函数按照指定顺序排序。例如： 123List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();// 按照从大到小的顺序排序intList.sort((o1, o2) -&gt; o2 - o1); 使用Collections.sort排序。 同样可以使用lambda函数按照指定顺序排序。例如： 1234567891011List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();Collections.sort(intList);// 按照从大到小的顺序排序Collections.sort(intList, (o1, o2) -&gt; o2.compareTo(o1));// 这等价于Collections.sort(intList, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); }}); 4）Collections工具类 排序操作 123456void reverse(List list)//反转void shuffle(List list)//随机排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j)//交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 查找,替换操作 1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 3. 队列 Queue1）基础队列Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。 Queue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 2）优先队列 PriorityQueuePriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。方法与Queue相同。 PriorityQueue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 利用Lambda表达式自定义比较函数。例如： 1PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((o1, o2)-&gt;o2-o1); 这等价于： 12345678PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;( new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); 注：Java中默认为小根堆，C++中默认为大根堆。 3）双端队列 DequeDeque 是双端队列，在队列的两端均可以插入或删除元素。 Deque 扩展了 Queue 的接口，增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类： Deque 接口 抛出异常 返回特殊值 插入队首 addFirst(E e) offerFirst(E e) 插入队尾 addLast(E e) offerLast(E e) 删除队首 removeFirst() pollFirst() 删除队尾 removeLast() pollLast() 查询队首元素 getFirst() peekFirst() 查询队尾元素 getLast() peekLast() 4. 栈 StackStack继承自Vector，与Vector一样使用synchronized关键字修饰来保证线程安全，但也因此效率低下。因此，在实际应用中多采用Deque来实现栈的功能。例如： 1Deque deque = new LinkedList&lt;Integer&gt;(); 另外，从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。ArrayDeque 也可以用于实现栈。使用如下： 1Deque deque = new ArrayDeque&lt;Integer&gt;(); 当作为栈使用时，可以采用如下方法： Deque 接口 抛出异常 返回特殊值 入栈 push(E e) 出栈 pop() poll() 查看栈顶 element() peek() 5. 字符串 String 方法说明 方法 指定索引处的 char 值 char charAt(int index) 字符串长度 int length() 判断字符串是否为空 boolean isEmpty() 返回字符串的副本，忽略前导空白和尾部空白。 String trim() 将String 中的所有字符都转换为小写 String toLowerCase() 将String 中的所有字符都转换为大写 [String toUpperCase() 比较两个字符串 int compareTo(String anotherString) 比较两个字符串是否相等 boolean equals(Object anObject) 连接字符串 String concat(String str) 将此字符串转换为一个新的字符数组 char[] toCharArray() 返回一个新的字符串，是此字符串的子字符串 String substring(int beginIndex) String substring(int beginIndex, int endIndex) 字符串是否有指定前缀/后缀 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) 指定字符第一次出现的索引 int indexOf(String str) int indexOf(String str, int fromIndex) 指定字符最后一次出现的索引 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换字符串 String replace(char oldChar, char newChar) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分字符串 String[] split(String regex) String[] split(String regex, int limit) 6. 字典 Map1）基本操作 方法说明 方法 map的长度 size() 插入元素 put(Object key, Object value) 获取元素 get(Object key) 移除元素 remove(Object key) 清空map clear() map是否为空 isEmpty() 是否包含指定key containsKey(Object key) 是否包含指定value containsValue(Object value) 2）排序1234567Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;((o1, o2)-&gt;o2-o1);// 这等价于Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { return o2.compareTo(o1); }}); 3）for循环遍历- keySet()遍历123456789for (String key : map.keySet()) { System.out.println(key + &quot; ：&quot; + map.get(key));}// 这等价于Iterator&lt;String&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) { String key = iterator.next(); System.out.println(key + &quot; ：&quot; + map.get(key));} - entrySet()遍历123456789for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());}// 这等价于Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) { Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());} - for-each遍历1map.forEach((k, v)-&gt;times.add(v)); 三、常用算法1. 通过stream()1）List取最值12intList.stream().max(Integer::compareTo).get();intList.stream().min(Integer::compareTo).get(); 2）List取平均值1intList.stream().mapToInt(Integer::intValue).average().orElse(0D); 3）List求和1integers.stream().reduce(Integer::sum).get(); 四、参考文档Java集合常见面试题总结 java中数组拷贝（深拷贝）的四种方法 Java map 详解 - 用法、遍历、排序、常用API等 Java8 stream平均值、最小数、最大数、求和","link":"/2023/05/01/Java%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"Lombok详解","text":"简介Lombok能通过注解的方式，在编译时自动为属性生成构造函数、getter/setter、equals、hashcode、toString等方法。奇妙之处在于源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁明了。 优缺点优点1）简化代码，提高效率 Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。 Lombok能通过注解的方式，在编译时自动为属性生成构造函数、getter/setter、equals、hashcode、toString等方法。奇妙之处在于源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁明了。 缺点1） 高侵入性，强迫队友 Lombok插件的使用，要求开发者一定要在IDE中安装对应的插件。不仅自己要安装，任何和你协同开发的人都要安装。如果有谁未安装插件的话，使用IDE打开一个基于Lombok的项目的话会提示找不到方法等错误，导致项目编译失败。更重要的是，如果我们定义的一个jar包中使用了Lombok，那么就要求所有依赖这个jar包的所有应用都必须安装插件，这种侵入性是很高的。 2）代码可调试性降低 Lombok确实可以帮忙减少很多代码，因为Lombok会帮忙自动生成很多代码。但是，这些代码是要在编译阶段才会生成的，所以在开发的过程中，其实很多代码其实是缺失的。这就给代码调试带来一定的问题，我们想要知道某个类中的某个属性的getter方法都被哪些类引用的话，就没那么简单了。 3） 影响版本升级 Lombok对于代码有很强的侵入性，就可能带来一个比较大的问题，那就是会影响我们对JDK的升级。按照如今JDK的升级频率，每半年都会推出一个新的版本，但是Lombok作为一个第三方工具，并且是由开源团队维护的，那么他的迭代速度是无法保证的。所以，如果我们需要升级到某个新版本的JDK的时候，若其中的特性在Lombok中不支持的话就会受到影响。还有一个可能带来的问题，就是Lombok自身的升级也会受到限制。因为一个应用可能依赖了多个jar包，而每个jar包可能又要依赖不同版本的Lombok，这就导致在应用中需要做版本仲裁，而我们知道，jar包版本仲裁是没那么容易的，而且发生问题的概率也很高。 4）注解使用有风险 在使用Lombok过程中，如果对于各种注解的底层原理不理解的话，很容易产生意想不到的结果。举一个简单的例子：我们知道，当我们使用@Data定义一个类的时候，会自动帮我们生成equals()方法 。但是如果只使用了@Data，而不使用@EqualsAndHashCode(callSuper=true)的话，会默认是@EqualsAndHashCode(callSuper=false)，这时候生成的equals()方法只会比较子类的属性，不会考虑从父类继承的属性，无论父类属性访问权限是否开放，这就可能得到意想不到的结果。 5）可能会破坏封装性 使用过程中如果不小心，在一定程度上就会破坏代码的封装性。举个简单的例子，我们定义一个购物车类，并且使用了@Data注解： 123456789@Datapublic class ShoppingCart { //商品数目 private int itemsCount; //总价格 private double totalPrice; //商品明细 private List items = new ArrayList&lt;&gt;();} 我们知道，购物车中商品数目、商品明细以及总价格三者之前其实是有关联关系的，如果需要修改的话是要一起修改的。但是，我们使用了Lombok的@Data注解，对于itemsCount 和 totalPrice这两个属性，虽然我们将它们定义成 private 类型，但是提供了 public 的 getter、setter 方法。 外部可以通过 setter 方法随意地修改这两个属性的值，我们可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。 而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。 好的做法应该是不提供getter/setter，而是只提供一个public的addItem方法，同时取修改itemsCount、totalPrice以及items三个属性。 因此，在此种情况下，就不适合使用Lombok，或者只用@Getter不用@Setter，而别直接使用@Data，在使用过程中，需要多多小心。 安装1. 安装插件Lombok插件支持Eclipse、IntelliJ IDEA、MyEclispe等IDE，在这里我们使用IntelliJ IDEA来演示安装： 1）打开File &gt; Settings &gt; Plugins &gt;Marketplace，搜索Lombok，如图，点击install，弹窗Accept，然后安装好后Restart IDEA。 2）设置Enable annotation processing 打开File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors，勾选Enable annotation processing，然后Apply和OK。 2. 导入jar包常用jar包引入方法有两种，如下： 方法1：普通项目可以直接官网下载jar包，和使用普通jar包一样，导入项目即可。jar下载地址：点击去下载 方法2：Maven项目可以在pom.xml中配置依赖坐标即可，依赖坐标如下： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 常用注解@NonNull@NonNull该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。 示例代码： 1234//成员方法参数加上@NonNull注解，构造方法也一样，在此不做演示public String getName(@NonNull Person p){ return p.getName();} 实际效果相当于： 123456public String getName(Person p){ if(p==null){ throw new NullPointerException(&quot;person&quot;); } return p.getName();} @Getter和@Setter使用此注解相当于为成员变量生成对应的get和set方法，方法默认修饰符为public，同时还可以使用AccessLevel为生成的方法指定访问修饰符。这两个注解还可以直接用在类上，可以为此类里的所有非静态成员变量生成对应的get和set方法。 示例代码： 1234567891011public class Student{ @Getter @Setter private String name; @Setter(AccessLevel.PROTECTED) private int age; @Getter(AccessLevel.PUBLIC) private String language;} @ToString使用此注解会自动重写对应的toStirng方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割，通过callSuper参数来指定是否引用父类，includeFieldNames参数设为true，就能明确的输出toString()属性。 示例代码： 12345678910111213141516171819202122@ToString(exclude=&quot;id&quot;)public class ToStringExample { private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() { return this.getName(); } @ToString(callSuper=true, includeFieldNames=true) public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.width = width; this.height = height; } }} 实际效果相当于： 123456789101112131415161718192021222324252627282930public class ToStringExample { private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() { return this.getName(); } public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.width = width; this.height = height; } @Override public String toString() { return &quot;Square(super=&quot; + super.toString() + &quot;, width=&quot; + this.width + &quot;, height=&quot; + this.height + &quot;)&quot;; } } @Override public String toString() { return &quot;ToStringExample(&quot; + this.getName() + &quot;, &quot; + this.shape + &quot;, &quot; + Arrays.deepToString(this.tags) + &quot;)&quot;; }} @NoArgsConstructor、@RequiredArgsConstructor和@AllArgsConstructor这三个注解都是用在类上的，第一个和第三个都很好理解，就是为该类产生无参的构造方法和包含所有参数的构造方法，第二个注解则使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法，当然，成员变量都是非静态的，另外，如果类中含有final修饰的成员变量，是无法使用@NoArgsConstructor注解的。 三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用@RequiredArgsConstructor(staticName=”methodName”)的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象。 示例代码： 12345678910@RequiredArgsConstructor(staticName = &quot;myShape&quot;)@AllArgsConstructor(access = AccessLevel.PROTECTED)@NoArgsConstructorpublic class Shape { private int x; @NonNull private double y; @NonNull private String name;} @Data@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。@Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 官方实例如下： 12345678910111213@Data public class DataExample { private final String name; @Setter(AccessLevel.PACKAGE) private int age; private double score; private String[] tags; @ToString(includeFieldNames=true) @Data(staticConstructor=&quot;of&quot;) public static class Exercise&lt;T&gt; { private final String name; private final T value; }} @SneakyThrows这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常，很简单的注解，直接看个例子： 1234567891011public class SneakyThrows implements Runnable { @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) { return new String(bytes, &quot;UTF-8&quot;); } @SneakyThrows public void run() { throw new Throwable(); }} 实际效果相当于： 1234567891011121314151617public class SneakyThrows implements Runnable { public String utf8ToString(byte[] bytes) { try{ return new String(bytes, &quot;UTF-8&quot;); }catch(UnsupportedEncodingException uee){ throw Lombok.sneakyThrow(uee); } } public void run() { try{ throw new Throwable(); }catch(Throwable t){ throw Lombok.sneakyThrow(t); } }} @Synchronized这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized得锁对象分别是私有静态final对象LOCK和私有final对象lock，当然，也可以自己指定锁对象，例子也很简单： 123456789101112131415161718public class Synchronized { private final Object readLock = new Object(); @Synchronized public static void hello() { System.out.println(&quot;world&quot;); } @Synchronized public int answerToLife() { return 42; } @Synchronized(&quot;readLock&quot;) public void foo() { System.out.println(&quot;bar&quot;); }} 实际效果相当于： 1234567891011121314151617181920212223public class Synchronized { private static final Object $LOCK = new Object[0]; private final Object $lock = new Object[0]; private final Object readLock = new Object(); public static void hello() { synchronized($LOCK) { System.out.println(&quot;world&quot;); } } public int answerToLife() { synchronized($lock) { return 42; } } public void foo() { synchronized(readLock) { System.out.println(&quot;bar&quot;); } } } @Log这个注解用在类上，可以省去从日志工厂生成日志对象这一步，直接进行日志记录，具体注解根据日志工具的不同而不同，同时，可以在注解中使用topic来指定生成log对象时的类名。不同的日志注解总结如下(上面是注解，下面是实际作用)： 1234567891011121314@CommonsLogprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);@JBossLogprivate static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);@Logprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());@Log4jprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);@Log4j2private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);@Slf4jprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);@XSlf4jprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 示例代码： 在实际的使用中完全做到了无缝衔接，与注释调到的功能完全等价，简洁而优雅 1234567891011@Controller@Slf4jpublic class SampleController { //private static Logger log= LogManager.getLogger(SampleController.class); @RequestMapping(&quot;/&quot;) public String home(ModelMap model) { log.info(&quot;aa&quot;); return &quot;main&quot;; }} @Builder建造者的模式一般是这样（减少了成员变量，只有一个成员变量一般不用此模式） 1234567891011121314151617181920212223242526272829303132public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(Builder builder) { this.name= builder.name; } public static Builder builder(){ return new Builder(); } public static class Builder{ private String name; public Builder name(String name) { this.name= name; return this; } public User build(){ return new User(this); } }} 使用了@Builder之后,只需要这样 123456@Builder@Getter@Setterpublic class User { private String name;} 二者调用方法相同 12345@Testpublic void main() throws Exception{ User user=User.builder().name(&quot;Asens&quot;).build(); System.out.println(user.getName());} 参考文章Lombok入门使用教程及其优缺点详解 Lombok指南","link":"/2023/09/22/Lombok%E8%AF%A6%E8%A7%A3/"},{"title":"MyBatis笔记","text":"简介MyBatis简介 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化和持久层 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 什么是持久层？ 完成持久化工作的代码块 —— dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念，而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】 为什么需要Mybatis？ Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) —&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！ MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 MyBatis示例程序1. 数据库代码12345678910CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`name`,`pwd`) values (1,'狂神','123456'),(2,'张三','abcdef'),(3,'李四','987654'); 2. maven配置12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 3. 编写MyBatis核心配置文件 mybatis-comfig.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注：springboot中配置放在application.yaml文件中 4. 编写MyBatis工具类12345678910111213141516171819202122import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //获取SqlSession连接 public static SqlSession getSession(){ return sqlSessionFactory.openSession(); }} 5. 创建实体类12345678public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString()} 6. 编写Mapper接口类12345import com.kuang.pojo.User;import java.util.List;public interface UserMapper { List&lt;User&gt; selectUser();} 7. 编写Mapper.xml配置文件123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 8. 编写测试类123456789101112131415public class MyTest { @Test public void selectUser() { SqlSession session = MybatisUtils.getSession(); //方法一: //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;); //方法二: UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); }} CURD操作select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 id 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 parameterType 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 resultType SQL语句返回值类型。【完整的类名或者别名】 示例程序：根据id查询用户 在UserMapper中添加对应方法： 123456public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id);} 在UserMapper.xml中添加Select语句： 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where id = #{id}&lt;/select&gt; 测试类中测试： 12345678@Testpublic void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();} 示例程序：根据密码和名字查询用户 在UserMapper中添加对应方法： 12345678public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id); //根据密码和名字查询用户 User selectUserByNP2(Map&lt;String,Object&gt; map);} 在UserMapper.xml中添加Select语句： 123&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd}&lt;/select&gt; 使用方法时： 1234Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;username&quot;,&quot;小明&quot;);map.put(&quot;pwd&quot;,&quot;123456&quot;);User user = mapper.selectUserByNP2(map); insert、update、delete增、删、改操作需要提交事务！ 与select操作类似。 MyBatis配置解析 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： 1234567891011121314configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件！【演示】 environments元素12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点：environment 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 1&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt; 详情：点击查看官方文档 这两种事务管理器类型都不需要设置任何属性。 子元素节点：数据源（dataSource） dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 1type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled： 这个数据源的实现只是每次被请求时打开和关闭连接。 pooled： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. mappers元素mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。 映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式12345678910111213141516171819202122232425&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; Mapper文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace和子元素的id联合保证唯一 , 区别不同的mapper 绑定DAO接口 namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 动态SQL简介什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。 表达式if 语句举例：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询。 123456789101112&lt;!--select * from blog where title = #{title} and author = #{author}--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog where &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/select&gt; 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select from user where title=#{title},但是如果title为空呢？那么查询语句为 select from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！ where语句修改上面的SQL语句； 1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。【这是我们使用的最多的案例】 Set语句同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？ 12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title}, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id};&lt;/update&gt; choose语句有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句。 12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #{title} &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/sql&gt; 引用SQL片段： 12345678&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意： ① 最好基于 单表来定义 sql 片段，提高片段的可重用性 ② 在 sql 片段中不要包括 where foreach语句举例：我们需要查询 blog 表中 id 分别为1,2,3的博客信息。 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧","link":"/2023/08/02/MyBatis%E7%AC%94%E8%AE%B0/"},{"title":"Mysql之windows10安装（8.0.17）","text":"1.下载文件下载网站：https://dev.mysql.com/downloads/mysql/ 2.配置文件(1)解压文件夹（2）右键新建txt文件，输入以下内容（注意basedir更改为mysql-8.0.17-winx64文件夹路径) 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB （3）将文件另存为my.ini 3.启动mysql数据库（1）在搜索栏输入cmd，右键命令提示符，以管理员身份运行（2）输入命令，切换成mysql目录（注意路径更改为自己mysql-8.0.17-winx64文件夹路径) 1C:\\Users\\Administrator&gt;cd C:\\Program Files\\MySQL\\bin (3)输入命令，初始化数据库执行完成后输出初始密码（如该初始密码为rI5rvf5x5G） 1234C:\\Program Files\\MySQL\\bin&gt;mysqld --initialize --console2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 49842018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server has completed （4）输入安装命令 1C:\\Program Files\\MySQL\\bin&gt;mysqld install （5）输入命令， 启动mysql服务 1C:\\Program Files\\MySQL\\bin&gt;net start mysql 4.登录mysql数据库(1)输入命令 1C:\\Program Files\\MySQL\\bin&gt;mysql -u root -p (2)输入密码 1Enter password: (3)密码输入正确后，出现 1mysql&gt; 安装部署就完成啦！","link":"/2021/01/03/Mysql%E4%B9%8Bwindows10%E5%AE%89%E8%A3%85%EF%BC%888.0.17%EF%BC%89/"},{"title":"Mysql之忘记密码重置（8.0.17）","text":"1.打开命令窗口cmd，输入命令，停止MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;net stop mysql 2.输入命令，开启跳过密码验证登录的MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysqld --console --skip-grant-tables --shared-memory 结果如图：3.再打开一个新的cmd，转到mysql/bin目录下输入 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysql 4.使用命令，将密码置为空 1mysql&gt;use mysql 1mysql&gt;update user set authentication_string='' where user='root'; 5.使用命令，退出mysql 1mysql&gt;quit 6.打开命令框，输入命令，启动MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;net start mysql (如果显示“发生系统错误”，可以使用任务管理器直接打开服务）7.输入登录命令，直接登录 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysql -u root -p 8.完成！ ​ ​","link":"/2021/02/01/Mysql%E4%B9%8B%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%EF%BC%888.0.17%EF%BC%89/"},{"title":"SSM框架概念","text":"SSM框架概述SSM框架是spring、spring MVC 和mybatis框架的整合，是标准的MVC模式。标准的SSM框架有四层，分别是dao层（mapper），service层，controller层和View层。使用spring实现业务对象管理，使用spring MVC负责请求的转发和视图管理，mybatis作为数据对象的持久化引擎。 SSM框架组成部分1）持久层：Dao层（mapper）层作用：主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此。 Dao层首先设计的是接口，然后再Spring的配置文件中定义接口的实现类。 然后可以在模块中进行接口的调用来进行数据业务的处理。（不在关心接口的实现类是哪个类） 数据源的配置以及有关数据库连接的参数都在Spring的配置文件中进行配置。 2）业务层：Service层作用：Service层主要负责业务模块的逻辑应用设计。 先设计接口然后再设计实类，然后再在Spring的配置文件中配置其实现的关联。（业务逻辑层的实现具体要调用到自己已经定义好的Dao的接口上）这样就可以在应用中调用Service接口来进行业务处理。 建立好Dao之后再建立service层，service层又要在controller层之下，因为既要调用Dao层的接口又要提供接口给controller层。每个模型都有一个service接口，每个接口分别封装各自的业务处理的方法。 3）表现层：Controller层（Handler层）作用：负责具体的业务模块流程的控制。 配置也同样是在Spring的配置文件里面进行， 调用Service层提供的接口来控制业务流程。 业务流程的不同会有不同的控制器，在具体的开发中可以将我们的流程进行抽象的归纳，设计出可以重复利用的子单元流程模块。 4）View层作用：主要和控制层紧密结合，主要负责前台jsp页面的表示。 其他概念说明POJO (Plain Ordinary Java Object, 简单Java对象)实际就是普通JavaBeans，是为了避免和EJB（Enterprise Java Beans 企业级JavaBeans）混淆所创造的简称，也称为（Plain Old Java Object 又普通又老的对象）。POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。 它仅包含自身的属性以及自身属性的getter和setter方法，这意味者POJO可以方便的从一个框架迁移到另一个框架中，或者框架升级也会对代码毫无影响，因此而得到复用。 一般，当需要持久化对象时，人们喜欢将该对象放在名为xxxPOJO的目录中。当然，不建议这样命名。POJO实际上是包括BO/VO/PO/DO等一系列对象的总称。有的团队规定禁止命名成xxxPOJO。 DO (Domain Object, 领域对象)领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 PO (persistence object, 持久层对象)PO是在ORM（对象关系映射）中与数据表的一条记录相匹配，自身属性与数据表字段一一对应。可以将数据表中的一条记录作为一个对象处理，并可以转化为其它对象。面对不同的数据源时，比如文档型数据库，对象型数据库等时，顾名思义PO是DAO层为进行持久化操作而准备的对象。 包含getter、setter方法。 不包含业务逻辑与数据库的访问方法。因为数据库本身不包含业务逻辑。 PO平常不一定需要实现序列化，只是当采用分布式存储或者需要作为前端输出及远程调用使用时，应该实现序列化。 DAO (data access object, 数据访问对象)包含对数据的访问，负责持久层的操作 。通常需要结合PO来访问数据库，主要用来封装对数据的访问，并不转化成其它对象。在基于“事务脚本”的业务设计时，它包含业务逻辑。否则，一般只包含持久化的封装。 DTO (Data Transfer Object, 数据传输对象)数据传输对象，是在应用网络层需要传输的对象，是一个为了减少方法调用次数而在进程间传输数据的对象。 在《阿里巴巴开发手册中》规定是Service 或 Manager 向外传输的对象。 某些人称这个为“值对象”，当然还是有稍许区别。值对象追求对象不可变，DTO的对象是可修改，可改变的。 VO (value object, 值对象）Value Object和View Object的简写都是VO，可能容易弄混。View Object的含义是通常是Web向模板渲染引擎层传输的对象。《阿里巴巴开发手册》中建议把输出的显示层对象命名为VO。当然，也有人把这个对象命名为DTO作为传输。 123456//Controller层public HttpResult list(@RequestBody XXParam param){ HttpResult vo=HttpResultUtils.convert(XXDTO); return vo;}12345 由于很多页面需要额外数据，比如错误码、提示信息、分页信息等，查询的DTO之后需要再封装成View Object 显示层对象再显示出来 参考文献SSM框架讲解（史上最详细的文章） 概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解 浅析DO、VO、DTO、PO的概念与区别","link":"/2023/08/15/SSM%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5/"},{"title":"SpringBoot笔记","text":"SpringBoot简介Spring介绍Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot？SpringBoot是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 Spring开发-HelloWord项目创建Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析：通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml 更改端口号在 application.properties文件中加入Server.port=8081。 更改Banner如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案； 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ pom.xml这里我们在引入一些SpringBoot依赖的时候,不需要指定版本,就因为父依赖有这些版本仓库，也就是核心依赖在父工程中。 其中它主要依赖一个父项目spring-boot-starter-parent，主要管理项目的资源过滤及插件。 点进去，发现还有一个父依赖spring-boot-dependencies。这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 启动器：说白了就是SpringBoot的启动场景 比如spring-boot-starter-web,会帮我们自动导入web环境所有的依赖 springboot会将所有功能场景,都变成一个个的启动器 我们要是用什么功能，就需要找到一个个启动器就可以了 主启动类123456789101112131415package com.example.springboot01helloworld;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//标注这个类是一个SpringBoot的应用@SpringBootApplicationpublic class Springboot01HelloworldApplication { public static void main(String[] args) { //通过这个方法将springboot启动 SpringApplication.run(Springboot01HelloworldApplication.class, args); }} @SpringBootConfiguration：SpringBoot的配置 @Configuration： spring配置类 @Component：说明这也是一个spring的组件 123456789- @EnableAutoConfiguration：自动配置 - ```java @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})：导入了选择器 @Import({AutoConfigurationImportSelector.class})：自动配置选择器 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); //获取所有的配置 获取候选的配置 123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; }12345 META-INF/spring.factories：自动配置的核心文件 SpringBoot所有的自动配置，都在启动类中被扫描并加载：所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的starter们就有对应的启动器了，有了启动器，我们的自动装配就会生效，然后就配置成功了 SpringBoot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值 将这些自动配置的类导入容器，自动配置类就会生效，帮我们进行自动配置 以前我们需要自动配置的东西，现在不需要了 整合javaEE，解决方案和自动配置的东西都在Spring-boot-autoconfigure下 它会把所有需要导入的组件，以类名的方式返回这些组件，这些组件就会被添加到容器 容器中也会存在非常多的XXXAutoConfigure的文件（@Bean），就是这个类给容器导入了这个场景所需要的所有组件并自动配置 SpringApplication开启了一个服务。 SpringApplication.run：分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； SpringApplication主要做了以下四件事情： 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 查看构造器： 1234567public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();} run方法流程分析 关于SpringBoot，谈谈你的理解： 自动装配：如何加载 run方法：如何启动 全面接管SpringMVC的配置！ yaml配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 yaml基础语法123456789101112131415161718# k-v键值对name: xiaoqi#相当于name=xiaoqi# 存对象student: name: xiaoqi age: 12 # 行内写法student1: {name: xiaoqi,age: 13}#数组pets: - cat - dog - pygpets1: [cat,dog] 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: qinjiang age: 3 行内写法 1student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 可以注入到我们的配置类当中 注入配置文件yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; yaml注入配置文件1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； 1234567891011package com.example.springboot02configure.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component//添加到spring组件中public class Dog { private String name; private Integer age;} 3、编写一个person类 12345678910111213141516171819202122package com.example.springboot02configure.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;} 4、 在yaml中写入对象 123456789101112Person: name: xiaoqi age: 13 happy: false birth: 2009/01/15 maps: {k1: v1,k2: v2} lists: - code - dog dog: name: qq age: 1 5、 在测试程序中测试 12345678910111213141516171819202122package com.example.springboot02configure;import com.example.springboot02configure.pojo.Dog;import com.example.springboot02configure.pojo.Person;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.swing.*;@SpringBootTestclass SpringBoot02ConfigureApplicationTests { @Autowired private Person person; @Test void contextLoads() { System.out.println(person); }} 加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 123456@PropertySource(value = &quot;classpath:person.properties&quot;)@Component //注册beanpublic class Person { @Value(&quot;${name}&quot;) private String name; ...... } 配置文件占位符配置文件还可以编写占位符生成随机 123456789101112Person: name: xiaoqi${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2009/01/15 maps: {k1: v1,k2: v2} lists: - code - dog dog: name: ${person.hello:other}_旺财 #如果hello没有那么就默认值hello+旺财 age: 1 对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 JSR303检验12345678910111213141516171819202122232425262728293031323334空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY.Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) Validates that the annotated string is between min and max included.日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 @Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。数值检查 建议使用在String,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为”“,Integer为null @Min 验证 Number 和 String 对象是否大等于指定的值 @Max 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min=, max=) 被指定的元素必须在合适的范围内 @Range(min=10000,max=50000,message=”range.bean.wage”) @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang= ,script=, alias=) @URL(protocol=,host=, port=,regexp=, flags=)]()]() 结论：配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 多环境切换profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： 123#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! 123456789101112server: port: 8081 ---server: port: 8082Spring: profiles: dev #命名 ---server: port: 8083 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 1234优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 自动配置原理配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 分析自动配置原理我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass({CharacterEncodingFilter.class})//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = {&quot;enabled&quot;}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; }} 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 12345//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties { // .....} 这就是自动装配的原理！ 精髓1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 使用debug=true可以查看哪些自动配置类生效，哪些没有生效。 MVC配置原理官网阅读在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration 12345678910111213141516171819202122232425262728293031323334353637383940Spring MVC Auto-configuration// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.// 自动配置在Spring默认设置的基础上添加了以下功能：The auto-configuration adds the following features on top of Spring’s defaults:// 包含视图解析器Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.// 支持静态资源文件夹的路径，以及webjarsSupport for serving static resources, including support for WebJars // 自动注册了Converter：// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】Automatic registration of Converter, GenericConverter, and Formatter beans.// HttpMessageConverters// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；Support for HttpMessageConverters (covered later in this document).// 定义错误代码生成规则的Automatic registration of MessageCodesResolver (covered later in this document).// 首页定制Static index.html support.// 图标定制Custom Favicon support (covered later in this document).// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document)./*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.123456789101112131415161718192021222324252627282930313233343536373839 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ ViewResolver 视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 1234567891011@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;}12345678910 自定义ViewResolverhttps://mp.weixin.qq.com/s/9AY48uLjR9bI9TUlulcBNA 转换器和格式化器修改SpringBoot的默认配置这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； 123456789101112//应为类型要求为WebMvcConfigurer，所以我们实现其接口//可以使用自定义类扩展MVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;); }}123456789101112 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： 1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 123456789101112public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }}1234567891011 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 1234protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry);}123 5、我们点进去看 123456789public void addViewControllers(ViewControllerRegistry registry) {Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); }}12345678 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 @EnableWebMvc 就是导入了一个 DelegatingWebMvcConfiguration 类，从容其中获取所有的webmvcconfig 在SpringBoot中由非常多的xxxConfiguration，会帮助我们进行扩展，只要看见了这个东西我们就要注意了 页面国际化https://mp.weixin.qq.com/s/e4Jd3xIMF4C4HBzPQfakvg 自定义starterhttps://mp.weixin.qq.com/s/2eB2uT088BvzaqRULezdsw 参考文章【狂神说】SpringBoot笔记整理","link":"/2023/09/15/SpringBoot%E7%AC%94%E8%AE%B0/"},{"title":"SpringMVC笔记","text":"什么是MVC？ MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 架构变迁Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 为什么要学SpringMVC?Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 中心控制器Spring的web框架围绕DispatcherServlet设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:808hello 如上url拆分成三部分： http://localhost:8080/ 服务器域名 SpringMVC 部署在服务器上的web站点 hello 表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 SpringMVC实现（注解版）1. 建立包结构 com.kuang.controller由于Maven可能存在资源过滤的问题，我们将配置完善 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 2. 配置web.xml注意点： 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; / *&lt;/ url-pattern &gt; 会匹配* .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 3. 添加Spring MVC配置文件 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 4. 创建Controller编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范 12345678910111213141516package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; }} @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 5. 创建视图层在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ${msg}&lt;/body&gt;&lt;/html&gt; 6. 配置Tomcat运行配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。 Controller 及 RestFul控制器Controller简介 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;} 示例程序 新建一个Moudle，springmvc-04-controller 。 将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 1234567891011//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ${msg}&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; 增加一个ControllerTest2类，使用注解实现； 123456789101112//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2{ //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; }} 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！除了这两种之外还有其他的方式，可以参考：https://www.cnblogs.com/hellokuangshen/p/11270742.html @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController { @RequestMapping(&quot;/h1&quot;) public String test(){ return &quot;test&quot;; }} 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(&quot;/admin&quot;)public class TestController { @RequestMapping(&quot;/h1&quot;) public String test(){ return &quot;test&quot;; }} 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能资源：互联网所有的事物都可以被抽象为资源资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询。 与传统方式对比传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET​ http://127.0.0.1/item/saveItem.action 新增,POST​ http://127.0.0.1/item/updateItem.action 更新,POST​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET​ http://127.0.0.1/item 新增,POST​ http://127.0.0.1/item 更新,PUT​ http://127.0.0.1/item/1 删除,DELETE 示例代码 在新建一个类 RestFulController 123@Controllerpublic class RestFulController {} 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 123456789101112@Controllerpublic class RestFulController { //映射访问路径 @RequestMapping(&quot;/commit/{p1}/{p2}&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; }} 我们来测试请求查看下，成功！ 使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等。 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = {RequestMethod.POST})public String index2(Model model){ model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;} 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = &quot;/hello&quot;,method = {RequestMethod.GET})public String index2(Model model){ model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;} 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个： 组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 平时使用的会比较多！ 结果跳转方式1. ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 对应的controller类 123456789public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 2. ServletAPI通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 1234567891011121314151617@Controllerpublic class ResultGo { @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); } @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(&quot;/index.jsp&quot;); } @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); }} 3. SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 123456789101112131415161718@Controllerpublic class ResultSpringMVC { @RequestMapping(&quot;/rsm/t1&quot;) public String test1(){ //转发 return &quot;/index.jsp&quot;; } @RequestMapping(&quot;/rsm/t2&quot;) public String test2(){ //转发二 return &quot;forward:/index.jsp&quot;; } @RequestMapping(&quot;/rsm/t3&quot;) public String test3(){ //重定向 return &quot;redirect:/index.jsp&quot;; }} 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 1234567891011121314@Controllerpublic class ResultSpringMVC2 { @RequestMapping(&quot;/rsm2/t1&quot;) public String test1(){ //转发 return &quot;test&quot;; } @RequestMapping(&quot;/rsm2/t2&quot;) public String test2(){ //重定向 return &quot;redirect:/index.jsp&quot;; //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ }} 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 123456//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 3、提交的是一个对象要求提交的表单域和对象的属性名一致 , 参数使用对象即可 实体类 12345678public class User { private int id; private String name; private int age; //构造 //get/set //tostring()} 提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 处理方法 : 12345@RequestMapping(&quot;/user&quot;)public String user(User user){ System.out.println(user); return &quot;hello&quot;;} 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView123456789public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 第二种 : 通过ModelMap12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;} 第三种 : 通过Model12345678@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;} 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 乱码问题测试步骤： 我们可以在首页编写一个提交的表单 1234&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 后台编写对应的处理类 12345678@Controllerpublic class Encoding { @RequestMapping(&quot;/e/t&quot;) public String test(Model model,String name){ model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 }} 输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ： 设置编码！ 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 自定义过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/** * 解决get和post请求 全部乱码的过滤器 */public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { }}//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(&quot;get&quot;)) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; }} 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 整合SSM框架的练习参考SpringMVC07、整合SSM P.S. 安装Tomcat参考Tomcat 的安装与环境配置教程（超详细） Json什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123{&quot;name&quot;: &quot;QinJiang&quot;}{&quot;age&quot;: &quot;3&quot;}{&quot;sex&quot;: &quot;男&quot;} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的var json = '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 12345678910111213package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private String name; private int age; private String sex;} 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 123456789101112131415@Controllerpublic class UserController { @RequestMapping(&quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 123456789101112131415@RestControllerpublic class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} 启动tomcat测试，结果都正常输出！ RestController示例测试集合输出增加一个新的方法 123456789101112131415161718@RequestMapping(&quot;/json2&quot;)public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;} 运行结果 : 十分完美，没有任何问题！ 输出时间对象增加一个新的方法 123456789@RequestMapping(&quot;/json3&quot;)public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;} 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 12345678910111213@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;} 运行结果 : 成功的输出了时间！ 抽取为工具类如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 12345678910111213141516171819202122232425package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils { public static String getJson(Object object) { return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; }} 我们使用工具类，代码就更加简洁了！ 123456@RequestMapping(&quot;/json5&quot;)public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json;} FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： 【JSONObject 代表 json 对象 】 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 【JSONArray 代表 json 对象数组】 内部是有List接口中的方法来完成操作的。 【JSON 代表 JSONObject和JSONArray的转化】 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 12345678910111213141516171819202122232425262728293031323334package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); }} 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 拦截器概述SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器想要自定义拦截器，必须实现 HandlerInterceptor 接口。 新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器 12345678910111213141516171819202122package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(&quot;------------处理前------------&quot;); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(&quot;------------处理后------------&quot;); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(&quot;------------清理------------&quot;); }} 在springmvc的配置文件中配置拦截器 1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 1234567891011121314package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//测试拦截器的控制器@Controllerpublic class InterceptorController { @RequestMapping(&quot;/interceptor&quot;) @ResponseBody public String testFunction() { System.out.println(&quot;控制器中的方法执行了&quot;); return &quot;hello&quot;; }} 前端 index.jsp 1&lt;a href=&quot;${pageContext.request.contextPath}/interceptor&quot;&gt;拦截器测试&lt;/a&gt; 启动tomcat 测试一下！ 应用&amp;示例：验证用户是否登录 (认证用户)","link":"/2023/09/21/SpringMVC%E7%AC%94%E8%AE%B0/"},{"title":"Spring笔记","text":"Spring概述简介 Spring是一个开源免费的框架 , 容器 . Spring是一个轻量级的框架 , 非侵入式的 . 控制反转 IoC , 面向切面 Aop 对事物的支持 , 对框架的支持 一句话概括：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 组成Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . Spring4.x 版本： Spring5.x 版本： Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 其他所有的功能基本都需要依赖于该模块。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。 Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 IOC 控制反转简介控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。Spring中的IoC是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 为什么叫控制反转？ 控制：指的是对象创建（实例化、管理）的权力 反转：控制权交给外部环境（Spring 框架、IoC 容器） 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。 Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。 Bean的作用域在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所 采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Singleton当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; Prototype当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt; 或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 通过XML文件配置Bean无参构造 编写一个Hello实体类 123456789101112public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&quot;Hello,&quot;+ name ); }} 编写我们的spring文件 , 这里我们命名为beans.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 我们可以去进行测试了 . 12345678@Testpublic void test(){ //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show();} 有参构造 UserT . java 123456789101112public class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&quot;name=&quot;+ name ); }} beans.xml 有三种方式编写 1234567891011121314&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第三种根据参数类型设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt; 测试 123456@Testpublic void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserT user = (UserT) context.getBean(&quot;userT&quot;); user.show();} 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ set注入1. 常量注入123&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 2. bean注入1234567&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt; 注意点：这里的值是一个引用，ref 3. 数组注入1234567891011&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4. List注入1234567&lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 5. Map注入123456&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 6. set注入1234567&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 7. Null注入1&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt; 8. Properties注入1234567&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; Bean的自动装配简介 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 在xml中显式配置手动配置xml新建两个实体类，Cat Dog 都有一个叫的方法 12345678910public class Cat { public void shout() { System.out.println(&quot;miao~&quot;); }}public class Dog { public void shout() { System.out.println(&quot;wang~&quot;); }} 新建一个用户类 User 12345public class User { private Cat cat; private Dog dog; private String str;} 编写Spring配置文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.getCat().shout(); user.getDog().shout(); }} Autowire自动装配1. byName由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。采用自动装配将避免这些错误，并且使配置简单化。 修改bean配置，增加一个属性 autowire=”byName”，其余不变，则仍可以成功运行。 123&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 当一个bean节点带有 autowire byName的属性时： 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 2. byType使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常NoUniqueBeanDefinitionException。 修改bean配置，改为 autowire=”byType”，则仍可以成功运行。 再注册一个cat的bean对象，则会出现报错NoUniqueBeanDefinitionException. 123456&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 注解自动装配jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作： 利用注解的方式注入属性。 在spring配置文件中引入context文件头 123xmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 开启属性注解支持！ 1&lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 示例程序：将User类中的set方法去掉，使用@Autowired注解。 12345678910111213141516public class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; }} 配置文件： 1234&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配。 @Qualifier不能单独使用。 配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 没有加Qualifier测试，直接报错。在属性上添加Qualifier注解。 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User { //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String str;} beans.xml： 1234&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 实体类上只保留注解。 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 先进行byName查找，失败；再进行byType查找，成功。 @Autowired与@Resource异同 @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用。 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 使用注解开发准备工作 在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 注解实现Bean 配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt; 在指定包下编写类，增加注解 12345@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User { public String name = &quot;秦疆&quot;;} 测试 1234567@Testpublic void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) applicationContext.getBean(&quot;user&quot;); System.out.println(user.name);} 属性注入使用注解注入属性。 可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User { @Value(&quot;秦疆&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt; public String name;} 如果提供了set方法，在set方法上添加@value(“值”); 12345678@Component(&quot;user&quot;)public class User { public String name; @Value(&quot;秦疆&quot;) public void setName(String name) { this.name = name; }} 衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 作用域@scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User { @Value(&quot;秦疆&quot;) public String name;} XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 示例程序：编写一个实体类，Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog { public String name = &quot;dog&quot;;} 新建一个config配置包，编写一个MyConfig配置类 1234567@Configuration //代表这是一个配置类public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog dog(){ return new Dog(); }} 测试，成功输出结果！ 1234567@Testpublic void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;); System.out.println(dog.name);} 导入其他的配置类 我们再编写一个配置类！ 123@Configuration //代表这是一个配置类public class MyConfig2 {} 在之前的配置类中我们来选择导入这个配置类 12345678@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig { @Bean public Dog dog(){ return new Dog(); }} 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ AOP底层机制AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 示例程序Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent { public void rent();} Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(&quot;房屋出租&quot;); }} Proxy . java 即代理角色 12345678910111213141516171819202122//代理角色：中介public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(&quot;带房客看房&quot;); } //收中介费 public void fare(){ System.out.println(&quot;收中介费&quot;); }} Client . java 即客户 1234567891011//客户类，一般客户都会去找代理！public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); }} 分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的优缺点优点： 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! AOP中最核心的思想：在不改变原来的代码的情况下，实现了对原有功能的增强 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理——JDK动态代理 基于类的动态代理—cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy。 【InvocationHandler：调用处理程序】 12345Object invoke(Object proxy, 方法 method, Object[] args)；//参数 //proxy - 调用该方法的代理实例 //method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 //args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 12345//生成代理类public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this);} 示例程序抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent { public void rent();} Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(&quot;房屋出租&quot;); }} ProxyInvocationHandler. java 即代理角色 1234567891011121314151617181920212223242526272829public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(&quot;带房客看房&quot;); } //收中介费 public void fare(){ System.out.println(&quot;收中介费&quot;); }} Client . java 123456789101112//租客public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); }} 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口 动态代理的好处静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ AOPAOP简介AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 1. 通过 Spring API 实现首先编写我们的业务接口和实现类 123456public interface UserService { public void add(); public void delete(); public void update(); public void search();} 123456789101112131415161718public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(&quot;增加用户&quot;); } @Override public void delete() { System.out.println(&quot;删除用户&quot;); } @Override public void update() { System.out.println(&quot;更新用户&quot;); } @Override public void search() { System.out.println(&quot;查询用户&quot;); }} 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 123456789public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); }} 123456789101112public class AfterLog implements AfterReturningAdvice { //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); }} 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 12345678public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.search(); }} Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 2. 自定义类来实现Aop目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 12345678public class DiyPointcut { public void before(){ System.out.println(&quot;---------方法执行前---------&quot;); } public void after(){ System.out.println(&quot;---------方法执行后---------&quot;); }} 去spring中配置 123456789101112&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试： 12345678public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.add(); }} 3. 使用注解实现第一步：编写一个注解实现的增强类 1234567891011121314151617181920212223242526package com.kuang.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut { @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;---------方法执行前---------&quot;); } @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void after(){ System.out.println(&quot;---------方法执行后---------&quot;); } @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); }} 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=”true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 MyBatis-Spring引入Spring之前需要了解mybatis-spring包中的一些重要类； 什么是 MyBatis-Spring？MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 在 MyBatis-Spring 中，可使用 SqlSessionFactoryBean来创建 SqlSessionFactory。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 注意：SqlSessionFactory 需要一个 DataSource（数据源）。 这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。 而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt;settings&gt; 或 &lt;typeAliases&gt; 元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;environments&gt;），数据源（&lt;DataSource&gt;）和 MyBatis 的事务管理器（&lt;transactionManager&gt;）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 123&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： 123456789public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper...; }} 按下面这样，注入 SqlSessionTemplate： 123&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt; 示例程序引入Spring配置文件beans.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 配置数据源替换mybaits的数据源 1234567&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 配置SqlSessionFactory，关联MyBatis 1234567&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;&lt;/bean&gt; 注册sqlSessionTemplate，关联sqlSessionFactory； 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 增加Dao接口的实现类；私有化sqlSessionTemplate 1234567891011public class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); }} 注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 示例程序2mybatis-spring1.2.3版以上的才有这个 . 官方文档截图 : dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 将我们上面写的UserDaoImpl修改一下 123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { public List&lt;User&gt; selectUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); }} 修改bean的配置 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 总结 : 整合到spring中以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ Spring事务事务事务简介 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务的属性 原子性（atomicity）：事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency）：一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation）：可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability）：事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 Spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx 123xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 示例程序 配置AOP，导入aop的头文件！ 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 进行测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 参考文章Spring常见面试题总结 狂神SSM教程-Spring","link":"/2023/09/12/Spring%E7%AC%94%E8%AE%B0/"},{"title":"《求合体》小游戏项目报告","text":"项目链接https://github.com/0Heeee/Join_game 开发背景《求合体》以合体为主题的全新游戏,每一株草丛、每一幢房屋、每一只猫咪都时时刻刻哭喊着求合体，一切都取决于玩家的旨意,一切都决定于玩家的安排。玩家的每一位子民,都在等待英明的合体决定。 在本次的课程设计中，依照该背景对游戏进行了一定的改编。支持鼠标操作，并且包含“彩虹”、“炸弹”、“猫”等多样玩法。界面上有显示下一个可放置物品的提示以及玩家当前的分数、剩余步数、获得金币。根据玩家不同的物品类型以及玩家所点击的不同位置，将作出不同的回应。 系统功能设计系统功能模块图 系统业务流程图 项目创建系统开发环境要求本项目的开发及运行环境要求： 操作系统： Windows 开发工具：dev c++和vc++ 开发语言：c 语言 项目创建过程 寻找合适的项目主题，确定项目为游戏项目《求合体》。 找到构建项目的方法，确定使用easyx库，学习该库的使用。 考虑项目的各个模块，并完成系统功能模块图。 确认游戏的业务流程，并完成系统业务流程图。 思考并编写各个模块的具体实现。 修改bug，完善游戏页面与逻辑。 完成设计报告。 项目模块设计游戏欢迎界面概述：首先使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。 游戏规则界面概述：使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。 游戏界面概述：首先使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。并且每次点击时判断游戏是否结束，结束则返回游戏欢迎界面。 生成随机地图模块概述：首先将地图所有位置初始化为空地，将盘子信息初始化为空，再随机放置石头，随机放置猫，随机放置物品，最后初始化玩家信息。 游戏操作模块概述：首先判断下一物品类型，再判断放置位置的信息，根据两者进行下一步操作。 放置物品模块概述：根据要放置的位置以及要放置的物品类型，调用putimage（）函数。 合并同类型物品模块概述：判断放下物品的四周是否有与刚放置物品同类型的物品，若有则合并升级，没有则放置。若放下物品为彩虹则可与任何物品进行合并，若其周围无满足条件物品，则彩虹变为随机物品放置。 猫咪移动模块概述：每放下一个物品时，所有可移动猫咪移动一格。若猫咪四周均有障碍物，则猫咪无路可走，变为墓。 生成随机物品模块概述：每放下一个物品后，生成新的随机物品并显示在屏幕上方正中央。 放置物品到盘子模块概述：当盘子为空时，可将物品暂时放入盘子。也可以随时取回盘子中的物品。 玩家信息变更模块概述：每放下一个物品后，玩家步数减1。合并物品后，根据所放置的物品等级进行加分。根据用户的分数可以获得相应的金币。 游戏结束模块概述：若地图中没有空地，则游戏结束，统计玩家分数。 项目创新点该项目只是根据本人玩游戏所大致了解的背景进行一定程度的改编，所有功能的实现与完善均为自己所想。 猫的移动算法在判断猫的移动时，同时要考虑到猫碰到全包围时会变成墓。然而，猫咪移动的同时，有可能会阻碍其他猫咪的移动，致使其他猫咪遇到全包围的情况，但这种情况不是玩家所致，不应该变成墓。并且，在所有猫咪移动时，原本被猫咪阻挡了所有移动方向的猫咪在该阻挡猫咪移开后，也理应可以移动。 再有，刚被玩家放置的猫不能马上移走。考虑到这几种复杂情况，我设计算法如下： （1）遍历地图，找到全部的猫，将被猫全包围且四周没有猫的猫变成墓，将被全包围且四周有猫的猫放入暂存栈。 （2）随机移动可以自由移动的猫（不包括刚放下的猫），并记录移动前的位置，加入猫栈。将移动的猫类型type变为newCAT，加入新猫栈。 （3）检测可移动的猫移动前的位置四周是否有猫，若有猫（类型type为CAT且不为刚放下的猫），则将其移动至该可移动的猫移动前的位置（现在为空地），并从暂存栈中删除该猫，将其移动前的位置加入猫栈。将刚移动的猫类型type变为newCAT，加入新猫栈。若猫栈不空，则循环该步。 （4）检查剩余的暂存猫，若周围有新猫（类型type为newCAT），则不变墓，否则变墓。 （5）将类型type为newCAT的猫类型type改回CAT。 合并同类物品算法因三个物品便可以合并，故要判断是否需要合并最多只需两次四周判断即可。设计算法（不完全按照程序执行顺序）如下： （1）判断放下物品的四周是否有与刚放置物品同类型的物品。 （2）若有同类型物品，则统计数量加一，将其放入暂存栈。判断该同类型物品的四周（不包括刚放置物品的位置）是否还有与刚放置物品同类型的物品。 （3）若两次判断均有相同类型物品，则说明相同物品数一定大于等于2，则可运用栈，将除刚放置位置外其他所有经过判断的相同类型物品清除，并记录为可升级（upFlag = 1）。 （4）若判断为可升级，则将刚放置位置的类型升级。 （5）再次调用函数，看是否可连续升级。 彩虹合并同类物品算法彩虹可以和任意物品合并，因此，为找到其应变为的类型，先统计周围物品的类型及该类型对应物品的数量，在大于等于2的类型中选取等级最低的物品，将彩虹等效为该物品。此外，其判断的大致思路与合并同类物品算法类似，故与之合并。修改合并同类物品算法如下： （1）在判断周围是否有与刚放置物品同类型的物品时，若放置物品为彩虹，则也算是。除空地、猫、墓、石头类型外，统计剩余类型的数量。 （2）第二次四周判断同第一次。除空地、猫、墓、石头类型外，统计剩余类型的数量。 （3）统计周围相同物品，若所有可用类型数量均小于2，则不能合并。将彩虹变为随机类型（不包括彩虹、猫、石头）放置。 若有某类型数量大于等于2，则在所有可合并类型中进行判断，选出等级最低的物品，并将其类型type赋给彩虹所在位置。再次调用函数进行合并操作。 总结与收获我这次所做的项目是《求合体》，灵感来源于同名app。因为之前有玩过这款小游戏，觉得比较有意思，因此想到做这个项目。 在制作项目时，遇到了挺多问题。因为这游戏知名度比较低，在设计以前我也没有找到官方的游戏规则，因此游戏的基本逻辑主要是在玩游戏的体验中总结出来的，并且加入了我个人的想法。 在游戏算法的设计上，我修改了许多次。这让我懂得了在设计的时候要反复思考，许多的问题都是事先没有考虑完全导致的。因此要考虑好可能出现的各种情况。 除了基本的游戏算法外，我还对easyx这个库有了一定的了解。用于实现c语言编写的小游戏确实比较简单，交互界面也相对于控制台游戏更加友好。 因为之前有过团队协作完成项目的经历，再加上这次对项目有了一定的想法，因此尝试了一个人完成项目。相对于团队合作，一个人完成任务的负担会重很多，但也减少了相互磨合讨论的时间。总的来说，单独完成项目使得我对整体项目的把控更为清晰。 另外，这次完成项目使用了git进行项目管理。之前有学习和使用过几次，但却是第一次使用其辅助完成项目。使用后发现，git在管理方面非常方便，也有助于看到一次次的修改成果，对项目的整体走向更好地掌控。 总体而言，经过这次项目我收获了许多，也发现了自己的不足。在以后的项目中，也会不断吸取经验教训，争取完成地更好。","link":"/2019/12/10/%E3%80%8A%E6%B1%82%E5%90%88%E4%BD%93%E3%80%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/"},{"title":"python笔记","text":"基础 采用缩进（不用“；”隔开） 空值：None 注释# print absolute value of an integer: Python的整数没有大小限制，浮点数也没有，但超出一定范围就直接表示为inf（无限大） 动态语言：同一个变量可以反复赋值，而且可以是不同类型的变量 1234a = 123 # a是整数print(a)a = 'ABC' # a变为字符串print(a) bytes类型和str类型转化 1234567891011&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文'#如果只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中' 布尔值1234&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse 与、或、非123456&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse 除法 无论整数、浮点数，/除法计算结果是浮点数 12&gt;&gt;&gt; 9 / 33.0 整数，//地板除计算结果是整数（只取结果的整数部分）浮点数，//地板除计算结果是浮点数（只取结果的整数部分） 1234&gt;&gt;&gt; 10 // 33&gt;&gt;&gt; 20.8 // 210.0 条件判断和循环 if语句12345678910age = 3if age &gt;= 18: print('your age is', age) print('adult')elif age &gt;= 6: print('your age is', age) print('teenager')else: print('your age is', age) print('kid') tuple 一种有序列表：元组 tuple的每个元素，指向永远不变，但指向的list本身可变 创建list123&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')&gt;&gt;&gt; classmates('Michael', 'Bob', 'Tracy') 获取元素的方法和list一样 没有改变元素方法 list 是内置的一种数据类型:列表 list里面的元素的数据类型可以不同 &gt;&gt;&gt; L = ['Apple', 123, True, ['asp', 'php']] 创建list123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 获得list元素的个数12&gt;&gt;&gt; len(classmates)3 用索引来访问list中元素1234&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[-1]'Tracy' 添加、删除、替换元素12345678910111213141516171819202122#追加元素到末尾&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam']#把元素插入到指定的位置&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']#删除list末尾的元素&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']#删除指定位置的元素&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']#把某个元素替换成别的元素&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] 字符串 字符串的输出 依次打印每个字符串，遇到逗号“,”会输出一个空格 12&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')The quick brown fox jumps over the lazy dog 输出格式化字符串:%方法 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' format（）方法 12&gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 多行字符串 交互式命令行： 123&gt;&gt;&gt; print('''line1... line2... line3''') .py文件： 123print('''line1line2line3''') 字符串不转义用r’’表示’’内部的字符串默认不转义1234&gt;&gt;&gt; print('\\\\\\t\\\\')\\ \\&gt;&gt;&gt; print(r'\\\\\\t\\\\')\\\\\\t\\\\ 字符编码转换123456&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; chr(25991)'文'&gt;&gt;&gt; '\\u4e2d\\u6587''中文' 字符串的长度 len计算str类型字符数 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2 len也可计算bytes类型字节数 123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6 输入输出 输出 1&gt;&gt;&gt; print('hello, world') 输入 1234&gt;&gt;&gt; name = input()Michael&gt;&gt;&gt; name'Michael' 文件示例 12name = input('please enter your name: ')print('hello,', name) 123C:\\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael 文件运行 命令行模式和交互模式 命令行模式： 1C:\\&gt; 交互模式：命令行模式下输入python，进入交互模式输入exit（），退出交互模式 123456C:\\Users\\cjq2061&gt;pythonPython 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; exit()C:\\&gt; 运行.py文件 1C:\\work&gt;python xxx.py","link":"/2019/04/20/python%E7%AC%94%E8%AE%B0/"},{"title":"基数排序问题与解决","text":"问题描述因为引理中提到， 对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，则Radix sort需要Θ(d(k+n))时间。 因此一开始想用Counting sort来进行一位的排序。代码如下： 1234567891011121314151617181920Array stableSort(Array A, int n, int d){ int k = 10;//因为排序的是位，最大值直接定为9 Array B = (ElemType*)malloc(k * sizeof(ElemType)); Array C = (ElemType*)malloc(n * sizeof(ElemType)); Array D = getSubArray(A, n, d); //第d位的数 for(int i = 0; i &lt; k; i++){ B[i] = 0; } for(i = 0; i &lt; n; i++){ B[D[i]]++; } for(i = 1; i &lt; k; i++){ B[i] += B[i - 1]; } for(i = 0; i &lt; n; i++){ B[D[i]]--; C[B[D[i]]] = A[i]; } return A;} 123456Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ A = stableSort(A, n, i); } return A;} 测试数据始终不对。后来意识到Counting sort中相同取值的数的输出顺序与输入顺序无关，因此不适用于Radix sort。第二次还是没想放弃效率较高的算法，采用了Quicksort。代码如下： 12345678910111213int PARTITION(Array &amp;A, Array &amp;D, int p, int r){ int j = p; for(int i = p; i &lt; r; i++){ if(D[i] &lt; D[r]){ exchange(A, i, j); exchange(D, i, j); j++; } } exchange(A, j, r); exchange(D, j, r); return j;} 123456void QUICKSORT(Array &amp;A, Array &amp;D, int p, int r){ if(p &gt;= r) return; int q = PARTITION(A, D, p, r); QUICKSORT(A, D, p, q - 1); QUICKSORT(A, D, q + 1, r);} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 QUICKSORT(A, D, 0, n - 1); } return A;} 发现测试数据仍不对。又意识到Quicksort其实也没有让相同取值的数的输出顺序与输入顺序相同。为了尽快完成任务，最后采用了效率低但是输出正确的冒泡排序。 12345678910void stableSort(Array &amp;A, Array D, int n){ for(int i = 0; i &lt; n - 1; i++){ for(int j = i; j &lt; n - 1; j++){ if(D[j] &gt; D[j + 1]){ exchange(A, j, j + 1); exchange(D, j, j + 1); } } }} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 stableSort(A, D, n); } return A;} 分析 对各个排序算法的适用性不太熟悉。 对各个算法的书写也没完全掌握，在写不同算法时，仍会有很多小bug。 总结因为对算法的不熟悉，导致耗费了大量时间在这一个简单的算法上。但从另一个角度说，也算是加深了对算法的理解，并且对vc++的调试更熟悉了。","link":"/2020/09/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"},{"title":"桶排序问题","text":"问题描述在用Bucket sort的时候，试了一下用链表数组的结构。编译通过了，但是不知道为什么next指针用不了。 代码12345678typedef double ElemType;typedef ElemType* Array;typedef struct CTNode{ ElemType data; struct CTNode *next;}*ChildPtr;typedef ChildPtr CTBox;typedef CTBox* CTree; 12345678910//得到最后一个元素 ChildPtr getRear(CTBox B){ ChildPtr p = B; if(B){ //while(p-&gt;next){ // p = p-&gt;next; //} } return p;} 1234567891011121314151617//链表中元素的排序void SortCTNode(CTBox &amp;Box){ ChildPtr p, q, head; head = p = Box; while(head){ head = head-&gt;next; q = Box; while(p-&gt;data &gt; q-&gt;next-&gt;data &amp;&amp; q-&gt;next){ q = q-&gt;next; } if(p != q){ p-&gt;next = q-&gt;next; q-&gt;next = p; } p = head; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344void BUCKET_SORT(Array &amp;A, int n){ CTree B = (CTBox*)malloc(n * sizeof(CTBox)); CTBox newBox; ChildPtr newChild, p; for(int i = 0; i &lt; n; i++){ B[i] = NULL; } for(i = 0; i &lt; n; i++){ if(!B[(int)ceil(n * A[i])]){ newBox = (CTNode*)malloc(sizeof(CTNode)); newBox-&gt;data = A[i]; newBox-&gt;next = NULL; B[(int)ceil(n * A[i])] = newBox; } else{ newChild = (CTNode*)malloc(sizeof(CTNode)); newChild-&gt;data = A[i]; newChild-&gt;next = NULL; p = getRear(B[(int)ceil(n * A[i])]); p-&gt;next = newChild; } } //依次给链表排序 for(i = 0; i &lt; n; i++){ if(B[i]){ SortCTNode(B[i]); } } //将链表连接起来 CTBox Final = (CTNode*)malloc(sizeof(CTNode)); p = Final; for(i = 0; i &lt; n; i++){ if(B[i]){ p-&gt;next = B[i]; p = getRear(B[i]); } } //依次赋值给Array p = Final-&gt;next; for(i = 0; i &lt; n; i++){ A[i] = p-&gt;data; p = p-&gt;next; }}","link":"/2020/09/25/%E6%A1%B6%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"title":"桶排序问题与解决","text":"问题描述看到书上的案例图，觉得是用链表+数组实现，于是一开始参考数据结构老师ppt。但发现实现不了（详见桶排序问题）。后来想结构直接用二维数组算了。本来对B[i]数据排序，想用QuickSort，但发现如果是数组B[i][1]至B[i][k]排序，原算法改动较大，遂作罢。 最终代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void BUCKET_SORT(Array &amp;A, int n){ bArray B = (Array*)malloc(n * sizeof(Array)); for(int i = 0; i &lt; n; i++){ B[i] = (ElemType*)malloc((n + 1) * sizeof(ElemType)); B[i][0] = 0;//开头存放大小 for(int j = 1; j &lt; n + 1; j++){ B[i][j] = -1; } } //将A分配到B中 for(i = 0; i &lt; n; i++){ int pos = (int)ceil(n * A[i]) - 1; int j = 1; while(B[pos][j] != -1 &amp;&amp; j &lt; n){ j++; } B[pos][j] = A[i]; B[pos][0]++; } //对B[i]数据排序 for(i = 0; i &lt; n; i++){ if(B[i][0] != 0 &amp;&amp; B[i][0] != 1){ for(int j = 1; j &lt; B[i][0] + 1; j++){ for(int k = j; k &lt; B[i][0]; k++){ if(B[i][k] &gt; B[i][k + 1]){ double tmp = B[i][k]; B[i][k] = B[i][k + 1]; B[i][k + 1] = tmp; } } } } } //将B中数据重新给A i = 0; int j = 0; int k = 1; while(i &lt; n &amp;&amp; j &lt; n){ if(B[j][0] != 0){ if(B[j][k] != -1 &amp;&amp; k &lt; n + 1){ A[i] = B[j][k]; B[j][k] = -1; B[j][0]--; k++; i++; } else{ j++; } } else{ j++; k = 1; } }} 总结自己从头写不仅非常耗费时间精力，而且算法效率也不高，体现不出原算法的精妙。或许以后应该直接参考别人的写法？这种完全靠自己实现算法的做法除了让我对调试越来越熟悉以外，其他好像也没什么帮助了吧。（也许还会让自己更有自知之明一些…）","link":"/2020/09/30/%E6%A1%B6%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"},{"title":"算法导论笔记","text":"第1章算法介绍 第2章 用扑克牌举例，介绍了一种插入排序123456789101112void InsertSort(ElemType *A){ printf(&quot;length:%d\\n&quot;, length); for(int j = 1; j &lt; MAXSIZE; j++){ int i = j - 1; int tmp = A[j]; while(tmp &lt; A[i] &amp;&amp; i &gt;= 0){ A[i + 1] = A[i]; i--; } A[i + 1] = tmp; }} 简单介绍了时间复杂度的计算 简单介绍了分治法，并举例 123456789101112131415161718192021222324void Merge(ElemType *A, int start1, int end1, int start2, int end2){ int length1 = end1 - start1; int length2 = end2 - start2; ElemType L[MAXSIZE], R[MAXSIZE]; int i, j, p1, p2; for(j = start1, i = 0; j &lt;= end1; j++, i++){ L[i] = A[j]; } L[i] = INT_MAX;//--注意跳出循环后i的值 for(j = start2, i = 0; j &lt;= end2; j++, i++){ R[i] = A[j]; } R[i] = INT_MAX; for(i = start1, p1 = 0, p2 = 0; i &lt;= end2; i++){ if(L[p1] &lt;= R[p2]){ A[i] = L[p1]; p1++; } else{ A[i] = R[p2]; p2++; } }} 123456789void MergeSort(ElemType *A, int start, int end){ if(end - start == 0) return;//--注意长度为1数组的表达 else{ int mid = (start + end) / 2; MergeSort(A, start, mid); MergeSort(A, mid + 1, end); Merge(A, start, mid, mid + 1, end); }} 分析算法T(n) = aT(n/b) + D(n) + C(n)分离的子问题T(n/b)，子问题之和aT(n/b) 第3章 时间复杂度记号Θ()：包括上下界O()：上界，常使用，最坏情况Ω()：下界o()：强上界，高阶无穷小w()：强下界，低阶无穷小 floors and ceilings⌈⌉：向上取整⌊⌋：向下取整 指数对数及其他数学表达式除对数lgn = log2n外，其余与数学相同。 第4章 最大的子数列问题 1234567891011121314151617181920212223242526int* FindMaxCrossing(ElemType *A, int start, int mid, int end){ int left_sum = -INT_MAX; int right_sum = -INT_MAX; int sum = 0; int fstart, fend; int result[3]; for(int i = mid; i &gt;= start; i--){ sum += A[i]; if(left_sum &lt; sum){ left_sum = sum; fstart = i; } } sum = 0; for(int i = mid + 1; i &lt;= end; i++){ sum += A[i]; if(right_sum &lt; sum){ right_sum = sum; fend = i; } } result[0] = left_sum + right_sum; result[1] = fstart; result[2] = fend; return result;} 12345678910111213141516171819202122int* FindMax(ElemType *A, int start, int end) { int result[3], LResult[3], RResult[3], CResult[3]; if(start == end){ result[0] = A[start];//result[0] : maxMoney result[1] = start;//result[1] : startPos result[2] = end;//result[2] : endPos return result; } else{ int mid = (start + end) / 2; ArrayTo(LResult, FindMax(A, start, mid), 3); ArrayTo(RResult, FindMax(A, mid + 1, end), 3); ArrayTo(CResult, FindMaxCrossing(A, start, mid, end), 3); if(LResult[0] &gt; RResult[0]) ArrayTo(result, LResult, 3); else ArrayTo(result, RResult, 3); if(CResult[0] &gt; result[0]) ArrayTo(result, CResult, 3); return result; }} 矩阵乘法简化算法 用代入法和递归树求时间复杂度（中文翻译为递归式） 主方法求时间复杂度T(n) = aT(n/b) + f(n)主定理： 第5章概率分析和随机算法 第6章堆 数组堆的两个属性：length（数组长）、heap-size（实际存放数据长度，堆顶）。 放在数组中储存，可根据下标判断左/右孩子（2i为左，2i+1为右）。 分为max-heap(最大堆)和min-heap(最小堆)，最大堆的每个父母结点的值都大于孩子结点。 基本算法 MAX-HEAPIFY比较父母结点与孩子结点的大小，并将最大值放在父母结点位置时间复杂度O(lgn) 123456789101112Status MAX_HEAPIFY(Heap &amp;A, int i){ if(i &gt;= A.heap_size || i &lt; 0) return ERROR; int left, right, max; left = A.node[i].lchild; right = A.node[i].rchild; max = A.node[left].data &gt; A.node[right].data ? left : right; if(A.node[max].data &gt; A.node[i].data){ Exchange(A, max, i); MAX_HEAPIFY(A, max); } return OK;} BUILD-MAX-HEAP利用前一算法构造max-heap(最大堆)时间复杂度O(n)1234567Status BUILD_MAX_HEAP(Heap &amp;A){ //A.heap_size = A.length; for(int i = A.length / 2 - 1; i &gt;= 0; i--){ MAX_HEAPIFY(A, i); } return OK;} HEAPSORT可能是利用堆排序，排完后解散堆123456789Status HEAP_SORT(Heap &amp;A){ BUILD_MAX_HEAP(A); for(int i = A.heap_size - 1; i &gt; 0; i--){ Exchange(A, 0, i); A.heap_size--; MAX_HEAPIFY(A, 0); } return OK;} HEAP-MAXIUM返回堆的最大值123ElemType HEAP_MAXIUM(Heap A){ return A.node[0].data;} HEAP-EXTRACT-MAX取出堆的最大值1234567ElemType HEAP_EXTRACT_MAX(Heap &amp;A){ ElemType dataMax = HEAP_MAXIUM(A); Exchange(A, 0, A.heap_size - 1); A.heap_size--; MAX_HEAPIFY(A, 0); return dataMax;} MAX-HEAP-INSERT增加堆中某位置的值123456789Status MAX_HEAP_INSERT(Heap &amp;A, int pos, ElemType key){ if(key &lt; A.node[pos].data) return ERROR; A.node[pos].data = key; while(pos != 0 &amp;&amp; A.node[A.node[pos].parent].data &lt; A.node[pos].data){ Exchange(A, A.node[pos].parent , pos); pos = A.node[pos].parent; } return OK;} HEAP-INCREMENT-KEY堆末尾插入新元素 123456Status HEAP_INCREMENT_KEY(Heap &amp;A, ElemType key){ if(++A.heap_size &gt; A.length) return ERROR; A.node[A.heap_size - 1].data = -INT_MAX; MAX_HEAP_INSERT(A, A.heap_size - 1, key); return OK;} 第7章概述将要排序的数分割为比A[q]大和比A[q]小的，再分别对A[p,q-1],A[q+1,r]进行分割，直到完成。 特点期望的时间复杂度为O(nlgn)，最坏情况为O(n)。通常为O(nlgn)。方法为分治法。 算法 QUICKSORT(A, p, r)1234567Status QUICKSORT(Array &amp;A, int p, int r){ if(p &gt;= r) return OK; int q = PARTITION(A, p, r); QUICKSORT(A, p, q - 1); QUICKSORT(A, q + 1, r); return OK;} PARTITION(A, p, r)1234567891011int PARTITION(Array &amp;A, int p, int r){ int j = p; for(int i = p; i &lt; r; i++){ if(A[i] &lt; A[r]){ Exchange(A, i, j); j++; } } Exchange(A, j, r); return j;} RANDOMIZED_QUICKSORT相当于输入足够大的数组？1234567Status RANDOMIZED_QUICKSORT(Array &amp;A, int p, int r){ if(p &gt;= r) return OK; int q = RANDOMIZED_PARTITION(A, p, r); RANDOMIZED_QUICKSORT(A, p, q - 1); RANDOMIZED_QUICKSORT(A, q + 1, r); return OK;} 第8章比较排序的最短时间: 通过决策树的深度，可以体现算法的时间复杂度的下界。 定理：任何排序算法的最坏情况都需要Ω(nlgn)的时间复杂度。 结论：Heapsort和Mergesort都是渐进最优排序算法。 线性时间算法 Counting sort概述：A中，有n个比x小的数，则将x放置在第n+1个位置。特点：适用于比较非负整数且数值较小的数。k为须比较的数的最大值，则时间复杂度为Θ(k+n)。使用该算法时，通常k=O(n)，则时间复杂度为Θ(n)。相同取值的数的输出顺序与输入顺序无关。代码： 12345678910111213141516171819Array COUNTING_SORT(Array A, int n){ int k = getMax(A, n); Array B = (ElemType*)malloc(k * sizeof(ElemType)); Array C = (ElemType*)malloc(n * sizeof(ElemType)); for(int i = 0; i &lt; k; i++){ B[i] = 0; } for(i = 0; i &lt; n; i++){ B[A[i] - 1]++; } for(i = 1; i &lt; k; i++){ B[i] += B[i - 1]; } for(i = 0; i &lt; n; i++){ B[A[i] - 1]--; C[B[A[i] - 1]] = A[i]; } return C;} Radix sort概述：根据位数d的重要性，从最不重要的一位开始排序，共排序d次。特点：引理：对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，则Radix sort需要Θ(d(k+n))时间。引理：对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，对于任意正数r≤b，Radix sort需要Θ((b/r)(n+2^r))时间。代码：12345678910void stableSort(Array &amp;A, Array D, int n){ for(int i = 0; i &lt; n - 1; i++){ for(int j = i; j &lt; n - 1; j++){ if(D[j] &gt; D[j + 1]){ exchange(A, j, j + 1); exchange(D, j, j + 1); } } }} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 stableSort(A, D, n); } return A;} Bucket sort概述：有n个[0,1)之间的数，根据⌊nA[i]⌋将A中各数分配到B中，再对B[i]中各数进行排序。特点：要排序的各数均在[0,1)之间。B可运用链表。时间复杂度为Θ(n)。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void BUCKET_SORT(Array &amp;A, int n){ bArray B = (Array*)malloc(n * sizeof(Array)); for(int i = 0; i &lt; n; i++){ B[i] = (ElemType*)malloc((n + 1) * sizeof(ElemType)); B[i][0] = 0;//开头存放大小 for(int j = 1; j &lt; n + 1; j++){ B[i][j] = -1; } } //将A分配到B中 for(i = 0; i &lt; n; i++){ int pos = (int)ceil(n * A[i]) - 1; int j = 1; while(B[pos][j] != -1 &amp;&amp; j &lt; n){ j++; } B[pos][j] = A[i]; B[pos][0]++; } //对B[i]数据排序 for(i = 0; i &lt; n; i++){ if(B[i][0] != 0 &amp;&amp; B[i][0] != 1){ for(int j = 1; j &lt; B[i][0] + 1; j++){ for(int k = j; k &lt; B[i][0]; k++){ if(B[i][k] &gt; B[i][k + 1]){ double tmp = B[i][k]; B[i][k] = B[i][k + 1]; B[i][k + 1] = tmp; } } } } } //将B中数据重新给A i = 0; int j = 0; int k = 1; while(i &lt; n &amp;&amp; j &lt; n){ if(B[j][0] != 0){ if(B[j][k] != -1 &amp;&amp; k &lt; n + 1){ A[i] = B[j][k]; B[j][k] = -1; B[j][0]--; k++; i++; } else{ j++; } } else{ j++; k = 1; } }} 第9章找到最小值时间复杂度：比较n-1次。方法：常规做法。代码：略。 同时找到最小值和最大值时间复杂度：比较3⌊n/2⌋次。方法：将A分成两两一组，大的跟max比较，小的跟min比较。代码： 12345678void comparing(Array &amp;A, int i, int j){ ElemType tmp; if(A[i] &gt; A[j]){ tmp = A[i]; A[i] = A[j]; A[j] = tmp; }} 1234567891011121314151617181920void getMaxMin(Array A, int n, ElemType &amp;max, ElemType &amp;min){ if(n % 2){ max = min = A[0]; for(int i = 1; i &lt; n - 1; i = i + 2){ comparing(A, i, i + 1); if(A[i] &lt; min) min = A[i]; if(A[i + 1] &gt; max) max = A[i + 1]; } } else{ comparing(A, 0, 1); min = A[0]; max = A[1]; for(int i = 2; i &lt; n - 1; i = i + 2){ comparing(A, i, i + 1); if(A[i] &lt; min) min = A[i]; if(A[i + 1] &gt; max) max = A[i + 1]; } }} 随机挑选出第i个最小的数时间复杂度：Θ(n^2)? O(n)?不通过排序来选择，使算法效率较高。方法：运用随机分割，可得有k-1个数小于A[q]。若k！=i，则递归再次挑选。代码： 12345678ElemType RANDOMIZED_SELECT(Array A, int p, int r, int i){ if(p == r) return A[p]; int q = RANDOMIZED_PARTITION(A, p, r); int k = q - p + 1; if(k == i) return A[q]; else if(i &lt; k) return RANDOMIZED_SELECT(A, p, q - 1, i); else return RANDOMIZED_SELECT(A, q + 1, r, i - k);} 第10章Stacks特征last-in,first-out(LIFO) 先进后出基本操作 STACK-EMPTY PUSH POP Queue特征first-in,first-out(FIFO)先进先出基本操作 STACK-EMPTY ENQUEUE DEQUEUE Linked lists基本操作 LIST-SEARCH LIST-INSERT LIST-DELETE 静态指针和静态链表树第11章特征 search time: Θ(n), in the worst case O(1), in the average 用数组T[n]存储关键词的位置","link":"/2020/09/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"},{"title":"计算机网络知识点整理","text":"网络模型 Q：为什么要有 TCP/IP 网络模型？ A：对于同一台设备上的通信，有很多种方式，比如管道、消息队列、共享内存等；而对于不同设备上的进程间通信，就需要网络通信。为了兼容多种设备，就协商出了一套通用的网络协议。 TCP/IP 网络参考模型共有 4 层，其中需要我们熟练掌握的是应用层、传输层和网络层，至于网络接口层（数据链路层和物理层）我们只需要做简单的了解就可以了。 1. 应用层（Application Layer）应用层不关心数据是如何传输的，而是专注于为用户提供应用功能。常见的协议有HTTP、FTP、Telnet、DNS和SMTP等。应用层工作在操作系统的用户态。 2. 传输层（Transport Layer）传输层有两个传输协议，TCP和UDP。 TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。 UDP（User Datagram Protocol）只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，这需要把 TCP 的特性在应用层上实现。 当传输层的数据大小超过MSS（TCP 最大报文段长度）时，需要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，每个分块称为一个 TCP 段（TCP Segment）。 传输层需要将数据包传给应用，不同的应用通过端口号来进行区分。例如，80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。 3. 网络层（Internet Layer）网络层负责将数据从一个设备传输到另一个设备，一般使用IP地址给设备编号。对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。IP地址通过子网掩码分为两部分，分别是网络号和主机号： 网络号，负责标识该 IP 地址是属于哪个「子网」的； 主机号，负责标识同一「子网」下的不同主机。 网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。 IP协议包括路由能力和寻址能力： 路由：实际场景中，两台设备是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。路由器寻址工作中，就是要找到目标地址的子网，找到后把数据包转发给对应的网络内。 寻址：IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。 4. 网络接口层（Link Layer） Q：什么是以太网呢？ A：电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。 生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。 以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。 MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。 网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。 各层的封装格式网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。","link":"/2024/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"通过C#实现Xml的自动转换","text":"一、目的 通过给定的标准化xml schema文档，将非标准化的xml schema文档进行一定的转换，从而使所有的xml schema文档都遵循同一套格式，方便后续对xml文档的处理。 二、实现过程起初，我们对任务不太明确。不清楚给出的规划化文件和需要进行规范的文件是xml文档还是xml schema文档。因此，在多次讨论无果后，再次咨询了老师。得到确定答案后重新查阅了资料，才开始具体的实现。 前期，我们主要查询的方向为xml文档相似度的判定。了解到xml文档的相似度主要基于名称相似度以及结构相似度。而名称相似度又可以通过比较两个节点名称的编辑距离相似度、语义相似度、上下节点的相关性等得到。结构相似度除了节点的层次外，还包括了节点的数据类型相似度、生成的树的编辑距离、子树出现频率等。例如，《基于路径特征的xml文档结构相似性度量》中提出，可以通过比较节点的最长公共子序列的相似度、节点层次相似度、节点名称出现频率来得到两个xml文档的相似度。在明确任务目的后，我们又对xml的匹配、转换进行了相关查询。再加上自己的思考、不断测试更正，最终实现了所需的功能。 三、实现方法经过暑假的学习，我们已经对运用C#操作xml文档有了初步的认识，因此选择使用C#语言实现。运行环境为Microsoft Visual Studio2019。主要步骤如下： 用DOM将xml schema文件生成可视化模式图，结构为树。其中节点的属性和子节点用不同的符号进行区分。 遍历可视化模式图，计算节点的相似度。节点相似度由几个部分组成： 节点名称的语义相似度。主要通过WordNet得出。若WordNet不可直接解析，则将名称进行规范化后再按照权重进行计算。 名称间的编辑距离。 节点的数据类型相似度。参考《Computing simple and complex matching’s between XML schema for transforming XML documents》中提出的数据类型兼容表。 将符合条件的节点进行配对。节点的映射分为一对一、一对多、多对一这三种情况。按照一对多、多对一、一对一的顺序配对。 根据配对结果，对非标准化的文档进行修改转换，使其成为规范化的文档。 四、任务分配 可视化模式图的生成、节点名称的编辑距离计算、节点的数据类型相似度计算、文档的转换操作。 节点名称规范化、名称间的语义相似度、节点的配对。 五、具体实现由于可通过直接遍历得到节点的相似度以及实现转换，因此在正式实现过程中，没有生成可视化模式图，仅作为测试使用。（具体看代码）","link":"/2020/04/12/%E9%80%9A%E8%BF%87C#%E5%AE%9E%E7%8E%B0Xml%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"nexo","slug":"nexo","link":"/tags/nexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"C#","slug":"C","link":"/tags/C/"}],"categories":[{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法导论","slug":"算法导论","link":"/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"pages":[]}