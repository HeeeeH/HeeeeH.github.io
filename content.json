{"posts":[{"title":"Effective C++笔记","text":"01：把c++视为一个语言联邦02：尽量以const, enum, inline替代#define1. 对于单纯变量，最好用const对象或enum替换#define​ #define由预处理器进行处理，因此可能不被编译器看见。当获得编译器错误信息时无法追踪（通过#define定义的变量可能未进入记号表）。而使用const对象则不会出现这样的问题。 ​ 并且，#define无法限制作用域。当需要定义class的专属常量时，可以通过const定义，并且为了保证此常量至多一个实体，可以将其定义为static类型。 ​ 旧式编译器可能不支持static在声明式中获得初值，那么可以将初值放在定义式。在此情况下，如果class编译期间需要用到class的常量（例如用class常量来定义class内数组的大小），则可以使用“the enum hack”补偿做法，这是因为一个属于枚举类型的数值可以被当作int使用。例如： 12345class GamePlayer {private: enum { NumTurns = 5}; int scores[NumTurns];} ​ “enum hack”某些方面比较像#define，比如取地址不合法，也不会导致非必要的内存分配。 2. 对于形似函数的宏，最好用inline函数替代#define​ 宏不会带来函数调用的额外开销，但是容易出问题。比如必须记住给所有实参加上小括号，但即时加上括号也会出现问题，例如： 12345#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))int a = 5, b = 0;CALL_WITH_MAX(++a, b); //a被累加2次CALL_WITH_MAX(++a, b + 10); //a被累加1次 ​ 可以使用template inline函数代替，这样不需要给每个实参加上小括号，也不需要操心参数被运算多次，例如： 12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a, const T&amp; b){ f(a &gt; b ? a : b);} 03：尽可能使用const1. 将某些东西声明为const可以帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型和成员函数本体。​ const允许指定一个语义约束，即该对象不可被改变，而编译器会确保这项约束。通过返回const对象，可以避免一些错误，例如： const Taritonal operator* (const Rational&amp; lhs, const Rational&amp; rhs)返回const对象，如果用户将 if (a * b == c) 误输入成 if (a * b = c) 时，编译器可以察觉这种错误。若不返回const对象，则对返回值赋值的行为是允许的，也就是编译器会通过这种错误的行为。 ​ 因此，除非需要改变参数或对象，否则应该将其声明为const。 ​ 可以将成员函数声明为const，这将能改动对象和不可以改动对象的函数区分开来。并且，将成员函数声明为const有利于提高c++程序效率（通过pass by reference-to-const的方式传递对象）。两个只有常量性不同的成员函数（即一个为const成员函数，另一个不是）可以被重载。具体调用哪个函数取决于处理的对象是否为const。 2. 编译器强制实行“bitwise constness”，但编程时应该更多采用“logical constness”。​ “bitwise constness”指的是const成员函数不改变任何一个non-static的成员变量。但是一些成员函数不具备const性质却不会引起编译器错误。例如： 若指向非常量的常量指针，只有指针属于对象，则改变该指针所指向的对象不会引起编译器错误（常量指针只确保指针指向同一个对象，不保证指向的对象的内容不改变）。例如： 1234567class CTextBlock {public: char&amp; operator[] (std::size_t position) const { return pText[position]; }private: char* pText;} 这样一个const成员函数，它的返回值实际上可以被改变。这就导致了编译器无法提示的错误。 ​ “logical constness”指的是const成员函数可以修改其对象内的某些内容，但是客户端无法侦察到（读了好多遍没读懂，应该是这个意思吧）。 ​ （这里有个例子，但我没搞明白为什么这个成员函数需要修改对象但是却声明为const，然后再通过mutable来消除const的约束） 3. 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。​ 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本是个安全的做法，即使在这个过程中需要转型。因为const成员函数相当于保证了绝不改变对象，但是non-const成员函数并没有保证。因此令non-const版本调用const版本成员函数不会带来风险，但是反之则可能会使const成员函数改变对象，造成错误。 ​ 例如： 123456789101112131415161718class TextBlock {public: const char&amp; operator[](std::size_t position) const { //边界检测 //日志数据访问 //检验数据完整性 return text[position]; } char&amp; operator[](std::size_t position) { return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt;(*this) [position] ); }} ​ 添加const的转型为安全转型，因此使用static_cast，移除const是通过const_cast完成。 04：确定对象被使用前已经先被初始化1. 为内置型对象进行手工初始化，因为C++不保证初始化它们。​ 读取未初始化的值会导致不确定的行为。如果使用C part of C++且初始化可能带来运行成本时，就无法保证初始化。 ​ 对于内置类型，手工完成初始化；对于其他类型，在构造函数内保证将对象的每一个成员初始化。 1int x = 0; //内置类型初始化 2. 构造函数最好使用成员初始列，而不要在构造函数内使用赋值操作。初始列列出的成员变量，其排列顺序应该和它们在class中的声明次序相同。​ 赋值和初始化操作容易混淆。例如： 123456789class ABEntry {public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;}; 赋值操作： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0;} 成员初始列： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) :theName(name), theAddress(address); thePhones(phones); numTimesConsulted(0){ } ​ 两个构造函数的结果相同，但是成员初始列的效率较高。赋值操作首先调用默认构造函数为theName、theAddress和thePhones设初值，然后再赋予新值。而成员初始列是以name、address和phones为初值对theName、theAddress和thePhones调用拷贝构造函数。因此后者较为高效。 ​ 并且，成员初始列也能够调用默认构造函数，只需要不指定初始化实参即可。例如： 123456ABEntry::ABEntry() :theName(), theAddress(); thePhones(); numTimesConsulted(0) // 这里不知道为什么不调用默认初始化函数{ } ​ 如果成员变量是const或者引用类型，则一定需要初值，而不能被赋值。 ​ 如果class内有多个构造函数，可以将一些“赋值表现和初始化一样好”的成员变量不使用成员初始列，而是改用赋值操作。并且可以将赋值操作移到某个函数（通常private）来供所有构造函数调用。 3. 为避免“跨编译单元的初始化次序”问题，使用local static对象替换non-local static对象。​ C++有固定的“成员初始化”次序：基类早于派生类被初始化，成员变量以声明的次序初始化。因此，成员初始列最好以成员变量的声明次序为次序。但是对于不同编译单元的“non-local static”对象，仍然可能出现初始化次序的问题。 ​ 编译单元指的是产出单一目标文件的源码，通常是单一源码文件加上包含的头文件。static对象的生命周期是从构造出来到程序结束。函数内的static对象称为local static对象，其他称为non-local static对象。因此，可能遇到的问题是：某个编译单元对象的初始化用到了另一个编译单元的non-local static对象，但是不能保证该non-local static对象已经被初始化，因此可能结果出错。例如： 123456class FileSystem {public: std::size_t numDisks() const; ...};extern FileSystem tfs; 12345678910class Directory {public: Directory( params ); ...};Directory::Directory( params ) { std::size_t disks = tfs.numDisks(); ...}Directory tempDir( params ); ​ 如上，想要程序正确运行就需要确保tfs在tempDir之前初始化，但是C++对这里的次序并没有明确定义，也就是无法保证。 ​ 解决方式是使用单例模式的一个常见实现方法：将non-local static对象放在函数内实现，函数再返回一个引用对象指向它所含的对象。因为C++保证函数内的local static对象会在“函数调用期间”“首次遇到该对象的定义式”的时候被初始化，因此可以保证通过函数调用获取的对象的引用一定完成了初始化。并且，如果不调用这个函数，那么构造函数和析构函数的成本也不需要了，相比于local static对象可以节省开销。用例如下： 1234567891011121314class FileSystem { ... };FileSystem&amp; tfs() { static FileSystem fs; return fs;}class Directory { ... };Directory::Directory( params ) { std::size_t disks = tfs().numDisks(); // 调用tfs对象改为调用tfs()函数 ...}Directory&amp; tempDir() { static Directory td; return td;} ​ 但是这种含有static对象的函数在多线程系统中存在不确定性：任何一种non-const static对象（不管local还是non-local）在多线程环境下“等待某件事发生”都会存在麻烦。处理这种麻烦的方式之一是：在程序的单线程启动阶段手工调用所有这种返回引用对象的函数，这样就可以消除初始化有关的“竞速形势”（race conditions）。 05：C++默默编写并调用的函数编译器可以为class自动创建默认构造函数、拷贝构造函数、拷贝赋值函数和析构函数。 所有构造的这些函数都是public且inline的。 只有当这些函数被调用的时候才会被编译器创建出来。 除非class的基类自身声明了virtual析构函数，否则编译器产生的析构函数是non-virtual类型。 只要自己声明了一个构造函数，那么编译器就不会自动创建默认构造函数。 编译器创建的拷贝构造函数和拷贝赋值函数只是单纯将来源对象的每一个non-static成员变量拷贝到目标对象。例如 12345678910template&lt;typename T&gt;class NamedObject {public: NamedObject(const char* name, const T&amp; value); NamedObject(const std::string&amp; name, const T&amp; value); ...private: std::string nameValue; T objectValue;}; 12NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2);NamedObject&lt;int&gt; no2(no1); // 调用拷贝构造函数 ​ no2是通过拷贝构造函数初始化的：no2.nameValue以no1.nameValue调用string的拷贝构造函数，no2.objectValue这里的类型为内置类型int，因此通过“拷贝no1.objectValue内的每一个bit”来完成初始化。 如果编译器自动创建的拷贝构造函数和拷贝赋值函数不合法，那么就不会自动创建。例如： 123456789template&lt;typename T&gt;class NamedObject {public: NamedObject(std::string&amp; name, const T&amp; value); ...private: std::string&amp; nameValue; // 修改为指向string的引用 const T objectValue; // 修改为const类型}; 12345std::string newDog(&quot;Persephone&quot;);std::string oldDog(&quot;Satch&quot;);NamedObject&lt;int&gt; p(newDog, 2);NamedObject&lt;int&gt; s(oldDog, 36);p = s; ​ 如果自动创建了拷贝赋值函数，那么p.nameValue就改为s.nameValue，也就是引用的指向被改变了，但是这是不合法的。因此C++不会为NamedObject自动创建拷贝赋值函数。对于含有const成员的class，编译器也不会自动创建。此外，对于将拷贝赋值函数声明为private的基类，其派生类将不会被自动创建拷贝赋值函数。 06：若不想使用编译器自动生成的函数，则该明确拒绝​","link":"/2023/02/01/Effective%20C++%E7%AC%94%E8%AE%B0/"},{"title":"Effective Modern C++笔记","text":"零. 绪论 左值和右值 概念上，右值对应的是函数返回的临时对象，左值对应的是可指涉的对象（通过名字、指针或左值引用） 甄别方式：能取得地址的为左值。 右值引用类型的形参，该形参本身也是左值。 任何形参都是左值 若某对象是依据同一类型的另一对象初始化出来的，则该新对象称为原对象的一个副本。右值的副本通常由移动构造函数创建，左值的副本通常由复制构造函数创建。 函数对象 指某个对象，其类型支持operator()成员函数。 lambda表达式 创建的函数对象称为闭包。 定义和声明 定义可以当声明用。 函数的形参类型和返回值类型视为函数签名，而函数名字和形参名字不属于函数签名。 一. 类型推导01. 理解模板类型推导​ 在编译期，编译器会通过expr推导两个类型：T的类型和ParamType的类型。这两个类型完全往往不一样，因为ParamType通常包括一些修饰词。 123456// 函数模板template&lt;typename T&gt;void f(ParamType param);// 函数调用f(expr); ​ T的类型的推导结果需要分三种情况讨论： ParamType具有指针或者引用类型，但不是万能引用。 ParamType是一个万能引用。 ParamType既不是指针也不是引用。 - 在模板类型推导过程中，具有引用类型的实参会被当作非引用类型来处理，即其引用性会被忽略。 ​ ParamType具有指针或者引用类型，但不是万能引用时，推导过程如下： 若expr有引用类型，则忽略引用。 对expr和ParamType的类型进行模式匹配，得到T的类型。 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为int&amp;f(cx); // T类型为const int，param类型为const int&amp;f(rx); // T类型为const int，param类型为const int&amp; ​ 向T&amp;类型模板传入const对象是安全的，因为常量性会称为T的类型的一部分。 ​ 若是传给右值引用形参，则推导过程与左值引用相同。 ​ 若把形参类型加上const，则结果如下： 12345678910111213// 函数模板template&lt;typename T&gt;void f(const T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为const int&amp;f(cx); // T类型为int，param类型为const int&amp;f(rx); // T类型为int，param类型为const int&amp; ​ 若param为指针，则推导过程也相同： 1234567891011// 函数模板template&lt;typename T&gt;void f(T* param);// 声明变量int x = 27;const int *px = &amp;x;// 函数调用f(&amp;x); // T类型为int，param类型为int*f(px); // T类型为const int，param类型为const int* - 对万能引用进行推导时，左值实参会进行特殊处理。 ​ ParamType是一个万能引用时，类型推导过程如下： 若expr是左值，则T和ParamType都被推导为左值引用。 若expr是右值，则推导过程与之前相同。 ​ 在expr为左值的情况比较特殊：首先，这是唯一一种T被推导为引用类型的情况；其次，声明的时候采用右值引用语法，但类型推导却是左值引用。 ​ 例如： 1234567891011121314// 函数模板template&lt;typename T&gt;void f(T&amp;&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // x为左值，T类型为int&amp;，param类型为int&amp;f(cx); // cx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(rx); // rx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(27); // 27为右值，T类型为int，param类型为int&amp;&amp; - 对按值传递的形参进行推导时，若实参类型中带有const或volatile修饰，则忽略该修饰词。 ​ ParamType既不是指针也不是引用时，其实就是按值传递，无论传入什么，param都会是一个副本。推导过程如下： 若expr有引用类型，则忽略引用； 若expr是const对象，则忽略const； 若expr是volatile对象，则忽略volatile。 ​ 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T和param类型为intf(cx); // T和param类型为intf(rx); // T和param类型为int ​ 虽然cs和rx有const属性，但是param是完全独立于它们的存在，是它们的副本，因此可以忽略const属性。 ​ 但是const属性只有在按值传递时被忽略，若形参为引用或者指针则const会被保留。但是要额外考虑expr时指向const对象的const指针这种情况： 123456789// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量const char* const ptr = &quot;pointer&quot;;// 函数调用f(ptr); // T和param类型为const char* ​ 也就是说，ptr自身的const属性会被忽略，但是指向对象的const属性会被保留。 - 在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非被用来初始化引用。 ​ 某些情况下，数组会退化成指向其首元素的指针。例如： 12const char name[] = &quot;J. P. Briggs&quot;; // name类型为const char[13]const char *ptrToName = name; // 数组退化成指针 ​ 当数组传递给按值形参的模板时，形参T的类型会被推导为指针类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T param);// 函数调用f(name); // T类型为const char* ​ 但是如果按引用方式传递参数，形参T类型就会被推导为实际的数组类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 函数调用f(name); // T类型为const char[13]，param类型为const char (&amp;)[13] ​ 因此可以用这个能力创建出模板推导数组含有的元素个数： 123456789// 该数组形参未起名字，因为不需要template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;}// 调用函数构建相同大小的数组int keyVals[] = { 1, 2, 3, 4, 5, 6, 7 };std::array&lt;int, arraySize(keyVals)&gt; mappedVals; ​ 除了数组外，函数类型也会退化成函数指针。推导过程与数组相同。例如： 12345678910void someFunc(int, double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc); // param的类型为函数指针，具体为void (*)(int, double)f2(someFunc); // param的类型为函数引用，具体为void (&amp;)(int, double) 02. 理解auto类型推导- 一般情况下，auto类型推导和模板推导是一样的。但是auto类型推导会假定使用大括号的初始化表达式代表std::initializer_list，模板类型推导不会。 ​ 一般情况下，auto类型推导和模板推导是完全相同的。例如： 1234567auto x = 27; // x类型为intconst auto cx = x; // cx类型为const intconst auto&amp; rx = x; // rx类型为const int&amp;auto&amp;&amp; uref1 = x; // x类型为int，且是左值，则uref1类型为int&amp;auto&amp;&amp; uref2 = cx; // cx类型为const int，且是左值，则uref2类型为const int&amp;auto&amp;&amp; uref3 = 27; // 27类型为int，且是右值，则uref3类型为int&amp;&amp; ​ 但是以下这种情况不同： 12345678910111213141516171819// C++98中的初始化方式int x1 = 27;int x2(x1);// C++11中新增了用大括号初始化的方法，结果与上面相同。int x3 = { 27 };int x4{ 27 };// 通过auto推导类型auto x1 = 27; // 类型为intauto x2(x1); // 类型为intauto x3 = { 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27auto x4{ 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27// 通过模板推导类型auto x = { 11, 23, 9 }; // auto推导类型为std::initializer_list&lt;int&gt;template&lt;typename T&gt;void f(T param);f({ 11, 23, 9 }); // 模板推导类型错误，代码不能通过编译 ​ 对于大括号初始化的表达式，auto类型会推导为std::initializer_list&lt;T&gt;类型（T的类型推导为模板推导，也就是需要用到两种类型推导），而模板推导类型则会失败，编译错误。 - 在函数返回值或者lambda表达式形参中使用auto，意思是使用模板推导而不是auto推导。 ​ C++14允许使用auto说明函数返回值或者lambda表达式形参的类型需要推导，但是这里是用模板推导类型的。例如： 123456789// 函数返回值为autoauto createInitList() { return { 1, 2, 3 }; // 错误，无法完成类型推导}// lambda表达式形参中使用autostd::vector&lt;int&gt; v;auto resetV = [&amp;v](const auto&amp; newValue) { v = newValue; };resetV({ 1, 2, 3 }); // 错误，无法完成类型推导 03. 理解decltype- 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。 ​ C++11中，decltype的主要用途大概在于，声明返回值类型依赖于参数类型的函数模板。例如C++11中利用返回值类型尾序语法（trailing return type syntax）声明返回值的类型，这样的好处是，在指定返回值类型时可以使用函数形参。例如： 12345678910111213141516// C++11中使用返回值类型尾序语法（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt; decltype(c[i]) { authenticateUser(); return c[i];}// C++14中可以直接使用auto推导类型（有错误，不能正确运行）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 一般来说，含有类型T的对象的容器，其operator[]会返回T&amp;。std::deque是这样，std::vector几乎总是这样，只有std::vector&lt;bool&gt;不返回bool&amp;，而是返回全新的对象。因此，对于第二段代码，operator[]会返回T&amp;，但是auto类型推导的过程中会忽略expr的引用性，这样返回值类型就变成了T。作为函数的返回值，这里的T为右值，因此无法被赋值，因此有错误。 - C++14支持的decltype(auto)，这样的类型推导使用decltype的规则 ​ 想要authAndAccess返回左值，则可以对返回值使用decltype类型推导。可以通过decltype(auto)来使用decltype的规则进行类型推导。因此可以修改为： 1234567// C++14中可以直接使用auto推导类型（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 但是这样仍然有改进空间。这是因为，容器的传递方式是对非常量的左值引用，但是右值是无法绑定到左值引用的（除非是对常量的左值引用），这样就不能往函数中传递右值容器。可以通过重载维护两个函数，分别声明左值引用形参和右值引用形参。然而，也可以通过万能引用，这种引用形参既能够绑定到左值也能够绑定到右值。 ​ 使用万能引用的话需要应用std::forward（*不知道是什么）。这样可以得到最终修改的版本： 12345678910111213141516// C++14中可以直接使用auto推导类型（最终版）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];}// C++11中使用返回值类型尾序语法（最终版）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp;&amp; c, Index i) -&gt; decltype(std::forward&lt;Container&gt;(c)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} - 对于类型为T的表达式，除非该表达式仅有一个名字，否则decltype得出类型为T&amp; ​ 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。但是对于一个不仅仅是T的名字的表达式，decltype得出类型为T&amp;。例如： 12345678910111213// decltype(x)为int，f1返回intdecltype(auto) f1(){ int x = 0; return x;}// decltype((x))返回int&amp;，f2返回int&amp;decltype(auto) f2(){ int x = 0; return (x);} ​ 这不仅仅是返回类型的错误，f2实际上返回了局部变量的引用，这是非常危险的行为。 04. 掌握查看类型推导结果的方法- 利用IDE编辑器、编译器错误信息和Boost.TypeIndex库常常能查看到推导得到的类型。 - 有些工具可能不准确，因此理解C++类型推导规则是必要的。 ​ 采用那种工具查看类型推导结果取决于在开发过程中的哪个阶段需要该信息： 代码撰写阶段：IDE编辑器 ​ 鼠标悬停时可以查看。原理是让C++编译器在IDE内执行一轮，因此代码需要处在可编译的状态。例如： 123const int theAnswer = 42;auto x = theAnswer; // x类型为intauto y = &amp;theAnswer; // y类型为const int* 编译阶段：编译器诊断信息 ​ 可以通过该类型导致某些编译错误，而报告错误的消息几乎肯定会提及导致该错误的类型。例如： 123// 声明类模板，但是不定义它。template&lt;typename T&gt;class TD; ​ 这样就可以通过TD查看x和y的类型： 12TD&lt;decltype(x)&gt; xType;TD&lt;decltype(y)&gt; yType; ​ 这样编译器会报错，错误信息中会指出x和y的类型。 运行阶段：运行时输出 ​ 可以通过typeid和std::type_info::name查看类型信息，例如： 12std::cout &lt;&lt; typeid(x).name() &lt;&lt; '\\n'; // GNU和Clang：x类型为i，即intstd::cout &lt;&lt; typeid(y).name() &lt;&lt; '\\n'; // GNU和Clang：y类型为PKi，即int const*(PK: pointer to konst const涉及到常量的指针) ​ 但是这样有可能会输出不准确的信息，例如： 12345678template&lt;typename T&gt;void f(const T&amp; param);std::vector&lt;Widget&gt; createVec();if(!vw.empty()) { f(&amp;vw[0]);} ​ 通过typeid和std::type_info::name查看T和param的类型： 1234567template&lt;typename T&gt;void f(const T&amp; param) { using std::cout; cout &lt;&lt; &quot;T = &quot; &lt;&lt; typeid(T).name() &lt;&lt; '\\n'; // T = class Widget const * cout &lt;&lt; &quot;param = &quot; &lt;&lt; typeid(param).name() &lt;&lt; '\\n'; // param = class Widget const *} ​ 输出结果如上，但是结果是错误的。param的类型为const Widget * const &amp;，但是被报告成const Widget *。这是因为通过这种方式推导得到类型和向函数模板传参是一样的，按值传参时会忽略掉const、volatile和&amp;这些修饰词。 ​ 可以通过Boost的TypeIndex库查看，虽然这不是标准C++的一部分（IDE和TD也不是）。使用方法例如： 12345678910111213#include &lt;boost/type_index.hpp&gt;template&lt;typename T&gt;void f(const T&amp; param){ using std::cout; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;T = &quot; &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; '\\n'; // T = Widget const* cout &lt;&lt; &quot;param = &quot; &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; '\\n'; // param = Widget const* const&amp;} 二、auto05. 优先选用auto，而不是显式类型声明- auto变量必须初始化。使用auto基本可以避免因为类型不匹配而导致的兼容性和效率问题，还可以简化重构流程，并且代码量更少。 - auto类型也存在着一些问题（如02和06） ​ auto类型可以节省代码量，不用费大心思思考变量类型，例如： 12345678910template&lt;typename It&gt;void dwim(It b, It e) { while(b != e) { auto currValue = *b; // 等价于 // typename std::iterator_traits&lt;It&gt;::value_type currValue = *b; ... }} ​ 另外，对于std::function，使用auto类型也有非常大的优势。例如： 1234auto derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ std::function是C++11标准库中的一个模板，把函数指针的思想加以推广，可以指向任何可以调用的对象。比如，std::function可以指向lambda表达式。上述用例就可以表示为： 12345std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ 但是跟auto类型声明相比： auto声明的变量所要求的内存量与lambda表达式相同，而std::function声明的变量是其实例，所以占有固定内存。因此，std::function一般占用更多内存。 编译器一般会产生间接函数调用，通过std::function调用lambda表达式几乎必然会比auto声明更慢。 另外，auto声明还可以避免一些不明确类型所产生的错误。例如： 12std::vector&lt;int&gt; v;unsigned sz = v.size(); // v.size()为std::vector&lt;int&gt;::size_type，向unsigned隐式转换。 ​ std::vector&lt;int&gt;::size_type是无符号整型。在32位Windows上，unsigned和std::vector&lt;int&gt;::size_type尺寸相同，但是64位Windows上，unsigned是32位而std::vector&lt;int&gt;::size_type是64位，因此可能出错。 ​ 再比如： 123std::unordered_map&lt;std::string, int&gt; m;for(const std::pair&lt;std::string, int&gt;&amp; p : m){ ... } // 代码有问题for(const auto&amp; p : m){ ... } // 用auto声明可以避免这个问题 ​ 这里std::unordered_map的键值部分是const，也就是里面的键值对类型实际上为std::pair&lt;const std::string, int&gt;。上述代码实际上会对m中每一个对象进行复制操作，将p绑定到产生的临时对象上。 并且，auto可以简化重构流程。比如函数本来声明的返回类型为int，后续改为long时，使用auto声明返回值只需要重新编译便可以直接更新。 06. 当auto推导的类型不符合要求时，使用显式类型的初始化方法- “隐形”的代理类型可能会导致auto推导出“错误的”类型 ​ 举例来说： 123456789std::vector&lt;boo&gt; features(const Widget&amp; w);Widget w;bool highPriority = feature(w)[5];processWidget(w, highPriority);// 若使用auto类型声明auto highPriority = feature(w)[5];processWidget(w, highPriority); // 未定义的行为 ​ 实际上，highPriority的返回值不是bool类型。对于其他类型，std::vector::operator[]都返回容器内一个元素的引用，但是std::vector&lt;bool&gt;返回的是std::vector&lt;bool&gt;::reference对象。这是一个代理类的实例。代理类指的是为了模拟或者增广其他类型的类，比如智能指针也是代理类。有些代理类比较明细那，但是有些是“隐形代理”，难以察觉。这种类的对象往往生命周期只有单个语句，因此容易出现创建这种类型容易出现未定义的行为。 ​ 在上述例子中，auto实际推断的类型是std::vector&lt;bool&gt;::reference，是一个临时对象，在语句结束时就被析构，因此之后会产生未定义的行为。 - 带显式类型的初始化方法可以强制推导出想要的类型 ​ 可以通过带显式类型的初始化方法来避免上述问题。使用方法如下： 1auto highPriority = static_cast&lt;bool&gt;(feature(w)[5]); // std::vector&lt;bool&gt;::reference被强制转换为bool类型 ​ 除了能够避免隐形代理类产生的问题，还可以用来强调变量进行了类型转换。例如： 1234567double calcEpsilon();// float的精度足够，并且在意变量的存储空间大小的情况下，可以用float类型存储该返回值float ep = calcEpsilon();// 与上面意思相同，但是强调了“降低返回值精度”auto ep = static_cast&lt;float&gt;(calcEpsilon()); 三、转向现代C++07. 创建对象时注意区分()和{}To be continued","link":"/2023/04/04/Effective%20Modern%20C++%E7%AC%94%E8%AE%B0/"},{"title":"GitHub下载速度太慢的解决方式","text":"一、修改host文件1.访问https://www.ipaddress.com/。 2.查询github.com和github.global.ssl.fastly.net的对应ip地址。 3.进入目录C:\\Windows\\System32\\drivers\\etc，以管理员权限打开hosts文件。 4.将查询到的ip地址加入hosts文件。例如： 12140.82.112.4 github.com199.232.69.194 github.global.ssl.fastly.net 5.在powershell打开执行命令，刷新DNS 缓存。 1ipconfig /flushdns 二、从gitee下载1.点击从GitHub\\GitLab导入仓库。 2.输入Git仓库URL。 3.直接执行git clone xxxx(gitee仓库的地址)。","link":"/2020/12/13/GitHub%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"},{"title":"IDEA已有maven插件但mvn出错","text":"mvn命令找不到是因为maven环境变量未配置，因此需配置环境变量。 1.找到IDEA下的maven位置例如：D:\\IntelliJ IDEA 2019.3.3\\plugins\\maven\\lib\\maven3 2.配置环境变量（1）右键此电脑的属性。 （2）点击高级系统设置。 （3）点击环境变量。 （4）点击新建。 （5）输入变量名MAVEN_HOME和变量值（IDEA下的maven位置）。 （6）点击编辑。 （7）点击新建，新增%MAVEN_HOME%\\bin项。 （8）点击确定，完成环境变量设置。","link":"/2020/12/13/IDEA%E5%B7%B2%E6%9C%89maven%E6%8F%92%E4%BB%B6%E4%BD%86mvn%E5%87%BA%E9%94%99/"},{"title":"Icarus主题美化","text":"本文面向前端小白！仅记录自己修改的部分！ 个人主题配置​ 主要就是修改_config.icarus.yml文件，具体主题配置可以参考Icarus用户指南。 网页显示的图标 123# _config.icarus.ymlhead: favicon: /img/pikachu.svg Logo修改 12# _config.icarus.ymllogo: /img/logo_pikachu.svg 网页显示的标题 12# _config.ymltitle: Hyeee's Home 网页显示的语言 可以在node_modules\\hexo-theme-icarus\\languages目录下查看可用的语言 PS：如果找不到相应的语言，会自动选择德语（经验之谈） 12# _config.ymllanguage: zh-CN 个人信息修改 1234567widgets: - author: Hyeee author_title: '|ू･ω･` )' location: Hangzhou, China avatar: /img/avatar_pikachu.jpg follow_link: https://github.com/HeeeeH 其他一些七七八八的，比如cookie、赞赏、评论什么的不太会就先全部注释掉啦 加入背景图片 将背景图片放到node_modules\\hexo-theme-icarus\\source\\img目录下 修改node_modules\\hexo-theme-icarus\\include\\style\\base.styl文件，在body样式下加入以下几行 12345body ... ... background: url(../img/background_op.png) no-repeat background-attachment: fixed background-size: cover background的属性说明 url：图片路径（这里填的是相对路径） attachment ：图片是否滚动（fixed为 不滚动，scoll 为滚动） size：图片大小（原始尺寸为 auto ，覆盖为 cover ，拉伸为 contain 等） PS：背景图片的不透明度有点难调，所以我选择PS手动调节(。-`ω´-) 标签颜色更改​ 主题的颜色定义在node_modules\\hexo-theme-icarus\\include\\style\\base.styl中，可以将$primary直接修改为想要的颜色。例如： 1$primary ?= $yellow ​ 但是这样的修改不全面，还有很多地方的颜色是硬编码。这里记录一下我修改的地方： base.styl: $navbar-item-active-color $menu-item-active-color $menu-item-active-background-color article.styl article &amp;.media color article &amp;.media a &amp;:hover color helper.styl .link-muted &amp;:hover color navbar.styl .navbar-main .navbar-item &amp;.is-active color .navbar-main .navbar-item &amp;.hover color PS：找不到对应元素的标签或class怎么办？ 可以通过F12，选中页面元素查看对应元素的标签以及class，然后直接修改在自定义的custom.styl中。 // 例如修改导航栏悬浮时的颜色 a.navbar-item:hover, .navbar-link:hover, a.navbar-item.is-active, .navbar-link.is-active { background-color: #fafafa; color: #ff9600; } 12345- 再在node_modules\\hexo-theme-icarus\\source\\css\\style.styl文件中引入custom.styl。 - ```stylus @import './custom' TODO 夜间模式 评论 参考文章icarus用户指南-主题配置 活用 Bulma 美化 Icarus 文章 icarus主题自定义 Hexo-icarus主题黑夜模式以及背景","link":"/2024/02/02/Icarus%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"title":"Java刷题基础语法","text":"一、Java集合概览​ Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。 ​ Java 集合框架如下图所示： List：存储的元素是有序的、可重复的。 ArrayList：Object[] 数组。 Vector：线程安全，使用 synchronized 进行同步，了解即可。 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。 Set：存储的元素不可重复的。 HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。 Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 PriorityQueue: Object[] 数组来实现小顶堆。 DelayQueue:PriorityQueue。 ArrayDeque: 可扩容动态双向数组。 Map：使用键值对（key-value）存储。key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 HashMap：JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：LinkedHashMap 在 HashMap的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。 二、常见数据结构及用法1. 数组1）赋值 初始化时直接赋值 1int[] intArray = new int[]{1, 2, 3, 4}; 通过 Java Util 类的 Arrays.fill(arrayname,value) 12345int[] intArray = new int[10];// Arrays.fill(arrayname, value) Arrays.fill(intArray, 100);// Arrays.fill(arrayname, starting index, ending index, value) Arrays.fill(intArray, 3, 6, 50); 注：Arrays.fill只能给一维数组赋初值，二维数组需要循环赋值。如下： 1234int[][] intArray = new int[10][10];for(int i = 0; i &lt; intArray.length; ++i) { Arrays.fill(intArray[i], 100);} 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intArray.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intArray) { System.out.println(a);} 3）数组复制 直接赋值（没有拷贝） intArray2和intArray1是指向同一个数组对象的。 12int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = intArray1; System.arraycopy（浅拷贝） 方法：arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = new int[5];System.arraycopy(intArray1, 0, intArray2, 0, intArray1.length); Arrays.copyOf和Arrays.copyOfRange（浅拷贝） 方法：copyOf(T[] original, int newLength)和copyOfRange(T[] original, int from, int to) 如果newLength不合法，即小于0，那么抛出NegativeArraySizeException异常 如果newLength小于源数组长度，则复制指定长度的数组元素 如果newLength大于源数组长度，则新数组中超出源数组长度的元素则是默认值 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = Arrays.copyOf(intArray1, intArray1.length);int[] intArray3 = Arrays.copyOfRange(intArray1, 0, intArray1.length); 对象拷贝（Object.clone） clone()比较特殊，对于对象而言，它是深拷贝，但是对于数组而言，它是浅拷贝。拷贝数组时会返回一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 4）Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 能够给数组赋值、对数组排序、比较数组和查找数组元素。具体如下表： 方法 说明 int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。也可以调用**binarySearch(Object[], int fromIndex, int toIndex, Object key)**在指定位置查找给定值。 boolean equals(long[] a, long[] a2) 若两个数组以相同顺序包含相同的元素，则两个数组是相等的。适用于所有的其他基本数据类型。 void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。适用于所有的其他基本数据类型。 void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。适用于所有的其他基本数据类型。可以传入方法指定按照特定方法排序。例如，Collections.reverseOrder()进行反向排序；String.CASE_INSENSITIVE_ORDER进行忽略大小写排序。 String toString(Object[] a) 能将数组中的内容全部打印出来。适用于所有的其他基本数据类型。 举例如下： 12345678910111213int[] intArray = new int[5];// 调用Arrays.fill进行赋值Arrays.fill(intArray, 4);// 调用Arrays.sort进行排序Arrays.sort(intArray);// 调用Arrays.sort从指定位置进行排序Arrays.sort(intArray, 2, 4);// 调用Arrays.sort进行反向排序Arrays.sort(intArray, Collections.reverseOrder());// 调用Arrays.binarySearch查找指定元素System.out.println(Arrays.binarySearch(arr, 30));// 调用Arrays.toString打印数组元素System.out.print(Arrays.toString(intArray)); 5）数组与List之间相互转换- 对象数组转为基本数据类型数组 stream流执行转换 1int[] intArray = integerArray.stream().mapToInt(Integer::valueOf).toArray(); - 基本数据类型数组转为对象数组 stream流执行转换 1Integer[] integerArray = Arrays.stream(intArray).boxed().toArray(Integer[]::new); - 对象数组转为List 最常见方式，但不支持增删（会抛异常） 1List intList = Arrays.asList(intArray); 数组转为List后，支持增删改查的方式 1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(Arrays.asList(intArray)); 通过集合工具类Collections.addAll()方法（最高效） 12ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(intArray.length);Collections.addAll(intList, intArray); 使用stream中的collector 1List&lt;Integer&gt; intList = Arrays.stream(intArray).collect(Collectors.toList()); - List转为对象数组 toArray()方法，需要传入对应的对象数组构造函数并指定数组的长度 1Integer[] intArray = intList.toArray(new Integer[intList.size()]); stream流的toArray()方法，需要传入对应对象的构造方法的方法引用 1Integer[] intArray = intList.stream().toArray(Integer[]::new); - List转为基本数据类型数组 stream流执行转换 123456// 方法引用int[] intArray1 = intList.stream().mapToInt(Integer::intValue).toArray();// lambda表达式int[] intArray2 = intList.stream().mapToInt(i-&gt;i).toArray();// 先使用filter过滤int[] intArray3 = intList.stream().filter(integer -&gt; integer!=null).mapToInt(i-&gt;i).toArray(); - 基本数据类型数组转为List stream流执行转换 123List&lt;Integer&gt; intList1 = Arrays.stream(intArray).mapToObj(Integer::new).collect(Collectors.toList());// 采用boxed装箱List&lt;Integer&gt; intList2 = Arrays.stream(intArray).boxed().collect(Collectors.toList()); 利用CollectionUtils集合工具类进行转换 1List&lt;Integer&gt; intList = CollectionUtils.arrayToList(intArray); 2. 列表 List1）Collection通用方法： Collection 接口 方法 元素个数 size() 是否为空 isEmpty() 是否包含某元素 contains(Object o) 迭代器 iterator() 清空所有元素 clear() 转为数组 toArray() 增加元素 add(E e) 删除元素 remove(Object o) 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intList.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intList) { System.out.println(a);} for-each遍历 1intList.forEach(a -&gt; System.out.println(a)); 3）排序 使用List.sort排序。 可以使用lambda函数按照指定顺序排序。例如： 123List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();// 按照从大到小的顺序排序intList.sort((o1, o2) -&gt; o2 - o1); 使用Collections.sort排序。 同样可以使用lambda函数按照指定顺序排序。例如： 1234567891011List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();Collections.sort(intList);// 按照从大到小的顺序排序Collections.sort(intList, (o1, o2) -&gt; o2.compareTo(o1));// 这等价于Collections.sort(intList, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); }}); 4）Collections工具类 排序操作 123456void reverse(List list)//反转void shuffle(List list)//随机排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j)//交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 查找,替换操作 1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 3. 队列 Queue1）基础队列Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。 Queue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 2）优先队列 PriorityQueuePriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。方法与Queue相同。 PriorityQueue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 利用Lambda表达式自定义比较函数。例如： 1PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((o1, o2)-&gt;o2-o1); 这等价于： 12345678PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;( new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); 注：Java中默认为小根堆，C++中默认为大根堆。 3）双端队列 DequeDeque 是双端队列，在队列的两端均可以插入或删除元素。 Deque 扩展了 Queue 的接口，增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类： Deque 接口 抛出异常 返回特殊值 插入队首 addFirst(E e) offerFirst(E e) 插入队尾 addLast(E e) offerLast(E e) 删除队首 removeFirst() pollFirst() 删除队尾 removeLast() pollLast() 查询队首元素 getFirst() peekFirst() 查询队尾元素 getLast() peekLast() 4. 栈 StackStack继承自Vector，与Vector一样使用synchronized关键字修饰来保证线程安全，但也因此效率低下。因此，在实际应用中多采用Deque来实现栈的功能。例如： 1Deque deque = new LinkedList&lt;Integer&gt;(); 另外，从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。ArrayDeque 也可以用于实现栈。使用如下： 1Deque deque = new ArrayDeque&lt;Integer&gt;(); 当作为栈使用时，可以采用如下方法： Deque 接口 抛出异常 返回特殊值 入栈 push(E e) 出栈 pop() poll() 查看栈顶 element() peek() 5. 字符串 String 方法说明 方法 指定索引处的 char 值 char charAt(int index) 字符串长度 int length() 判断字符串是否为空 boolean isEmpty() 返回字符串的副本，忽略前导空白和尾部空白。 String trim() 将String 中的所有字符都转换为小写 String toLowerCase() 将String 中的所有字符都转换为大写 [String toUpperCase() 比较两个字符串 int compareTo(String anotherString) 比较两个字符串是否相等 boolean equals(Object anObject) 连接字符串 String concat(String str) 将此字符串转换为一个新的字符数组 char[] toCharArray() 返回一个新的字符串，是此字符串的子字符串 String substring(int beginIndex) String substring(int beginIndex, int endIndex) 字符串是否有指定前缀/后缀 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) 指定字符第一次出现的索引 int indexOf(String str) int indexOf(String str, int fromIndex) 指定字符最后一次出现的索引 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换字符串 String replace(char oldChar, char newChar) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分字符串 String[] split(String regex) String[] split(String regex, int limit) 6. 字典 Map1）基本操作 方法说明 方法 map的长度 size() 插入元素 put(Object key, Object value) 获取元素 get(Object key) 移除元素 remove(Object key) 清空map clear() map是否为空 isEmpty() 是否包含指定key containsKey(Object key) 是否包含指定value containsValue(Object value) 2）排序1234567Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;((o1, o2)-&gt;o2-o1);// 这等价于Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { return o2.compareTo(o1); }}); 3）for循环遍历- keySet()遍历123456789for (String key : map.keySet()) { System.out.println(key + &quot; ：&quot; + map.get(key));}// 这等价于Iterator&lt;String&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) { String key = iterator.next(); System.out.println(key + &quot; ：&quot; + map.get(key));} - entrySet()遍历123456789for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());}// 这等价于Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) { Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());} - for-each遍历1map.forEach((k, v)-&gt;times.add(v)); 三、常用算法1. 通过stream()1）List取最值12intList.stream().max(Integer::compareTo).get();intList.stream().min(Integer::compareTo).get(); 2）List取平均值1intList.stream().mapToInt(Integer::intValue).average().orElse(0D); 3）List求和1integers.stream().reduce(Integer::sum).get(); 四、参考文档Java集合常见面试题总结 java中数组拷贝（深拷贝）的四种方法 Java map 详解 - 用法、遍历、排序、常用API等 Java8 stream平均值、最小数、最大数、求和","link":"/2023/05/01/Java%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"nexo","slug":"nexo","link":"/tags/nexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}],"pages":[]}