{"posts":[{"title":"Django项目总结","text":"概述题目：基于bytom信息流的新闻聚合网站。问题说明：本系统首先需要通过网络爬虫爬取Bytom发布在各个平台的内容信息，通过对这些信息的分类，可以清晰的展示，帮助人们更好的获取到信息。因为种种原因报名了python程序设计挑战赛，所以才有了这个项目。事实证明，人可能要有点自知之明…不管怎样，过程中间还是学到了一些的（大概）。 忏悔本来准备时间是一个月，但是因为期中考、出去玩以及犯懒等等私人原因，到ddl前3天才真正开始做，导致各种睡眠不足，水课补作业补到头疼。下次一定不拖到ddl了（这个flag我就立这儿了）。 分工因为之前接触过一点前端（而且感觉比较简单好学一些…html、css什么的），所以初步定是我负责前端，另俩人分别负责后台和爬虫。结果负责后台的小伙伴咕咕了好久…所以后台最后也差不多是我和另一个人完成的。 反省在完成项目的过程中，有遇到许多小问题，感觉下次可以改进一些。 用github远程仓库因为全部从0开始学，有很多参考网上的代码，对于那个实际效果其实是不确定的，因此需要不断地测试（也有可能就我）。github可以记录每次更新的功能，还可以版本回退…是个好东西啊。（但我因为犯懒之前没搞…导致用了复制压缩包存档的蠢办法） coding代码托管现在才突然发现这个和git仓库是两回事…之前我一直以为是一个东西。不管怎样，反正多人合作的话，需要一个能共同记录的东西（对…因为之前没搞，导致各种qq文件满天飞，文件的重命名看得我心好累）。 规划好项目结构这次毕竟完成的很匆忙，很多功能直接照搬别人，但自己在写的过程中又会有很多想法涌现（最后因技术不到位夭折了…）。应该在一开始就确定整个项目的构建。（毕竟是第一次，我就原谅自己啦！） 好好学习还是懂的太少了…完成的很心累，因为很多是按照自己的思路来走，每一个小问题都需要上网查，还会有很多意想不到的bug…上网查找能力也要加强啊…在好不容易找到网上一篇思路基本类似的一系列文章的时候，那一部分的代码已经勉勉强强完成了（心痛）。 项目总结其实从这里才算步入正题… 思路基本照搬别人（学长）的想法。 功能：***1.***首页显示各网址及其跳转链接，并对根据网址获取来源添加对应的标签***2.***可通过导航栏对不同来源网址进行分类（这里学长是设置的只有用户登录才有这个功能，但我们是对所有用户开放）***3.***收藏喜欢的网页，并在可在个人收藏查看（学长设置的只有登录用户有这个功能，但因为一些原因，我们实现的是对所有用户开放，但非登录用户只有临时收藏的功能（一刷新就没了））***4.***用户的登录及注册功能 还存在的bug：***1.***页面跳转过程中闪现的情况***2.***页脚不固定在底部***3.***导航栏中因为出现滚动条导致的页面布局稍有变化（发现全是前端的锅…） 需完善的功能：***1.***用户注册时邮箱的格式验证及密码的长度、格式检测后期可以考虑实现的功能：***1.***对首页的各项链接通过不同的方式排序，例如发表时间***2.***对首页的各项链接进行分页展示（这个学长完成了）***3.***对各项链接可以进行搜索（这个前期的页面实现了…但因为时间不够技术不足等不可抗因素被暂时搁浅）***4.***用户登录后的功能完善，例如个人信息的更改***5.***实时爬取数据（这个我反正做不了…）***6.***对于不同数据展示评论、喜欢等人数（这个学长也实现了）7. … …（感觉可完成的还有好多好多啊…毕竟我们做的只是最简陋的还充满bug的小项目） 实际项目进程时间顺序：5.16以前：写爬虫的小伙伴好像开始的比较早…他应该之前就写了一些了。但我在这之前只是看过一些关于django的入门教程，以及红家的项目，参考了一下前端代码。5.16：看了学长的完成页面，参考一下，开始写页面。初步页面布局就废了我一个下午加晚上，所有功能都没有实现。5.17、5.18：基本完成功能。（我实在记不得了…果然还是用git的好！） 项目完成顺序：***1.***爬虫获取网页数据（后期也有完善）***2.***首页、用户登录、用户注册页面布局***3.***导航栏功能实现***4.***收藏功能实现（临时用户）***5.***用户登录、注册实现***6.***用户的个人收藏功能实现 完成过程中遇到的问题及解决办法***1.***前端布局中div、文本等居中问题解决办法：用flex布局、text-align、margin、绝对位置解决反省：css还是用不熟练，天知道我仅仅为了把东西布局到页面正中花了多少心思。可以考虑多参考其他网页的页面布局以及多练手。 ***2.***导航栏实现不同链接展示问题问题：一开始使用.append方法增加html内容，后来发现这样页面信息无法保存。解决办法：给不同标签的链接加上不同class，点击时分别显示对应的内容，其他的隐藏。反省：可能还是写得少看得少，这个办法我也是自己想的，不晓得其他人怎么解决的，不管怎样，最终效果达到了（就是过程充满艰辛…）。 ***3.***未登录时使用临时收藏夹跳出提示框题外话：一开始的提示框太难看了，又没法修改内容，于是想自己写一个。问题：提示框的出现用下降实现，但会有一直点就一直下降问题。解决办法：直接上代码$('.alert').css(&quot;top&quot;, 50+&quot;px&quot;).show().animate({top:&quot;+=20px&quot;}, 100);反省：嗯…写代码要靠脑子的（要么有强大的搜索能力应该也行…但我没） ***4.***临时收藏功能题外话：说了个实话，这个功能跟我一开始想的不一样…是因为一开始没考虑到记录用户到数据库的问题，所以想用这个实现，算阴差阳错吧。问题：一开始不知道怎么实现增加对应的div的class解决办法：直接上代码 12345678910$('.icon').on('click', function () { var b_src = $(this).attr('src'); if(b_src == '/static/imgs/collect1.png'){ $(this).attr('src', '/static/imgs/collect0.png'); $(this).parent().removeClass('hascolloect'); }else if(b_src == '/static/imgs/collect0.png'){ $(this).attr('src', '/static/imgs/collect1.png'); $(this).parent().addClass('hascolloect'); } }) 注：这不是最终完成代码，只截取了涉及本问题部分。（重点：用.parent()解决）反省：有的时候真是为自己的机智折服…（没别的本事，只能在这种小小的问题上高兴一下下） ***5.***登陆后显示功能列表题外话：显示的问题的话在网上找到了直接的解决办法问题：判断用户是否登录，若登录则显示功能列表，用本身logined的判断不成功解决办法：用$('#login').text().indexOf(&quot;Hello&quot;) &gt;= 0判断，完整代码如下： 12345678910111213141516171819202122$('.collect').hide();if($('#login').text().indexOf(&quot;Hello&quot;) &gt;= 0){ var timer; $('#login').mouseover(function () { clearTimeout(timer); $('.collect').show(); }) $('#login').mouseout(function () { timer = setTimeout(function () { $('.collect').hide(); }, 50); }) $('.collect').mouseover(function () { clearTimeout(timer); $('.collect').show(); }) $('.collect').mouseout(function () { timer = setTimeout(function () { $('.collect').hide(); }, 50); })} ***6.***用户的个人收藏传递到后台题外话：这个问题可多…我几乎是要从开始到放弃到自闭，好在后台数据库的问题小伙伴解决了，只剩前端传参的问题（虽然这也是个可大的问题…一开始小伙伴想到用form表单解决，解决是解决了，但带来的问题更多，我又不想修复这方面的bug，坚信ajax可以解决这个问题的！）问题：用ajax传参不成功（html500错误码）解决办法：上代码 12345678910111213function add_fav(fav_id){ $.ajax({ cache: false, type: &quot;post&quot;, url: &quot;{% url &quot;stars&quot; %}&quot;, data:{'fav_id': fav_id}, async: true, beforeSend:function(xhr, settings){ xhr.setRequestHeader(&quot;X-CSRFToken&quot;, &quot;{{ csrf_token }}&quot;); }, });}add_fav($(this).parents().children('.webid').text()); 注：我一开始一直以为是url的问题（实际应该也有问题），改了半天，检查发现提交到./star/这个地址去了，而不是我所想的使用view.py里的star这个方法。后来发现小伙伴一开始给的路径没配置好，这个方法本来就需要路径实现，最终url填的就是实现这个方法的路径。顺带一提，网上说cache: false,这一句去掉也会报html500错误码。且这一句不加会有跨域的错误。小问题1：传参数据不对问题描述：一开始用，检查的时候才发现获取不到信息。解决办法：我在前端页面加了一个不可见的标签，里面内容为,之后再用.text()获取里面的信息。反省：我真的想知道别人是怎么解决这个问题的…要不然我真觉得自己可机智了小问题2：后台获取信息有误题外话：这咱真不知道什么情况，咱也不敢问…我是看着小伙伴的代码直接复制粘贴的。解决办法： 1exist = record.fav.get(id=int(fav_id)) 改为 1234try: exist = record.fav.get(id=int(fav_id))except: exist = None 小问题3：对应修改的用户和实际信息不匹配解决办法： 1username = request.POST.get('username', None) 改为 1user=request.session['user_name'] 反省：咱啥也不知道… ***7.***用户数据传递到后台后，在前端显示收藏情况问题描述1：在个人收藏页面只显示收藏数据，点击导航栏又可以显示全部链接，需在同一个页面实现解决办法：用了两个for循环，分别加不同的class，在点击个人收藏后，隐藏包含全部链接的for循环的元素；点击导航栏时，隐藏包含收藏链接的for循环的元素。问题描述2：在点击导航栏后，需要判断元素是否为收藏，然后显示相应的图标。解决办法：在包含全部链接的for循环中加一层判断，再加一层包含收藏链接的for循环，如果两个元素相同，说明该元素被收藏，显示被收藏图标，否则在循环结束后显示未被收藏图标。代码如下（包含1、3问题的解决）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455{% for web in c_Webs %}&lt;div class=&quot;conitem con{{ web.type }} collectcon&quot;&gt; &lt;p class=&quot;urlitem&quot;&gt; &lt;p style=&quot;display: none&quot; class=&quot;webid&quot;&gt;{{ web.id }}&lt;/p&gt; &lt;img src=&quot;/static/imgs/collect1.png&quot; class=&quot;icon&quot;&gt; &lt;a href=&quot;{{ web.urls }}&quot;&gt; {{ web.title }} &lt;/a&gt; {% ifequal web.type 'bilibili'%} &lt;span class=&quot;from&quot;&gt;bilibili&lt;/span&gt; {% endifequal %} {% ifequal web.type 'jianshu'%} &lt;span class=&quot;from&quot;&gt;简书&lt;/span&gt; {% endifequal %} {% ifequal web.type 'weibo'%} &lt;span class=&quot;from&quot;&gt;微博&lt;/span&gt; {% endifequal %} {% ifequal web.type 'github'%} &lt;span class=&quot;from&quot;&gt;github&lt;/span&gt; {% endifequal %} &lt;/p&gt;&lt;/div&gt;{% endfor %}{% for web in Webs %}&lt;div class=&quot;conitem con{{ web.type }} normalcon&quot;&gt; &lt;p class=&quot;urlitem&quot;&gt; &lt;p style=&quot;display: none&quot; class=&quot;webid&quot;&gt;{{ web.id }}&lt;/p&gt; {% if c_Webs %} {% for item in c_Webs %} {% ifequal web item %} &lt;img src=&quot;/static/imgs/collect1.png&quot; class=&quot;icon hascollect&quot;&gt; {% endifequal %} {% endfor %} &lt;img src=&quot;/static/imgs/collect0.png&quot; class=&quot;icon nocollect&quot;&gt; {% else %} &lt;img src=&quot;/static/imgs/collect0.png&quot; class=&quot;icon nocollect&quot;&gt; {% endif %} &lt;a href=&quot;{{ web.urls }}&quot;&gt; {{ web.title }} &lt;/a&gt; {% ifequal web.type 'bilibili'%} &lt;span class=&quot;from&quot;&gt;bilibili&lt;/span&gt; {% endifequal %} {% ifequal web.type 'jianshu'%} &lt;span class=&quot;from&quot;&gt;简书&lt;/span&gt; {% endifequal %} {% ifequal web.type 'weibo'%} &lt;span class=&quot;from&quot;&gt;微博&lt;/span&gt; {% endifequal %} {% ifequal web.type 'github'%} &lt;span class=&quot;from&quot;&gt;github&lt;/span&gt; {% endifequal %} &lt;/p&gt;&lt;/div&gt;{% endfor %} 注：其中一长串的ifequal判断是用来加文本标签的，与本问题无关问题描述3：在实际写的过程中，因为问题2的解决方法带来了新的问题，就是根据循环中相同两个元素相同的次数会显示对应次数的图标。解决办法：给所有图标加上class注明该图标是否被收藏，若被收藏则不显示未被收藏的图标。代码如下： 123if($('.icon').hasClass('hascollect')){ $('.hascollect').parents().children('.nocollect').hide();} 反省：有的时候真是不知道是自己太傻，没见过真正有效率的解决方法，还是说有点机智，对于各种bug都想到了解决方法…***8.***最后发现一个…凡是实现不同显示的问题，都可以用添加、删除class解决！ 个人总结因为这个真的耗费了挺大心力的…（虽然主要是因为前期不作为导致后来赶工赶得要死）在星期四、星期五基本满课，以及上周末犯懒没写物理作业的极度困难情况下，硬是挤出时间（在水课上写了好多…）勉勉强强完成了这个项目（虽然后面改bug的时候已经超过截止时间了…）最后写这个总结也花了我一上午…总的来说还是有收获的吧，果然还是要好好学习啊…接下去我又要面对各种因为这个而拖欠的作业了…以及期末各种大作业。啊，人生…","link":"/2019/05/01/Django%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"title":"C++运算符重载","text":"关于运算符重载12345678Box operator+(const Box&amp; b){ Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box;} this为运算符前对象，b为运算符后对象。 如：Box3 = Box1 + Box2;Box1为this，Box2为b。也由此可知，运算符重载中传入参数只能放于运算符后。因此，对于想改变运算顺序的运算符重载，必须使用友元函数。而使用友元函数时，也要注意： 当重载为成员函数时，会隐含一个this指针；当重载为友元函数时，不存在隐含的this指针，需要在参数列表中显示地添加操作数。 参考资料：C++ 二元运算符重载C++ 操作符重载形式——成员函数 or 友元函数","link":"/2019/02/01/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"Effective C++笔记","text":"01：把c++视为一个语言联邦02：尽量以const, enum, inline替代#define1. 对于单纯变量，最好用const对象或enum替换#define​ #define由预处理器进行处理，因此可能不被编译器看见。当获得编译器错误信息时无法追踪（通过#define定义的变量可能未进入记号表）。而使用const对象则不会出现这样的问题。 ​ 并且，#define无法限制作用域。当需要定义class的专属常量时，可以通过const定义，并且为了保证此常量至多一个实体，可以将其定义为static类型。 ​ 旧式编译器可能不支持static在声明式中获得初值，那么可以将初值放在定义式。在此情况下，如果class编译期间需要用到class的常量（例如用class常量来定义class内数组的大小），则可以使用“the enum hack”补偿做法，这是因为一个属于枚举类型的数值可以被当作int使用。例如： 12345class GamePlayer {private: enum { NumTurns = 5}; int scores[NumTurns];} ​ “enum hack”某些方面比较像#define，比如取地址不合法，也不会导致非必要的内存分配。 2. 对于形似函数的宏，最好用inline函数替代#define​ 宏不会带来函数调用的额外开销，但是容易出问题。比如必须记住给所有实参加上小括号，但即时加上括号也会出现问题，例如： 12345#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))int a = 5, b = 0;CALL_WITH_MAX(++a, b); //a被累加2次CALL_WITH_MAX(++a, b + 10); //a被累加1次 ​ 可以使用template inline函数代替，这样不需要给每个实参加上小括号，也不需要操心参数被运算多次，例如： 12345template&lt;typename T&gt;inline void callWithMax(const T&amp; a, const T&amp; b){ f(a &gt; b ? a : b);} 03：尽可能使用const1. 将某些东西声明为const可以帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型和成员函数本体。​ const允许指定一个语义约束，即该对象不可被改变，而编译器会确保这项约束。通过返回const对象，可以避免一些错误，例如： const Taritonal operator* (const Rational&amp; lhs, const Rational&amp; rhs)返回const对象，如果用户将 if (a * b == c) 误输入成 if (a * b = c) 时，编译器可以察觉这种错误。若不返回const对象，则对返回值赋值的行为是允许的，也就是编译器会通过这种错误的行为。 ​ 因此，除非需要改变参数或对象，否则应该将其声明为const。 ​ 可以将成员函数声明为const，这将能改动对象和不可以改动对象的函数区分开来。并且，将成员函数声明为const有利于提高c++程序效率（通过pass by reference-to-const的方式传递对象）。两个只有常量性不同的成员函数（即一个为const成员函数，另一个不是）可以被重载。具体调用哪个函数取决于处理的对象是否为const。 2. 编译器强制实行“bitwise constness”，但编程时应该更多采用“logical constness”。​ “bitwise constness”指的是const成员函数不改变任何一个non-static的成员变量。但是一些成员函数不具备const性质却不会引起编译器错误。例如： 若指向非常量的常量指针，只有指针属于对象，则改变该指针所指向的对象不会引起编译器错误（常量指针只确保指针指向同一个对象，不保证指向的对象的内容不改变）。例如： 1234567class CTextBlock {public: char&amp; operator[] (std::size_t position) const { return pText[position]; }private: char* pText;} 这样一个const成员函数，它的返回值实际上可以被改变。这就导致了编译器无法提示的错误。 ​ “logical constness”指的是const成员函数可以修改其对象内的某些内容，但是客户端无法侦察到（读了好多遍没读懂，应该是这个意思吧）。 ​ （这里有个例子，但我没搞明白为什么这个成员函数需要修改对象但是却声明为const，然后再通过mutable来消除const的约束） 3. 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。​ 当const和non-const版本成员函数有着实质等价的实现时，令non-const版本调用const版本是个安全的做法，即使在这个过程中需要转型。因为const成员函数相当于保证了绝不改变对象，但是non-const成员函数并没有保证。因此令non-const版本调用const版本成员函数不会带来风险，但是反之则可能会使const成员函数改变对象，造成错误。 ​ 例如： 123456789101112131415161718class TextBlock {public: const char&amp; operator[](std::size_t position) const { //边界检测 //日志数据访问 //检验数据完整性 return text[position]; } char&amp; operator[](std::size_t position) { return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt;(*this) [position] ); }} ​ 添加const的转型为安全转型，因此使用static_cast，移除const是通过const_cast完成。 04：确定对象被使用前已经先被初始化1. 为内置型对象进行手工初始化，因为C++不保证初始化它们。​ 读取未初始化的值会导致不确定的行为。如果使用C part of C++且初始化可能带来运行成本时，就无法保证初始化。 ​ 对于内置类型，手工完成初始化；对于其他类型，在构造函数内保证将对象的每一个成员初始化。 1int x = 0; //内置类型初始化 2. 构造函数最好使用成员初始列，而不要在构造函数内使用赋值操作。初始列列出的成员变量，其排列顺序应该和它们在class中的声明次序相同。​ 赋值和初始化操作容易混淆。例如： 123456789class ABEntry {public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;}; 赋值操作： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) { theName = name; theAddress = address; thePhones = phones; numTimesConsulted = 0;} 成员初始列： 123456ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) :theName(name), theAddress(address); thePhones(phones); numTimesConsulted(0){ } ​ 两个构造函数的结果相同，但是成员初始列的效率较高。赋值操作首先调用默认构造函数为theName、theAddress和thePhones设初值，然后再赋予新值。而成员初始列是以name、address和phones为初值对theName、theAddress和thePhones调用拷贝构造函数。因此后者较为高效。 ​ 并且，成员初始列也能够调用默认构造函数，只需要不指定初始化实参即可。例如： 123456ABEntry::ABEntry() :theName(), theAddress(); thePhones(); numTimesConsulted(0) // 这里不知道为什么不调用默认初始化函数{ } ​ 如果成员变量是const或者引用类型，则一定需要初值，而不能被赋值。 ​ 如果class内有多个构造函数，可以将一些“赋值表现和初始化一样好”的成员变量不使用成员初始列，而是改用赋值操作。并且可以将赋值操作移到某个函数（通常private）来供所有构造函数调用。 3. 为避免“跨编译单元的初始化次序”问题，使用local static对象替换non-local static对象。​ C++有固定的“成员初始化”次序：基类早于派生类被初始化，成员变量以声明的次序初始化。因此，成员初始列最好以成员变量的声明次序为次序。但是对于不同编译单元的“non-local static”对象，仍然可能出现初始化次序的问题。 ​ 编译单元指的是产出单一目标文件的源码，通常是单一源码文件加上包含的头文件。static对象的生命周期是从构造出来到程序结束。函数内的static对象称为local static对象，其他称为non-local static对象。因此，可能遇到的问题是：某个编译单元对象的初始化用到了另一个编译单元的non-local static对象，但是不能保证该non-local static对象已经被初始化，因此可能结果出错。例如： 123456class FileSystem {public: std::size_t numDisks() const; ...};extern FileSystem tfs; 12345678910class Directory {public: Directory( params ); ...};Directory::Directory( params ) { std::size_t disks = tfs.numDisks(); ...}Directory tempDir( params ); ​ 如上，想要程序正确运行就需要确保tfs在tempDir之前初始化，但是C++对这里的次序并没有明确定义，也就是无法保证。 ​ 解决方式是使用单例模式的一个常见实现方法：将non-local static对象放在函数内实现，函数再返回一个引用对象指向它所含的对象。因为C++保证函数内的local static对象会在“函数调用期间”“首次遇到该对象的定义式”的时候被初始化，因此可以保证通过函数调用获取的对象的引用一定完成了初始化。并且，如果不调用这个函数，那么构造函数和析构函数的成本也不需要了，相比于local static对象可以节省开销。用例如下： 1234567891011121314class FileSystem { ... };FileSystem&amp; tfs() { static FileSystem fs; return fs;}class Directory { ... };Directory::Directory( params ) { std::size_t disks = tfs().numDisks(); // 调用tfs对象改为调用tfs()函数 ...}Directory&amp; tempDir() { static Directory td; return td;} ​ 但是这种含有static对象的函数在多线程系统中存在不确定性：任何一种non-const static对象（不管local还是non-local）在多线程环境下“等待某件事发生”都会存在麻烦。处理这种麻烦的方式之一是：在程序的单线程启动阶段手工调用所有这种返回引用对象的函数，这样就可以消除初始化有关的“竞速形势”（race conditions）。 05：C++默默编写并调用的函数编译器可以为class自动创建默认构造函数、拷贝构造函数、拷贝赋值函数和析构函数。 所有构造的这些函数都是public且inline的。 只有当这些函数被调用的时候才会被编译器创建出来。 除非class的基类自身声明了virtual析构函数，否则编译器产生的析构函数是non-virtual类型。 只要自己声明了一个构造函数，那么编译器就不会自动创建默认构造函数。 编译器创建的拷贝构造函数和拷贝赋值函数只是单纯将来源对象的每一个non-static成员变量拷贝到目标对象。例如 12345678910template&lt;typename T&gt;class NamedObject {public: NamedObject(const char* name, const T&amp; value); NamedObject(const std::string&amp; name, const T&amp; value); ...private: std::string nameValue; T objectValue;}; 12NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2);NamedObject&lt;int&gt; no2(no1); // 调用拷贝构造函数 ​ no2是通过拷贝构造函数初始化的：no2.nameValue以no1.nameValue调用string的拷贝构造函数，no2.objectValue这里的类型为内置类型int，因此通过“拷贝no1.objectValue内的每一个bit”来完成初始化。 如果编译器自动创建的拷贝构造函数和拷贝赋值函数不合法，那么就不会自动创建。例如： 123456789template&lt;typename T&gt;class NamedObject {public: NamedObject(std::string&amp; name, const T&amp; value); ...private: std::string&amp; nameValue; // 修改为指向string的引用 const T objectValue; // 修改为const类型}; 12345std::string newDog(&quot;Persephone&quot;);std::string oldDog(&quot;Satch&quot;);NamedObject&lt;int&gt; p(newDog, 2);NamedObject&lt;int&gt; s(oldDog, 36);p = s; ​ 如果自动创建了拷贝赋值函数，那么p.nameValue就改为s.nameValue，也就是引用的指向被改变了，但是这是不合法的。因此C++不会为NamedObject自动创建拷贝赋值函数。对于含有const成员的class，编译器也不会自动创建。此外，对于将拷贝赋值函数声明为private的基类，其派生类将不会被自动创建拷贝赋值函数。 06：若不想使用编译器自动生成的函数，则该明确拒绝​","link":"/2023/02/01/Effective%20C++%E7%AC%94%E8%AE%B0/"},{"title":"Effective Modern C++笔记","text":"零. 绪论 左值和右值 概念上，右值对应的是函数返回的临时对象，左值对应的是可指涉的对象（通过名字、指针或左值引用） 甄别方式：能取得地址的为左值。 右值引用类型的形参，该形参本身也是左值。 任何形参都是左值 若某对象是依据同一类型的另一对象初始化出来的，则该新对象称为原对象的一个副本。右值的副本通常由移动构造函数创建，左值的副本通常由复制构造函数创建。 函数对象 指某个对象，其类型支持operator()成员函数。 lambda表达式 创建的函数对象称为闭包。 定义和声明 定义可以当声明用。 函数的形参类型和返回值类型视为函数签名，而函数名字和形参名字不属于函数签名。 一. 类型推导01. 理解模板类型推导​ 在编译期，编译器会通过expr推导两个类型：T的类型和ParamType的类型。这两个类型完全往往不一样，因为ParamType通常包括一些修饰词。 123456// 函数模板template&lt;typename T&gt;void f(ParamType param);// 函数调用f(expr); ​ T的类型的推导结果需要分三种情况讨论： ParamType具有指针或者引用类型，但不是万能引用。 ParamType是一个万能引用。 ParamType既不是指针也不是引用。 - 在模板类型推导过程中，具有引用类型的实参会被当作非引用类型来处理，即其引用性会被忽略。 ​ ParamType具有指针或者引用类型，但不是万能引用时，推导过程如下： 若expr有引用类型，则忽略引用。 对expr和ParamType的类型进行模式匹配，得到T的类型。 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为int&amp;f(cx); // T类型为const int，param类型为const int&amp;f(rx); // T类型为const int，param类型为const int&amp; ​ 向T&amp;类型模板传入const对象是安全的，因为常量性会称为T的类型的一部分。 ​ 若是传给右值引用形参，则推导过程与左值引用相同。 ​ 若把形参类型加上const，则结果如下： 12345678910111213// 函数模板template&lt;typename T&gt;void f(const T&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T类型为int，param类型为const int&amp;f(cx); // T类型为int，param类型为const int&amp;f(rx); // T类型为int，param类型为const int&amp; ​ 若param为指针，则推导过程也相同： 1234567891011// 函数模板template&lt;typename T&gt;void f(T* param);// 声明变量int x = 27;const int *px = &amp;x;// 函数调用f(&amp;x); // T类型为int，param类型为int*f(px); // T类型为const int，param类型为const int* - 对万能引用进行推导时，左值实参会进行特殊处理。 ​ ParamType是一个万能引用时，类型推导过程如下： 若expr是左值，则T和ParamType都被推导为左值引用。 若expr是右值，则推导过程与之前相同。 ​ 在expr为左值的情况比较特殊：首先，这是唯一一种T被推导为引用类型的情况；其次，声明的时候采用右值引用语法，但类型推导却是左值引用。 ​ 例如： 1234567891011121314// 函数模板template&lt;typename T&gt;void f(T&amp;&amp; param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // x为左值，T类型为int&amp;，param类型为int&amp;f(cx); // cx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(rx); // rx为左值，T类型为cosnt int&amp;，param类型为cosnt int&amp;f(27); // 27为右值，T类型为int，param类型为int&amp;&amp; - 对按值传递的形参进行推导时，若实参类型中带有const或volatile修饰，则忽略该修饰词。 ​ ParamType既不是指针也不是引用时，其实就是按值传递，无论传入什么，param都会是一个副本。推导过程如下： 若expr有引用类型，则忽略引用； 若expr是const对象，则忽略const； 若expr是volatile对象，则忽略volatile。 ​ 例如： 12345678910111213// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量int x = 27;const int cx = x;const int&amp; rx = x;// 函数调用f(x); // T和param类型为intf(cx); // T和param类型为intf(rx); // T和param类型为int ​ 虽然cs和rx有const属性，但是param是完全独立于它们的存在，是它们的副本，因此可以忽略const属性。 ​ 但是const属性只有在按值传递时被忽略，若形参为引用或者指针则const会被保留。但是要额外考虑expr时指向const对象的const指针这种情况： 123456789// 函数模板template&lt;typename T&gt;void f(T param);// 声明变量const char* const ptr = &quot;pointer&quot;;// 函数调用f(ptr); // T和param类型为const char* ​ 也就是说，ptr自身的const属性会被忽略，但是指向对象的const属性会被保留。 - 在模板类型推导过程中，数组或函数类型的实参会退化成对应的指针，除非被用来初始化引用。 ​ 某些情况下，数组会退化成指向其首元素的指针。例如： 12const char name[] = &quot;J. P. Briggs&quot;; // name类型为const char[13]const char *ptrToName = name; // 数组退化成指针 ​ 当数组传递给按值形参的模板时，形参T的类型会被推导为指针类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T param);// 函数调用f(name); // T类型为const char* ​ 但是如果按引用方式传递参数，形参T类型就会被推导为实际的数组类型。例如： 123456// 函数模板template&lt;typename T&gt;void f(T&amp; param);// 函数调用f(name); // T类型为const char[13]，param类型为const char (&amp;)[13] ​ 因此可以用这个能力创建出模板推导数组含有的元素个数： 123456789// 该数组形参未起名字，因为不需要template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;}// 调用函数构建相同大小的数组int keyVals[] = { 1, 2, 3, 4, 5, 6, 7 };std::array&lt;int, arraySize(keyVals)&gt; mappedVals; ​ 除了数组外，函数类型也会退化成函数指针。推导过程与数组相同。例如： 12345678910void someFunc(int, double);template&lt;typename T&gt;void f1(T param);template&lt;typename T&gt;void f2(T&amp; param);f1(someFunc); // param的类型为函数指针，具体为void (*)(int, double)f2(someFunc); // param的类型为函数引用，具体为void (&amp;)(int, double) 02. 理解auto类型推导- 一般情况下，auto类型推导和模板推导是一样的。但是auto类型推导会假定使用大括号的初始化表达式代表std::initializer_list，模板类型推导不会。 ​ 一般情况下，auto类型推导和模板推导是完全相同的。例如： 1234567auto x = 27; // x类型为intconst auto cx = x; // cx类型为const intconst auto&amp; rx = x; // rx类型为const int&amp;auto&amp;&amp; uref1 = x; // x类型为int，且是左值，则uref1类型为int&amp;auto&amp;&amp; uref2 = cx; // cx类型为const int，且是左值，则uref2类型为const int&amp;auto&amp;&amp; uref3 = 27; // 27类型为int，且是右值，则uref3类型为int&amp;&amp; ​ 但是以下这种情况不同： 12345678910111213141516171819// C++98中的初始化方式int x1 = 27;int x2(x1);// C++11中新增了用大括号初始化的方法，结果与上面相同。int x3 = { 27 };int x4{ 27 };// 通过auto推导类型auto x1 = 27; // 类型为intauto x2(x1); // 类型为intauto x3 = { 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27auto x4{ 27 }; // 类型为std::initializer_list&lt;int&gt;，值为27// 通过模板推导类型auto x = { 11, 23, 9 }; // auto推导类型为std::initializer_list&lt;int&gt;template&lt;typename T&gt;void f(T param);f({ 11, 23, 9 }); // 模板推导类型错误，代码不能通过编译 ​ 对于大括号初始化的表达式，auto类型会推导为std::initializer_list&lt;T&gt;类型（T的类型推导为模板推导，也就是需要用到两种类型推导），而模板推导类型则会失败，编译错误。 - 在函数返回值或者lambda表达式形参中使用auto，意思是使用模板推导而不是auto推导。 ​ C++14允许使用auto说明函数返回值或者lambda表达式形参的类型需要推导，但是这里是用模板推导类型的。例如： 123456789// 函数返回值为autoauto createInitList() { return { 1, 2, 3 }; // 错误，无法完成类型推导}// lambda表达式形参中使用autostd::vector&lt;int&gt; v;auto resetV = [&amp;v](const auto&amp; newValue) { v = newValue; };resetV({ 1, 2, 3 }); // 错误，无法完成类型推导 03. 理解decltype- 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。 ​ C++11中，decltype的主要用途大概在于，声明返回值类型依赖于参数类型的函数模板。例如C++11中利用返回值类型尾序语法（trailing return type syntax）声明返回值的类型，这样的好处是，在指定返回值类型时可以使用函数形参。例如： 12345678910111213141516// C++11中使用返回值类型尾序语法（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt; decltype(c[i]) { authenticateUser(); return c[i];}// C++14中可以直接使用auto推导类型（有错误，不能正确运行）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 一般来说，含有类型T的对象的容器，其operator[]会返回T&amp;。std::deque是这样，std::vector几乎总是这样，只有std::vector&lt;bool&gt;不返回bool&amp;，而是返回全新的对象。因此，对于第二段代码，operator[]会返回T&amp;，但是auto类型推导的过程中会忽略expr的引用性，这样返回值类型就变成了T。作为函数的返回值，这里的T为右值，因此无法被赋值，因此有错误。 - C++14支持的decltype(auto)，这样的类型推导使用decltype的规则 ​ 想要authAndAccess返回左值，则可以对返回值使用decltype类型推导。可以通过decltype(auto)来使用decltype的规则进行类型推导。因此可以修改为： 1234567// C++14中可以直接使用auto推导类型（能运行，但是待改进）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} ​ 但是这样仍然有改进空间。这是因为，容器的传递方式是对非常量的左值引用，但是右值是无法绑定到左值引用的（除非是对常量的左值引用），这样就不能往函数中传递右值容器。可以通过重载维护两个函数，分别声明左值引用形参和右值引用形参。然而，也可以通过万能引用，这种引用形参既能够绑定到左值也能够绑定到右值。 ​ 使用万能引用的话需要应用std::forward（*不知道是什么）。这样可以得到最终修改的版本： 12345678910111213141516// C++14中可以直接使用auto推导类型（最终版）template&lt;typename Conrainer, typename Index&gt;decltype(auto) authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];}// C++11中使用返回值类型尾序语法（最终版）template&lt;typename Conrainer, typename Index&gt;auto authAndAccess(Container&amp;&amp; c, Index i) -&gt; decltype(std::forward&lt;Container&gt;(c)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} - 对于类型为T的表达式，除非该表达式仅有一个名字，否则decltype得出类型为T&amp; ​ 绝大多数情况下，decltype得出变量或表达式的类型而不做任何修改。但是对于一个不仅仅是T的名字的表达式，decltype得出类型为T&amp;。例如： 12345678910111213// decltype(x)为int，f1返回intdecltype(auto) f1(){ int x = 0; return x;}// decltype((x))返回int&amp;，f2返回int&amp;decltype(auto) f2(){ int x = 0; return (x);} ​ 这不仅仅是返回类型的错误，f2实际上返回了局部变量的引用，这是非常危险的行为。 04. 掌握查看类型推导结果的方法- 利用IDE编辑器、编译器错误信息和Boost.TypeIndex库常常能查看到推导得到的类型。 - 有些工具可能不准确，因此理解C++类型推导规则是必要的。 ​ 采用那种工具查看类型推导结果取决于在开发过程中的哪个阶段需要该信息： 代码撰写阶段：IDE编辑器 ​ 鼠标悬停时可以查看。原理是让C++编译器在IDE内执行一轮，因此代码需要处在可编译的状态。例如： 123const int theAnswer = 42;auto x = theAnswer; // x类型为intauto y = &amp;theAnswer; // y类型为const int* 编译阶段：编译器诊断信息 ​ 可以通过该类型导致某些编译错误，而报告错误的消息几乎肯定会提及导致该错误的类型。例如： 123// 声明类模板，但是不定义它。template&lt;typename T&gt;class TD; ​ 这样就可以通过TD查看x和y的类型： 12TD&lt;decltype(x)&gt; xType;TD&lt;decltype(y)&gt; yType; ​ 这样编译器会报错，错误信息中会指出x和y的类型。 运行阶段：运行时输出 ​ 可以通过typeid和std::type_info::name查看类型信息，例如： 12std::cout &lt;&lt; typeid(x).name() &lt;&lt; '\\n'; // GNU和Clang：x类型为i，即intstd::cout &lt;&lt; typeid(y).name() &lt;&lt; '\\n'; // GNU和Clang：y类型为PKi，即int const*(PK: pointer to konst const涉及到常量的指针) ​ 但是这样有可能会输出不准确的信息，例如： 12345678template&lt;typename T&gt;void f(const T&amp; param);std::vector&lt;Widget&gt; createVec();if(!vw.empty()) { f(&amp;vw[0]);} ​ 通过typeid和std::type_info::name查看T和param的类型： 1234567template&lt;typename T&gt;void f(const T&amp; param) { using std::cout; cout &lt;&lt; &quot;T = &quot; &lt;&lt; typeid(T).name() &lt;&lt; '\\n'; // T = class Widget const * cout &lt;&lt; &quot;param = &quot; &lt;&lt; typeid(param).name() &lt;&lt; '\\n'; // param = class Widget const *} ​ 输出结果如上，但是结果是错误的。param的类型为const Widget * const &amp;，但是被报告成const Widget *。这是因为通过这种方式推导得到类型和向函数模板传参是一样的，按值传参时会忽略掉const、volatile和&amp;这些修饰词。 ​ 可以通过Boost的TypeIndex库查看，虽然这不是标准C++的一部分（IDE和TD也不是）。使用方法例如： 12345678910111213#include &lt;boost/type_index.hpp&gt;template&lt;typename T&gt;void f(const T&amp; param){ using std::cout; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;T = &quot; &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; '\\n'; // T = Widget const* cout &lt;&lt; &quot;param = &quot; &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; '\\n'; // param = Widget const* const&amp;} 二、auto05. 优先选用auto，而不是显式类型声明- auto变量必须初始化。使用auto基本可以避免因为类型不匹配而导致的兼容性和效率问题，还可以简化重构流程，并且代码量更少。 - auto类型也存在着一些问题（如02和06） ​ auto类型可以节省代码量，不用费大心思思考变量类型，例如： 12345678910template&lt;typename It&gt;void dwim(It b, It e) { while(b != e) { auto currValue = *b; // 等价于 // typename std::iterator_traits&lt;It&gt;::value_type currValue = *b; ... }} ​ 另外，对于std::function，使用auto类型也有非常大的优势。例如： 1234auto derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ std::function是C++11标准库中的一个模板，把函数指针的思想加以推广，可以指向任何可以调用的对象。比如，std::function可以指向lambda表达式。上述用例就可以表示为： 12345std::function&lt;bool(const std::unique_ptr&lt;Widget&gt;&amp;, const std::unique_ptr&lt;Widget&gt;&amp;)&gt; derefUPLess = [](const std::unique_ptr&lt;Widget&gt;&amp; p1, const std::unique_ptr&lt;Widget&gt;&amp; p2) { return *p1 &lt; *p2; }; ​ 但是跟auto类型声明相比： auto声明的变量所要求的内存量与lambda表达式相同，而std::function声明的变量是其实例，所以占有固定内存。因此，std::function一般占用更多内存。 编译器一般会产生间接函数调用，通过std::function调用lambda表达式几乎必然会比auto声明更慢。 另外，auto声明还可以避免一些不明确类型所产生的错误。例如： 12std::vector&lt;int&gt; v;unsigned sz = v.size(); // v.size()为std::vector&lt;int&gt;::size_type，向unsigned隐式转换。 ​ std::vector&lt;int&gt;::size_type是无符号整型。在32位Windows上，unsigned和std::vector&lt;int&gt;::size_type尺寸相同，但是64位Windows上，unsigned是32位而std::vector&lt;int&gt;::size_type是64位，因此可能出错。 ​ 再比如： 123std::unordered_map&lt;std::string, int&gt; m;for(const std::pair&lt;std::string, int&gt;&amp; p : m){ ... } // 代码有问题for(const auto&amp; p : m){ ... } // 用auto声明可以避免这个问题 ​ 这里std::unordered_map的键值部分是const，也就是里面的键值对类型实际上为std::pair&lt;const std::string, int&gt;。上述代码实际上会对m中每一个对象进行复制操作，将p绑定到产生的临时对象上。 并且，auto可以简化重构流程。比如函数本来声明的返回类型为int，后续改为long时，使用auto声明返回值只需要重新编译便可以直接更新。 06. 当auto推导的类型不符合要求时，使用显式类型的初始化方法- “隐形”的代理类型可能会导致auto推导出“错误的”类型 ​ 举例来说： 123456789std::vector&lt;boo&gt; features(const Widget&amp; w);Widget w;bool highPriority = feature(w)[5];processWidget(w, highPriority);// 若使用auto类型声明auto highPriority = feature(w)[5];processWidget(w, highPriority); // 未定义的行为 ​ 实际上，highPriority的返回值不是bool类型。对于其他类型，std::vector::operator[]都返回容器内一个元素的引用，但是std::vector&lt;bool&gt;返回的是std::vector&lt;bool&gt;::reference对象。这是一个代理类的实例。代理类指的是为了模拟或者增广其他类型的类，比如智能指针也是代理类。有些代理类比较明细那，但是有些是“隐形代理”，难以察觉。这种类的对象往往生命周期只有单个语句，因此容易出现创建这种类型容易出现未定义的行为。 ​ 在上述例子中，auto实际推断的类型是std::vector&lt;bool&gt;::reference，是一个临时对象，在语句结束时就被析构，因此之后会产生未定义的行为。 - 带显式类型的初始化方法可以强制推导出想要的类型 ​ 可以通过带显式类型的初始化方法来避免上述问题。使用方法如下： 1auto highPriority = static_cast&lt;bool&gt;(feature(w)[5]); // std::vector&lt;bool&gt;::reference被强制转换为bool类型 ​ 除了能够避免隐形代理类产生的问题，还可以用来强调变量进行了类型转换。例如： 1234567double calcEpsilon();// float的精度足够，并且在意变量的存储空间大小的情况下，可以用float类型存储该返回值float ep = calcEpsilon();// 与上面意思相同，但是强调了“降低返回值精度”auto ep = static_cast&lt;float&gt;(calcEpsilon()); 三、转向现代C++07. 创建对象时注意区分()和{}To be continued","link":"/2023/04/04/Effective%20Modern%20C++%E7%AC%94%E8%AE%B0/"},{"title":"GitHub下载速度太慢的解决方式","text":"一、修改host文件1.访问https://www.ipaddress.com/。 2.查询github.com和github.global.ssl.fastly.net的对应ip地址。 3.进入目录C:\\Windows\\System32\\drivers\\etc，以管理员权限打开hosts文件。 4.将查询到的ip地址加入hosts文件。例如： 12140.82.112.4 github.com199.232.69.194 github.global.ssl.fastly.net 5.在powershell打开执行命令，刷新DNS 缓存。 1ipconfig /flushdns 二、从gitee下载1.点击从GitHub\\GitLab导入仓库。 2.输入Git仓库URL。 3.直接执行git clone xxxx(gitee仓库的地址)。","link":"/2020/12/13/GitHub%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"},{"title":"IDEA已有maven插件但mvn出错","text":"mvn命令找不到是因为maven环境变量未配置，因此需配置环境变量。 1.找到IDEA下的maven位置例如：D:\\IntelliJ IDEA 2019.3.3\\plugins\\maven\\lib\\maven3 2.配置环境变量（1）右键此电脑的属性。 （2）点击高级系统设置。 （3）点击环境变量。 （4）点击新建。 （5）输入变量名MAVEN_HOME和变量值（IDEA下的maven位置）。 （6）点击编辑。 （7）点击新建，新增%MAVEN_HOME%\\bin项。 （8）点击确定，完成环境变量设置。","link":"/2020/12/13/IDEA%E5%B7%B2%E6%9C%89maven%E6%8F%92%E4%BB%B6%E4%BD%86mvn%E5%87%BA%E9%94%99/"},{"title":"Icarus主题美化","text":"本文面向前端小白！仅记录自己修改的部分！ 个人主题配置​ 主要就是修改_config.icarus.yml文件，具体主题配置可以参考Icarus用户指南。 网页显示的图标 123# _config.icarus.ymlhead: favicon: /img/pikachu.svg Logo修改 12# _config.icarus.ymllogo: /img/logo_pikachu.svg 网页显示的标题 12# _config.ymltitle: Hyeee's Home 网页显示的语言 可以在node_modules\\hexo-theme-icarus\\languages目录下查看可用的语言 PS：如果找不到相应的语言，会自动选择德语（经验之谈） 12# _config.ymllanguage: zh-CN 个人信息修改 1234567widgets: - author: Hyeee author_title: '|ू･ω･` )' location: Hangzhou, China avatar: /img/avatar_pikachu.jpg follow_link: https://github.com/HeeeeH 其他一些七七八八的，比如cookie、赞赏、评论什么的不太会就先全部注释掉啦 加入背景图片 将背景图片放到node_modules\\hexo-theme-icarus\\source\\img目录下 修改node_modules\\hexo-theme-icarus\\include\\style\\base.styl文件，在body样式下加入以下几行 12345body ... ... background: url(../img/background_op.png) no-repeat background-attachment: fixed background-size: cover background的属性说明 url：图片路径（这里填的是相对路径） attachment ：图片是否滚动（fixed为 不滚动，scoll 为滚动） size：图片大小（原始尺寸为 auto ，覆盖为 cover ，拉伸为 contain 等） PS：背景图片的不透明度有点难调，所以我选择PS手动调节(。-`ω´-) 标签颜色更改​ 主题的颜色定义在node_modules\\hexo-theme-icarus\\include\\style\\base.styl中，可以将$primary直接修改为想要的颜色。例如： 1$primary ?= $yellow ​ 但是这样的修改不全面，还有很多地方的颜色是硬编码。这里记录一下我修改的地方： base.styl: $navbar-item-active-color $menu-item-active-color $menu-item-active-background-color article.styl article &amp;.media color article &amp;.media a &amp;:hover color helper.styl .link-muted &amp;:hover color navbar.styl .navbar-main .navbar-item &amp;.is-active color .navbar-main .navbar-item &amp;.hover color PS：找不到对应元素的标签或class怎么办？ 可以通过F12，选中页面元素查看对应元素的标签以及class，然后直接修改在自定义的custom.styl中。 // 例如修改导航栏悬浮时的颜色 a.navbar-item:hover, .navbar-link:hover, a.navbar-item.is-active, .navbar-link.is-active { background-color: #fafafa; color: #ff9600; } 12345- 再在node_modules\\hexo-theme-icarus\\source\\css\\style.styl文件中引入custom.styl。 - ```stylus @import './custom' TODO 夜间模式 评论 参考文章icarus用户指南-主题配置 活用 Bulma 美化 Icarus 文章 icarus主题自定义 Hexo-icarus主题黑夜模式以及背景","link":"/2024/02/02/Icarus%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"},{"title":"JavaScript笔记","text":"基本语法注意事项 === 比较运算符 NaN NaN === NaN; // false // true```（唯一判断方法）1234567891011- null 和 undefined- 变量类型不固定，可以赋值为不同类型```var a = 123; // a的值是整数123``````a = 'ABC'; // a变为字符串```&lt;!--more--&gt;### 字符串- 用' '或&quot; &quot;括起来- 多行字符串 这是一个 多行 字符串; 123456- 字符串的连接```javascriptvar name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';//方法1var message = '你好, ${name}, 你今年${age}岁了!';//方法2 字符串的长度12var s = 'Hello, world!';s.length; // 13 字符串的索引1234var s = 'Hello, world!';s[0]; // 'H's[0] = 'X';//对字符串的某个索引赋值，没有任何效果：alert(s); // s仍然为'Hello, world!', 字符串不可变！！！ 改变字符串大小写123var s = 'Hello, world!';s.toUpperCase(); // 返回'HELLO, WORLD's.toLowerCase(); // 返回'hello, world!' 搜索指定字符串出现的位置123var s = 'Hello, world!';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 返回指定索引区间的子串123var s = 'Hello, world!';s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' 数组 创建数组12var arr = [1, 2, 3.14, 'Hello', null, true];//数组可以包括任意数据类型var arr = new Array(1, 2, 3); // 方法2,数组为[1, 2, 3] 多维数组 var arr = [[1, 2, 3], [400, 500, 600], '-']; 数组的索引123456var arr = ['A', 'B', 'C'];arr[0]; //返回索引为0的元素，即Aarr[1] = 99;arr; //arr现在变为['A', 99, 'C']arr[5] = 'x';arr; //arr变为['A', 99, 'C', undefined, 'x'] 取得Array的长度(改变长度）123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 搜索一个指定的元素的位置12var arr = [10, 20, '30', 'xyz', 'D', 'E', 'F'];arr.indexOf(10); // 元素10的索引为0,返回0 截取元素123456var arr = [10, 20, '30', 'xyz', 'D', 'E', 'F'];arr.slice(0, 3); // 返回 [10, 20, '30']arr.slice(3); // 从索引3开始到结束，返回 ['xyz', 'D', 'E', 'F']var aCopy = arr.slice();//从头到尾截取所有元素,相当于复制aCopy; //[10, 20, '30', 'xyz', 'D', 'E', 'F']aCopy === arr; // false 添加/删除元素123456789101112131415var arr = ['C', 'D', 'E', 'F'];arr.push('G', 'H'); // 向尾部添加元素，返回新的长度: 6arr; // ['C', 'D', 'E', 'F', 'G', 'H']arr.pop(); // 删除末尾元素，返回'H'arr; // ['C', 'D', 'E', 'F', 'G']arr.unshift('A', 'B'); // 向头部添加元素，返回新的长度: 7arr; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']arr.shift(); // 删除开头元素，返回'A'（若arr为[],则返回undefined）arr; // ['B', 'C', 'D', 'E', 'F', 'G']arr.splice(1, 3, 'H', 'I'); // 从索引1开始，删除3个元素，再添加2个元素，返回删除的元素 ['C', 'D', 'E']arr;//['B', 'F', 'G', 'H', 'I']arr.splice(2, 2); //只删除,不添加,返回['G', 'H']arr; // ['B', 'F', 'I']arr.splice(2, 0, 'J', 'K'); //只添加,不删除,返回[]arr; // ['B', 'F', 'I', 'J', 'K'] 排序(按照默认顺序排序)123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] 反转字符串123var arr = ['A', 'B', 'C'];arr.reverse(); arr; // ['C', 'B', 'A'] 连接字符串1234567var arr = ['C', 'B', 'A'];var added = arr.concat([1, 2, 3]);added; // ['C', 'B', 'A', 1, 2, 3]arr; // 原字符串并未改变，仍为['C', 'B', 'A']arr.concat(1, 2, [3, 4]); // concat会自动把Array拆开，返回['C', 'B', 'A', 1, 2, 3, 4]//将每个元素用指定的字符串连接起来，返回连接后的字符串added.join('-'); // 'C-B-A-1-2-3-4' 对象 是由键-值组成的无序集合12345678var xiaoming = { name: '小明', birth: 1990, height: 1.70, weight: 65, score: null 'middle-school': 'No.1 Middle School'}; 访问元素1234xiaoming.name;// '小明'xiaoming['name']; // '小明'xiaoming['middle-school']; // 'No.1 Middle School'xiaoming.age; // undefined 添加或删除属性1234567891011xiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错xiaoming.name;// '小明'xiaoming['name']; // '小明'xiaoming['middle-school']; // 'No.1 Middle School'xiaoming.age; // undefined","link":"/2020/04/19/JavaScript%E7%AC%94%E8%AE%B0/"},{"title":"Java刷题基础语法","text":"一、Java集合概览​ Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。 ​ Java 集合框架如下图所示： List：存储的元素是有序的、可重复的。 ArrayList：Object[] 数组。 Vector：线程安全，使用 synchronized 进行同步，了解即可。 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。 Set：存储的元素不可重复的。 HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。 Queue：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。 PriorityQueue: Object[] 数组来实现小顶堆。 DelayQueue:PriorityQueue。 ArrayDeque: 可扩容动态双向数组。 Map：使用键值对（key-value）存储。key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 HashMap：JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 LinkedHashMap：LinkedHashMap 在 HashMap的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。 二、常见数据结构及用法1. 数组1）赋值 初始化时直接赋值 1int[] intArray = new int[]{1, 2, 3, 4}; 通过 Java Util 类的 Arrays.fill(arrayname,value) 12345int[] intArray = new int[10];// Arrays.fill(arrayname, value) Arrays.fill(intArray, 100);// Arrays.fill(arrayname, starting index, ending index, value) Arrays.fill(intArray, 3, 6, 50); 注：Arrays.fill只能给一维数组赋初值，二维数组需要循环赋值。如下： 1234int[][] intArray = new int[10][10];for(int i = 0; i &lt; intArray.length; ++i) { Arrays.fill(intArray[i], 100);} 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intArray.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intArray) { System.out.println(a);} 3）数组复制 直接赋值（没有拷贝） intArray2和intArray1是指向同一个数组对象的。 12int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = intArray1; System.arraycopy（浅拷贝） 方法：arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = new int[5];System.arraycopy(intArray1, 0, intArray2, 0, intArray1.length); Arrays.copyOf和Arrays.copyOfRange（浅拷贝） 方法：copyOf(T[] original, int newLength)和copyOfRange(T[] original, int from, int to) 如果newLength不合法，即小于0，那么抛出NegativeArraySizeException异常 如果newLength小于源数组长度，则复制指定长度的数组元素 如果newLength大于源数组长度，则新数组中超出源数组长度的元素则是默认值 返回了一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 123int[] intArray1 = new int[]{1, 2, 3, 4, 5};int[] intArray2 = Arrays.copyOf(intArray1, intArray1.length);int[] intArray3 = Arrays.copyOfRange(intArray1, 0, intArray1.length); 对象拷贝（Object.clone） clone()比较特殊，对于对象而言，它是深拷贝，但是对于数组而言，它是浅拷贝。拷贝数组时会返回一个新的数组对象，但是这两个数组里面的内容都是指向同一个引用的。 4）Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 能够给数组赋值、对数组排序、比较数组和查找数组元素。具体如下表： 方法 说明 int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。也可以调用**binarySearch(Object[], int fromIndex, int toIndex, Object key)**在指定位置查找给定值。 boolean equals(long[] a, long[] a2) 若两个数组以相同顺序包含相同的元素，则两个数组是相等的。适用于所有的其他基本数据类型。 void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。适用于所有的其他基本数据类型。 void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。适用于所有的其他基本数据类型。可以传入方法指定按照特定方法排序。例如，Collections.reverseOrder()进行反向排序；String.CASE_INSENSITIVE_ORDER进行忽略大小写排序。 String toString(Object[] a) 能将数组中的内容全部打印出来。适用于所有的其他基本数据类型。 举例如下： 12345678910111213int[] intArray = new int[5];// 调用Arrays.fill进行赋值Arrays.fill(intArray, 4);// 调用Arrays.sort进行排序Arrays.sort(intArray);// 调用Arrays.sort从指定位置进行排序Arrays.sort(intArray, 2, 4);// 调用Arrays.sort进行反向排序Arrays.sort(intArray, Collections.reverseOrder());// 调用Arrays.binarySearch查找指定元素System.out.println(Arrays.binarySearch(arr, 30));// 调用Arrays.toString打印数组元素System.out.print(Arrays.toString(intArray)); 5）数组与List之间相互转换- 对象数组转为基本数据类型数组 stream流执行转换 1int[] intArray = integerArray.stream().mapToInt(Integer::valueOf).toArray(); - 基本数据类型数组转为对象数组 stream流执行转换 1Integer[] integerArray = Arrays.stream(intArray).boxed().toArray(Integer[]::new); - 对象数组转为List 最常见方式，但不支持增删（会抛异常） 1List intList = Arrays.asList(intArray); 数组转为List后，支持增删改查的方式 1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(Arrays.asList(intArray)); 通过集合工具类Collections.addAll()方法（最高效） 12ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(intArray.length);Collections.addAll(intList, intArray); 使用stream中的collector 1List&lt;Integer&gt; intList = Arrays.stream(intArray).collect(Collectors.toList()); - List转为对象数组 toArray()方法，需要传入对应的对象数组构造函数并指定数组的长度 1Integer[] intArray = intList.toArray(new Integer[intList.size()]); stream流的toArray()方法，需要传入对应对象的构造方法的方法引用 1Integer[] intArray = intList.stream().toArray(Integer[]::new); - List转为基本数据类型数组 stream流执行转换 123456// 方法引用int[] intArray1 = intList.stream().mapToInt(Integer::intValue).toArray();// lambda表达式int[] intArray2 = intList.stream().mapToInt(i-&gt;i).toArray();// 先使用filter过滤int[] intArray3 = intList.stream().filter(integer -&gt; integer!=null).mapToInt(i-&gt;i).toArray(); - 基本数据类型数组转为List stream流执行转换 123List&lt;Integer&gt; intList1 = Arrays.stream(intArray).mapToObj(Integer::new).collect(Collectors.toList());// 采用boxed装箱List&lt;Integer&gt; intList2 = Arrays.stream(intArray).boxed().collect(Collectors.toList()); 利用CollectionUtils集合工具类进行转换 1List&lt;Integer&gt; intList = CollectionUtils.arrayToList(intArray); 2. 列表 List1）Collection通用方法： Collection 接口 方法 元素个数 size() 是否为空 isEmpty() 是否包含某元素 contains(Object o) 迭代器 iterator() 清空所有元素 clear() 转为数组 toArray() 增加元素 add(E e) 删除元素 remove(Object o) 2）遍历 for循环遍历 1234567for (int i = 0; i &lt; intList.length; ++i) { System.out.println(intArray[i]);}// for-each遍历，与for遍历等价for (int a: intList) { System.out.println(a);} for-each遍历 1intList.forEach(a -&gt; System.out.println(a)); 3）排序 使用List.sort排序。 可以使用lambda函数按照指定顺序排序。例如： 123List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();// 按照从大到小的顺序排序intList.sort((o1, o2) -&gt; o2 - o1); 使用Collections.sort排序。 同样可以使用lambda函数按照指定顺序排序。例如： 1234567891011List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();Collections.sort(intList);// 按照从大到小的顺序排序Collections.sort(intList, (o1, o2) -&gt; o2.compareTo(o1));// 这等价于Collections.sort(intList, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); }}); 4）Collections工具类 排序操作 123456void reverse(List list)//反转void shuffle(List list)//随机排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j)//交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 查找,替换操作 1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 3. 队列 Queue1）基础队列Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。 Queue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 2）优先队列 PriorityQueuePriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。方法与Queue相同。 PriorityQueue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() 利用Lambda表达式自定义比较函数。例如： 1PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((o1, o2)-&gt;o2-o1); 这等价于： 12345678PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;( new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); 注：Java中默认为小根堆，C++中默认为大根堆。 3）双端队列 DequeDeque 是双端队列，在队列的两端均可以插入或删除元素。 Deque 扩展了 Queue 的接口，增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类： Deque 接口 抛出异常 返回特殊值 插入队首 addFirst(E e) offerFirst(E e) 插入队尾 addLast(E e) offerLast(E e) 删除队首 removeFirst() pollFirst() 删除队尾 removeLast() pollLast() 查询队首元素 getFirst() peekFirst() 查询队尾元素 getLast() peekLast() 4. 栈 StackStack继承自Vector，与Vector一样使用synchronized关键字修饰来保证线程安全，但也因此效率低下。因此，在实际应用中多采用Deque来实现栈的功能。例如： 1Deque deque = new LinkedList&lt;Integer&gt;(); 另外，从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。ArrayDeque 也可以用于实现栈。使用如下： 1Deque deque = new ArrayDeque&lt;Integer&gt;(); 当作为栈使用时，可以采用如下方法： Deque 接口 抛出异常 返回特殊值 入栈 push(E e) 出栈 pop() poll() 查看栈顶 element() peek() 5. 字符串 String 方法说明 方法 指定索引处的 char 值 char charAt(int index) 字符串长度 int length() 判断字符串是否为空 boolean isEmpty() 返回字符串的副本，忽略前导空白和尾部空白。 String trim() 将String 中的所有字符都转换为小写 String toLowerCase() 将String 中的所有字符都转换为大写 [String toUpperCase() 比较两个字符串 int compareTo(String anotherString) 比较两个字符串是否相等 boolean equals(Object anObject) 连接字符串 String concat(String str) 将此字符串转换为一个新的字符数组 char[] toCharArray() 返回一个新的字符串，是此字符串的子字符串 String substring(int beginIndex) String substring(int beginIndex, int endIndex) 字符串是否有指定前缀/后缀 boolean startsWith(String prefix) boolean startsWith(String prefix, int toffset) boolean endsWith(String suffix) 指定字符第一次出现的索引 int indexOf(String str) int indexOf(String str, int fromIndex) 指定字符最后一次出现的索引 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) 替换字符串 String replace(char oldChar, char newChar) String replaceAll(String regex, String replacement) String replaceFirst(String regex, String replacement) 拆分字符串 String[] split(String regex) String[] split(String regex, int limit) 6. 字典 Map1）基本操作 方法说明 方法 map的长度 size() 插入元素 put(Object key, Object value) 获取元素 get(Object key) 移除元素 remove(Object key) 清空map clear() map是否为空 isEmpty() 是否包含指定key containsKey(Object key) 是否包含指定value containsValue(Object value) 2）排序1234567Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;((o1, o2)-&gt;o2-o1);// 这等价于Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { return o2.compareTo(o1); }}); 3）for循环遍历- keySet()遍历123456789for (String key : map.keySet()) { System.out.println(key + &quot; ：&quot; + map.get(key));}// 这等价于Iterator&lt;String&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) { String key = iterator.next(); System.out.println(key + &quot; ：&quot; + map.get(key));} - entrySet()遍历123456789for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());}// 这等价于Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) { Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + &quot; ：&quot; + entry.getValue());} - for-each遍历1map.forEach((k, v)-&gt;times.add(v)); 三、常用算法1. 通过stream()1）List取最值12intList.stream().max(Integer::compareTo).get();intList.stream().min(Integer::compareTo).get(); 2）List取平均值1intList.stream().mapToInt(Integer::intValue).average().orElse(0D); 3）List求和1integers.stream().reduce(Integer::sum).get(); 四、参考文档Java集合常见面试题总结 java中数组拷贝（深拷贝）的四种方法 Java map 详解 - 用法、遍历、排序、常用API等 Java8 stream平均值、最小数、最大数、求和","link":"/2023/05/01/Java%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"Lombok详解","text":"简介Lombok能通过注解的方式，在编译时自动为属性生成构造函数、getter/setter、equals、hashcode、toString等方法。奇妙之处在于源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁明了。 优缺点优点1）简化代码，提高效率 Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。 Lombok能通过注解的方式，在编译时自动为属性生成构造函数、getter/setter、equals、hashcode、toString等方法。奇妙之处在于源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁明了。 缺点1） 高侵入性，强迫队友 Lombok插件的使用，要求开发者一定要在IDE中安装对应的插件。不仅自己要安装，任何和你协同开发的人都要安装。如果有谁未安装插件的话，使用IDE打开一个基于Lombok的项目的话会提示找不到方法等错误，导致项目编译失败。更重要的是，如果我们定义的一个jar包中使用了Lombok，那么就要求所有依赖这个jar包的所有应用都必须安装插件，这种侵入性是很高的。 2）代码可调试性降低 Lombok确实可以帮忙减少很多代码，因为Lombok会帮忙自动生成很多代码。但是，这些代码是要在编译阶段才会生成的，所以在开发的过程中，其实很多代码其实是缺失的。这就给代码调试带来一定的问题，我们想要知道某个类中的某个属性的getter方法都被哪些类引用的话，就没那么简单了。 3） 影响版本升级 Lombok对于代码有很强的侵入性，就可能带来一个比较大的问题，那就是会影响我们对JDK的升级。按照如今JDK的升级频率，每半年都会推出一个新的版本，但是Lombok作为一个第三方工具，并且是由开源团队维护的，那么他的迭代速度是无法保证的。所以，如果我们需要升级到某个新版本的JDK的时候，若其中的特性在Lombok中不支持的话就会受到影响。还有一个可能带来的问题，就是Lombok自身的升级也会受到限制。因为一个应用可能依赖了多个jar包，而每个jar包可能又要依赖不同版本的Lombok，这就导致在应用中需要做版本仲裁，而我们知道，jar包版本仲裁是没那么容易的，而且发生问题的概率也很高。 4）注解使用有风险 在使用Lombok过程中，如果对于各种注解的底层原理不理解的话，很容易产生意想不到的结果。举一个简单的例子：我们知道，当我们使用@Data定义一个类的时候，会自动帮我们生成equals()方法 。但是如果只使用了@Data，而不使用@EqualsAndHashCode(callSuper=true)的话，会默认是@EqualsAndHashCode(callSuper=false)，这时候生成的equals()方法只会比较子类的属性，不会考虑从父类继承的属性，无论父类属性访问权限是否开放，这就可能得到意想不到的结果。 5）可能会破坏封装性 使用过程中如果不小心，在一定程度上就会破坏代码的封装性。举个简单的例子，我们定义一个购物车类，并且使用了@Data注解： 123456789@Datapublic class ShoppingCart { //商品数目 private int itemsCount; //总价格 private double totalPrice; //商品明细 private List items = new ArrayList&lt;&gt;();} 我们知道，购物车中商品数目、商品明细以及总价格三者之前其实是有关联关系的，如果需要修改的话是要一起修改的。但是，我们使用了Lombok的@Data注解，对于itemsCount 和 totalPrice这两个属性，虽然我们将它们定义成 private 类型，但是提供了 public 的 getter、setter 方法。 外部可以通过 setter 方法随意地修改这两个属性的值，我们可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。 而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。 好的做法应该是不提供getter/setter，而是只提供一个public的addItem方法，同时取修改itemsCount、totalPrice以及items三个属性。 因此，在此种情况下，就不适合使用Lombok，或者只用@Getter不用@Setter，而别直接使用@Data，在使用过程中，需要多多小心。 安装1. 安装插件Lombok插件支持Eclipse、IntelliJ IDEA、MyEclispe等IDE，在这里我们使用IntelliJ IDEA来演示安装： 1）打开File &gt; Settings &gt; Plugins &gt;Marketplace，搜索Lombok，如图，点击install，弹窗Accept，然后安装好后Restart IDEA。 2）设置Enable annotation processing 打开File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors，勾选Enable annotation processing，然后Apply和OK。 2. 导入jar包常用jar包引入方法有两种，如下： 方法1：普通项目可以直接官网下载jar包，和使用普通jar包一样，导入项目即可。jar下载地址：点击去下载 方法2：Maven项目可以在pom.xml中配置依赖坐标即可，依赖坐标如下： 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 常用注解@NonNull@NonNull该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。 示例代码： 1234//成员方法参数加上@NonNull注解，构造方法也一样，在此不做演示public String getName(@NonNull Person p){ return p.getName();} 实际效果相当于： 123456public String getName(Person p){ if(p==null){ throw new NullPointerException(&quot;person&quot;); } return p.getName();} @Getter和@Setter使用此注解相当于为成员变量生成对应的get和set方法，方法默认修饰符为public，同时还可以使用AccessLevel为生成的方法指定访问修饰符。这两个注解还可以直接用在类上，可以为此类里的所有非静态成员变量生成对应的get和set方法。 示例代码： 1234567891011public class Student{ @Getter @Setter private String name; @Setter(AccessLevel.PROTECTED) private int age; @Getter(AccessLevel.PUBLIC) private String language;} @ToString使用此注解会自动重写对应的toStirng方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割，通过callSuper参数来指定是否引用父类，includeFieldNames参数设为true，就能明确的输出toString()属性。 示例代码： 12345678910111213141516171819202122@ToString(exclude=&quot;id&quot;)public class ToStringExample { private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() { return this.getName(); } @ToString(callSuper=true, includeFieldNames=true) public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.width = width; this.height = height; } }} 实际效果相当于： 123456789101112131415161718192021222324252627282930public class ToStringExample { private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() { return this.getName(); } public static class Square extends Shape { private final int width, height; public Square(int width, int height) { this.width = width; this.height = height; } @Override public String toString() { return &quot;Square(super=&quot; + super.toString() + &quot;, width=&quot; + this.width + &quot;, height=&quot; + this.height + &quot;)&quot;; } } @Override public String toString() { return &quot;ToStringExample(&quot; + this.getName() + &quot;, &quot; + this.shape + &quot;, &quot; + Arrays.deepToString(this.tags) + &quot;)&quot;; }} @NoArgsConstructor、@RequiredArgsConstructor和@AllArgsConstructor这三个注解都是用在类上的，第一个和第三个都很好理解，就是为该类产生无参的构造方法和包含所有参数的构造方法，第二个注解则使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法，当然，成员变量都是非静态的，另外，如果类中含有final修饰的成员变量，是无法使用@NoArgsConstructor注解的。 三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用@RequiredArgsConstructor(staticName=”methodName”)的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象。 示例代码： 12345678910@RequiredArgsConstructor(staticName = &quot;myShape&quot;)@AllArgsConstructor(access = AccessLevel.PROTECTED)@NoArgsConstructorpublic class Shape { private int x; @NonNull private double y; @NonNull private String name;} @Data@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。@Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 官方实例如下： 12345678910111213@Data public class DataExample { private final String name; @Setter(AccessLevel.PACKAGE) private int age; private double score; private String[] tags; @ToString(includeFieldNames=true) @Data(staticConstructor=&quot;of&quot;) public static class Exercise&lt;T&gt; { private final String name; private final T value; }} @SneakyThrows这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常，很简单的注解，直接看个例子： 1234567891011public class SneakyThrows implements Runnable { @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) { return new String(bytes, &quot;UTF-8&quot;); } @SneakyThrows public void run() { throw new Throwable(); }} 实际效果相当于： 1234567891011121314151617public class SneakyThrows implements Runnable { public String utf8ToString(byte[] bytes) { try{ return new String(bytes, &quot;UTF-8&quot;); }catch(UnsupportedEncodingException uee){ throw Lombok.sneakyThrow(uee); } } public void run() { try{ throw new Throwable(); }catch(Throwable t){ throw Lombok.sneakyThrow(t); } }} @Synchronized这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized得锁对象分别是私有静态final对象LOCK和私有final对象lock，当然，也可以自己指定锁对象，例子也很简单： 123456789101112131415161718public class Synchronized { private final Object readLock = new Object(); @Synchronized public static void hello() { System.out.println(&quot;world&quot;); } @Synchronized public int answerToLife() { return 42; } @Synchronized(&quot;readLock&quot;) public void foo() { System.out.println(&quot;bar&quot;); }} 实际效果相当于： 1234567891011121314151617181920212223public class Synchronized { private static final Object $LOCK = new Object[0]; private final Object $lock = new Object[0]; private final Object readLock = new Object(); public static void hello() { synchronized($LOCK) { System.out.println(&quot;world&quot;); } } public int answerToLife() { synchronized($lock) { return 42; } } public void foo() { synchronized(readLock) { System.out.println(&quot;bar&quot;); } } } @Log这个注解用在类上，可以省去从日志工厂生成日志对象这一步，直接进行日志记录，具体注解根据日志工具的不同而不同，同时，可以在注解中使用topic来指定生成log对象时的类名。不同的日志注解总结如下(上面是注解，下面是实际作用)： 1234567891011121314@CommonsLogprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);@JBossLogprivate static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);@Logprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());@Log4jprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);@Log4j2private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);@Slf4jprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);@XSlf4jprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 示例代码： 在实际的使用中完全做到了无缝衔接，与注释调到的功能完全等价，简洁而优雅 1234567891011@Controller@Slf4jpublic class SampleController { //private static Logger log= LogManager.getLogger(SampleController.class); @RequestMapping(&quot;/&quot;) public String home(ModelMap model) { log.info(&quot;aa&quot;); return &quot;main&quot;; }} @Builder建造者的模式一般是这样（减少了成员变量，只有一个成员变量一般不用此模式） 1234567891011121314151617181920212223242526272829303132public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(Builder builder) { this.name= builder.name; } public static Builder builder(){ return new Builder(); } public static class Builder{ private String name; public Builder name(String name) { this.name= name; return this; } public User build(){ return new User(this); } }} 使用了@Builder之后,只需要这样 123456@Builder@Getter@Setterpublic class User { private String name;} 二者调用方法相同 12345@Testpublic void main() throws Exception{ User user=User.builder().name(&quot;Asens&quot;).build(); System.out.println(user.getName());} 参考文章Lombok入门使用教程及其优缺点详解 Lombok指南","link":"/2023/09/22/Lombok%E8%AF%A6%E8%A7%A3/"},{"title":"MyBatis笔记","text":"简介MyBatis简介 MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化和持久层 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 什么是持久层？ 完成持久化工作的代码块 —— dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念，而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】 为什么需要Mybatis？ Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) —&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！ MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 MyBatis示例程序1. 数据库代码12345678910CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` varchar(30) DEFAULT NULL, `pwd` varchar(30) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`name`,`pwd`) values (1,'狂神','123456'),(2,'张三','abcdef'),(3,'李四','987654'); 2. maven配置12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 3. 编写MyBatis核心配置文件 mybatis-comfig.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注：springboot中配置放在application.yaml文件中 4. 编写MyBatis工具类12345678910111213141516171819202122import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //获取SqlSession连接 public static SqlSession getSession(){ return sqlSessionFactory.openSession(); }} 5. 创建实体类12345678public class User { private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString()} 6. 编写Mapper接口类12345import com.kuang.pojo.User;import java.util.List;public interface UserMapper { List&lt;User&gt; selectUser();} 7. 编写Mapper.xml配置文件123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 8. 编写测试类123456789101112131415public class MyTest { @Test public void selectUser() { SqlSession session = MybatisUtils.getSession(); //方法一: //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;); //方法二: UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); }} CURD操作select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 id 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 parameterType 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 resultType SQL语句返回值类型。【完整的类名或者别名】 示例程序：根据id查询用户 在UserMapper中添加对应方法： 123456public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id);} 在UserMapper.xml中添加Select语句： 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where id = #{id}&lt;/select&gt; 测试类中测试： 12345678@Testpublic void tsetSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();} 示例程序：根据密码和名字查询用户 在UserMapper中添加对应方法： 12345678public interface UserMapper { //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id); //根据密码和名字查询用户 User selectUserByNP2(Map&lt;String,Object&gt; map);} 在UserMapper.xml中添加Select语句： 123&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #{username} and pwd = #{pwd}&lt;/select&gt; 使用方法时： 1234Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;username&quot;,&quot;小明&quot;);map.put(&quot;pwd&quot;,&quot;123456&quot;);User user = mapper.selectUserByNP2(map); insert、update、delete增、删、改操作需要提交事务！ 与select操作类似。 MyBatis配置解析 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： 1234567891011121314configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件！【演示】 environments元素12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点：environment 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 1&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt; 详情：点击查看官方文档 这两种事务管理器类型都不需要设置任何属性。 子元素节点：数据源（dataSource） dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 1type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled： 这个数据源的实现只是每次被请求时打开和关闭连接。 pooled： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. mappers元素mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。 映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式12345678910111213141516171819202122232425&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!-- 将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; Mapper文件123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace和子元素的id联合保证唯一 , 区别不同的mapper 绑定DAO接口 namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 动态SQL简介什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。 表达式if 语句举例：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询。 123456789101112&lt;!--select * from blog where title = #{title} and author = #{author}--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog where &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/select&gt; 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select from user where title=#{title},但是如果title为空呢？那么查询语句为 select from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！ where语句修改上面的SQL语句； 1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。【这是我们使用的最多的案例】 Set语句同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？ 12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title}, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id};&lt;/update&gt; choose语句有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句。 12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #{title} &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt;&lt;/sql&gt; 引用SQL片段： 12345678&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意： ① 最好基于 单表来定义 sql 片段，提高片段的可重用性 ② 在 sql 片段中不要包括 where foreach语句举例：我们需要查询 blog 表中 id 分别为1,2,3的博客信息。 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧","link":"/2023/08/02/MyBatis%E7%AC%94%E8%AE%B0/"},{"title":"Mysql之windows10安装（8.0.17）","text":"1.下载文件下载网站：https://dev.mysql.com/downloads/mysql/ 2.配置文件(1)解压文件夹（2）右键新建txt文件，输入以下内容（注意basedir更改为mysql-8.0.17-winx64文件夹路径) 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB （3）将文件另存为my.ini 3.启动mysql数据库（1）在搜索栏输入cmd，右键命令提示符，以管理员身份运行（2）输入命令，切换成mysql目录（注意路径更改为自己mysql-8.0.17-winx64文件夹路径) 1C:\\Users\\Administrator&gt;cd C:\\Program Files\\MySQL\\bin (3)输入命令，初始化数据库执行完成后输出初始密码（如该初始密码为rI5rvf5x5G） 1234C:\\Program Files\\MySQL\\bin&gt;mysqld --initialize --console2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 49842018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server has completed （4）输入安装命令 1C:\\Program Files\\MySQL\\bin&gt;mysqld install （5）输入命令， 启动mysql服务 1C:\\Program Files\\MySQL\\bin&gt;net start mysql 4.登录mysql数据库(1)输入命令 1C:\\Program Files\\MySQL\\bin&gt;mysql -u root -p (2)输入密码 1Enter password: (3)密码输入正确后，出现 1mysql&gt; 安装部署就完成啦！","link":"/2021/01/03/Mysql%E4%B9%8Bwindows10%E5%AE%89%E8%A3%85%EF%BC%888.0.17%EF%BC%89/"},{"title":"Mysql之忘记密码重置（8.0.17）","text":"1.打开命令窗口cmd，输入命令，停止MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;net stop mysql 2.输入命令，开启跳过密码验证登录的MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysqld --console --skip-grant-tables --shared-memory 结果如图：3.再打开一个新的cmd，转到mysql/bin目录下输入 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysql 4.使用命令，将密码置为空 1mysql&gt;use mysql 1mysql&gt;update user set authentication_string='' where user='root'; 5.使用命令，退出mysql 1mysql&gt;quit 6.打开命令框，输入命令，启动MySQL服务 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;net start mysql (如果显示“发生系统错误”，可以使用任务管理器直接打开服务）7.输入登录命令，直接登录 1D:\\mysql-8.0.12-winx64\\mysql-8.0.12-winx64\\bin&gt;mysql -u root -p 8.完成！ ​ ​","link":"/2021/02/01/Mysql%E4%B9%8B%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%EF%BC%888.0.17%EF%BC%89/"},{"title":"SSM框架概念","text":"SSM框架概述SSM框架是spring、spring MVC 和mybatis框架的整合，是标准的MVC模式。标准的SSM框架有四层，分别是dao层（mapper），service层，controller层和View层。使用spring实现业务对象管理，使用spring MVC负责请求的转发和视图管理，mybatis作为数据对象的持久化引擎。 SSM框架组成部分1）持久层：Dao层（mapper）层作用：主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此。 Dao层首先设计的是接口，然后再Spring的配置文件中定义接口的实现类。 然后可以在模块中进行接口的调用来进行数据业务的处理。（不在关心接口的实现类是哪个类） 数据源的配置以及有关数据库连接的参数都在Spring的配置文件中进行配置。 2）业务层：Service层作用：Service层主要负责业务模块的逻辑应用设计。 先设计接口然后再设计实类，然后再在Spring的配置文件中配置其实现的关联。（业务逻辑层的实现具体要调用到自己已经定义好的Dao的接口上）这样就可以在应用中调用Service接口来进行业务处理。 建立好Dao之后再建立service层，service层又要在controller层之下，因为既要调用Dao层的接口又要提供接口给controller层。每个模型都有一个service接口，每个接口分别封装各自的业务处理的方法。 3）表现层：Controller层（Handler层）作用：负责具体的业务模块流程的控制。 配置也同样是在Spring的配置文件里面进行， 调用Service层提供的接口来控制业务流程。 业务流程的不同会有不同的控制器，在具体的开发中可以将我们的流程进行抽象的归纳，设计出可以重复利用的子单元流程模块。 4）View层作用：主要和控制层紧密结合，主要负责前台jsp页面的表示。 其他概念说明POJO (Plain Ordinary Java Object, 简单Java对象)实际就是普通JavaBeans，是为了避免和EJB（Enterprise Java Beans 企业级JavaBeans）混淆所创造的简称，也称为（Plain Old Java Object 又普通又老的对象）。POJO的内在含义是指：那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。 它仅包含自身的属性以及自身属性的getter和setter方法，这意味者POJO可以方便的从一个框架迁移到另一个框架中，或者框架升级也会对代码毫无影响，因此而得到复用。 一般，当需要持久化对象时，人们喜欢将该对象放在名为xxxPOJO的目录中。当然，不建议这样命名。POJO实际上是包括BO/VO/PO/DO等一系列对象的总称。有的团队规定禁止命名成xxxPOJO。 DO (Domain Object, 领域对象)领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 PO (persistence object, 持久层对象)PO是在ORM（对象关系映射）中与数据表的一条记录相匹配，自身属性与数据表字段一一对应。可以将数据表中的一条记录作为一个对象处理，并可以转化为其它对象。面对不同的数据源时，比如文档型数据库，对象型数据库等时，顾名思义PO是DAO层为进行持久化操作而准备的对象。 包含getter、setter方法。 不包含业务逻辑与数据库的访问方法。因为数据库本身不包含业务逻辑。 PO平常不一定需要实现序列化，只是当采用分布式存储或者需要作为前端输出及远程调用使用时，应该实现序列化。 DAO (data access object, 数据访问对象)包含对数据的访问，负责持久层的操作 。通常需要结合PO来访问数据库，主要用来封装对数据的访问，并不转化成其它对象。在基于“事务脚本”的业务设计时，它包含业务逻辑。否则，一般只包含持久化的封装。 DTO (Data Transfer Object, 数据传输对象)数据传输对象，是在应用网络层需要传输的对象，是一个为了减少方法调用次数而在进程间传输数据的对象。 在《阿里巴巴开发手册中》规定是Service 或 Manager 向外传输的对象。 某些人称这个为“值对象”，当然还是有稍许区别。值对象追求对象不可变，DTO的对象是可修改，可改变的。 VO (value object, 值对象）Value Object和View Object的简写都是VO，可能容易弄混。View Object的含义是通常是Web向模板渲染引擎层传输的对象。《阿里巴巴开发手册》中建议把输出的显示层对象命名为VO。当然，也有人把这个对象命名为DTO作为传输。 123456//Controller层public HttpResult list(@RequestBody XXParam param){ HttpResult vo=HttpResultUtils.convert(XXDTO); return vo;}12345 由于很多页面需要额外数据，比如错误码、提示信息、分页信息等，查询的DTO之后需要再封装成View Object 显示层对象再显示出来 参考文献SSM框架讲解（史上最详细的文章） 概念POJO、DTO、DAO、PO、BO、VO、QO、ENTITY详解 浅析DO、VO、DTO、PO的概念与区别","link":"/2023/08/15/SSM%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5/"},{"title":"SimpleDB-Lab1","text":"0.实验目标完成本实验后，要能通过ScanTest系统测试 实现管理Tuple的类，即Tuple、TupleDesc。SimpleDB 中已经实现了Field、IntField、 StringField和Type，只需要支持整数和（固定长度的）字符串字段以及固定长度的 tuples。 实现 Catalog 。 实现BufferPool构造函数和getPage()方法。 实现访问方法、HeapPage和HeapFile以及相关的ID类。 实现操作符SeqScan。 1. 实现管理Tuple的类a. 要修改的文件 src/java/simpledb/storage/TupleDesc.java src/java/simpledb/storage/Tuple.java b. 实现目标 通过单元测试TupleTest和TupleDescTest。 其中，modifyRecordId()方法应该失败（暂时不需要实现）。 c. 设计思路 Tuple类 构造函数Tuple(TupleDesc td) TupleDesc getTupleDesc() 增加私有变量TupleDesc td RecordId getRecordId() 增加私有变量RecordId rid void setRecordId(RecordId rid) void setField(int i, Field f) 增加私有变量Field数组 Field getField(int i) String toString() Iterator&lt;Field&gt; fields() void resetTupleDesc(TupleDesc td) TupleDesc类 Iterator&lt;TDItem&gt; iterator() TupleDesc(Type[] typeAr, String[] fieldAr) 增加私有变量TDItem数组 TupleDesc(Type[] typeAr) int numFields() String getFieldName(int i) Type getFieldType(int i) int fieldNameToIndex(String name) int getSize() 计算所占字节数 TupleDesc merge(TupleDesc td1, TupleDesc td2) boolean equals(Object o) int hashCode() String toString() 2. 实现Cataloga. 要修改的文件 src/java/simpledb/common/Catalog.java b. 实现说明需要在Catalog类中支持添加新表，以及获取特定表的信息的功能 c. 实现目标 通过单元测试CatalogTest d. 设计思路 映射集合：将表名映射到表id、将表id映射到表名、将表id映射到表、将表id映射到表主键 Catalog中存储当前数据库的表。对于SimpleDB，只有一个全局Catalog。 构造函数Catalog() void addTable(DbFile file, String name, String pkeyField)：在Catalog中插入一张新表，表内容为file，表名为name，主键名为pkeyfield（可为“”）。若表名已存在，则更新表内容。 int getTableId(String name)：返回指定表名的表的id。 TupleDesc getTupleDesc(int tableid)：通过表id获取表描述。 DbFile getDatabaseFile(int tableid)：通过表id获取表。 … … 3. 实现BufferPool的getPage()方法a. 要修改的文件 src/java/simpledb/storage/BufferPool.java b. 实现说明 没有单元测试，可以在HeapFile实现中测试。 能够使用DbFile.readPage方法来访问DbFile的页面。 c. 设计思路 BufferPool是缓冲池，存储固定数量的Page。对于SimpleDB，只有一个全局BufferPool。 numPages：存储的Page的数量。 构造函数BufferPool(int numPages) Page getPage(TransactionId tid, PageId pid, Permissions perm)：获取指定的Page。若在缓冲池中，则直接返回；否则，从磁盘中读取并加入到BufferPool。若BufferPool空间不够，则淘汰掉Page，并将新读入的Page放在淘汰掉的Page的位置。 … … 映射集合：将PageId映射到BPageId，若对应的value为-1则说明BufferPool中没有该Page，需要先读取进BufferPool。 Page的List集合：BufferPool中存储的Page，通过BPageId能够直接获取Page pageNum：当前BufferPool中的Page数量，若小于numPages则可以直接将Page加载到BufferPool中，否则需要淘汰Page。 需要读入Page时，应该调用BufferPool.getPage。BufferPool中存放着缓存的Page。若需要读取的Page在BufferPool中，就直接返回该页面；否则，通过Catalog.getDatabaseFile()获得DbFile表文件（例如HeapFile），再调用DbFile.readPage()从磁盘中加载需要读取的Page，之后更新BufferPool。 4. 实现HeapPage的方法a. 要修改的文件 src/java/simpledb/storage/HeapPageId.java src/java/simpledb/storage/RecordId.java src/java/simpledb/storage/HeapPage.java b. 实现说明在HeapPage中实现getNumEmptySlots()和isSlotUsed()方法，这些方法需要在页面头部移动位。可以查看HeapPage或src/simpledb/HeapFileEncoder.java中提供的其他方法，来了解页面的布局。 实现页面中Tuple的迭代器，这可能涉及辅助类或数据结构。 在实现了HeapPage之后，还要为HeapFile编写方法，用于计算文件中的页面数量并从文件中读取页面。然后就能够从存储在磁盘上的文件中获取元组。 c. 实现目标 通过单元测试HeapPageIdTest、RecordIDTest和HeapPageReadTest。 d. 设计思路 HeapPage实现了接口Page，是用堆文件的方式存储Tuple。包括PageId pid，Tuple描述td、指明当前位置是否为空的header（类似位图）、Tuple集合tuples、槽位数量numSlots，还有用于恢复数据的oldData和oldDataLock。 构造函数HeapPage(HeapPageId id, byte[] data)：给变量pid、td、numSlots赋值。data通过流解析：前header.length位是header，指明该Page中的header.length条记录（元组）是否有效；之后是Tuples，每个Tuple占td.getSize()位。读取完数据后关闭流dis。最后调用setBeforeImage()，将Page中的数据存档在oldData中，用于数据恢复。 HeapPage getBeforeImage()：返回一个新的HeapPage对象，其中的内容是oldData中的存档信息，用于数据恢复。 void setBeforeImage()：将Page中的数据备份到oldData中，作为一个存档，用于数据恢复。 Tuple readNextTuple(DataInputStream dis, int slotId)：通过流dis读取Page中第slotId个元组的数据，返回读取到的元组以Tuple形式返回。若第slotId位为空，则从dis中读td.getSize()位（该表中单个元组的大小），然后返回null；否则创建新的Tuple，并设置RecordId，之后调用Type.parse方法得到Field，并通过Tuple.setFiled设置元组的数值，最后返回该Tuple。 byte[] getPageData()：生成一个byte数组来表示Page中的所有数据，用于序列化这个Page存放到磁盘上。 创建一个ByteArrayOutputStream名为baos，长度为PageSize。再创建一个DataOutputStream向baos写入Bytes。首先写入header，之后对于每个元组，若元组为空则写入td.getSize()（一个元组的长度）个0；否则遍历元组内的Field，调用Field.serialize()写入输出流。将除了header、元组外的剩余位置都补0，最后刷新到输出流，返回baos.toByteArray()，也就是最后的字节数组。 byte[] createEmptyPageData()：静态方法，生成一个空的PageData的字节数组。 HeapPage的header是byte[]类型，因此大小为ceil(numSlots/8)。isSlotUsed()方法需要进行位运算。 HeapPage的迭代器需要自定义，因为中间可能有空位，需要跳过null获得下一个元组。 5. 实现HeapFile的方法a. 要修改的文件 src/java/simpledb/storage/HeapFile.java b. 实现说明从磁盘读取页面，首先需要计算文件中的正确偏移量。（提示：为了在任意偏移量处读取和写入页面，你需要对文件进行随机访问。在从磁盘读取页面时，不应调用BufferPool的方法。） 还需要实现HeapFile.iterator()方法，该方法应遍历HeapFile中每个页面的元组。迭代器必须使用BufferPool.getPage()方法来访问HeapFile中的页面。该方法将页面加载到缓冲池中，并最终用于实现基于锁的并发控制和恢复（在后续的实验中）。不要在open()调用时将整个表加载到内存中，若表非常大会导致内存错误。 c. 实现目标 通过单元测试HeapFileReadTest。 d. 设计思路 DbFile是表述单张表的数据结构，能够获取到表在磁盘上存储的具体Pages，并且遍历表的元组。每个DbFild都是通过缓存池来获取的。 Page readPage(PageId id)：从磁盘中读取指定的Page。 void writePage(Page p)：将指定的Page写入磁盘。 List&lt;Page&gt; insertTuple(TransactionId tid, Tuple t)：将指定的tuple插入表中，返回被修改的Page的List。 List&lt;Page&gt; deleteTuple(TransactionId tid, Tuple t)：从表中移除指定的tuple，返回被修改的Page的List。 DbFileIterator iterator(TransactionId tid)：返回一个能够遍历所有元组的迭代器（通过BufferPool的getPage实现）。 int getId()：返回这个DbFile在Catalog中的ID。 TupleDesc getTupleDesc()：返回这个表的TupleDesc。 int numPages()：HeapFile中包含的Page数量，为文件大小除PageSize向上取整。 Page readPage(PageId pid)：主要参考TestUtil中的readFileBytes(String path)方法，从文件中读取data。之后调用构造函数HeapPage(pid, data)创建HeapPage对象并返回。 DbFileIterator iterator(TransactionId tid)：对HeapFile中的所有元组进行遍历。 DbFileIterator是一个接口，可以看作一个扩展的迭代器。 void open()：打开迭代器，打开之前无法获取迭代器中的内容。 boolean hasNext()：是否有下一项。 Tuple next()：返回下一个元组并使迭代器向后移一位。 void rewind()：重设迭代器，使其返回开头。 void close()：关闭迭代器，关闭后无法获取下一项内容。 这里对DbFileIterator的实现类之一AbstractDbFileIterator进行实现。由于AbstractDbFileIterator是抽象类，因此需要实现抽象方法readNext()以及没有实现的父类方法open()和rewind()。 在AbstractDbFileIterator实现类中，新增两个变量tupleIterator和currentPage，分别是Page内的迭代器以及当前的Page。这是由于HeapPage中实现了对元组的迭代器，因此可以直接通过迭代器遍历Page内元组。 若迭代器遍历到该Page最后一项，则需要查看是否还有下一页。若有，则更新currentPage和迭代器tupleIterator；否则返回null。 6. 实现Operatora. 要修改的文件 src/java/simpledb/execution/SeqScan.java b. 实现说明该操作符按顺序扫描由构造函数中的tableid指定的表的所有页面中的元组。该操作符应通过DbFile.iterator()方法访问元组。 c. 实现目标 通过系统测试ScanTest d. 设计思路 从实现角度来说不难，创建变量tid、tableId、tableAlias分别为事务编号、表号和表的别名。 TupleDesc getTupleDesc()：返回带有别名的表描述。创建新的Type[]和String[]，用原本的表描述（通过表号查询得到）来给变量赋值。 hasNext()、next()等一系列Iterator相关方法：通过获取HeapFile的iterator实现。本质上是检测之前的Iterator的正确性。 小结 实现不难，但是Iterator相关测试一直报错。一路查上去发现是之前的一些文件没写正确，但是当时的Test过于简单因此没查出问题。 由于SeqScan的Iterator就是调用HeapFile的iterator实现，因此重新查看HeapFileReadTest。与Iterator相关的测试为testIteratorBasic()，但是只测了三个元组，测试过于简单。用该测试测试505条元组后开始报错。一个Page中最多存放504个元组，这说明对于多个Page的HeapFile读取有误。 重新查看对HeapPageReadTest，发现不论怎么修改测试数据结果均正确，说明对Page内的元组的读写无误。那么问题应该出在HeapFile与HeapPage的数据传输上。 HeapFile是整个表的抽象，有file变量指向数据在磁盘具体位置，但是并不会保存具体的Page。当用户需要查询Page时，首先通过BufferPool的readPage查看Page是否在缓冲池中，若在则直接返回该Page；否则调用表文件HeapFile的readPage，从磁盘中读入Page，并更新缓冲池信息。 因此问题出在HeapFile的readPage()方法中。经查看，原本的方法一次性读入了全部文件并直接传入HeapPage的构造方法，返回新创建的HeapPage。进行更正后，输入流首先根据PageId，跳过之前的Page，读取PageSize个字节存入data，再将data传入HeapPage的构造方法创建新的HeapPage。 更正完成后，测试通过。","link":"/2023/10/30/SimpleDB-Lab1/"},{"title":"SimpleDB-Lab2","text":"0.实验目标实验二需要为SimpleDB编写一组操作符，用于实现表的修改（例如，插入和删除记录），选择操作，连接操作和聚合操作。这些操作将在Lab 1中所编写的基础上构建。此外，需要设计页面淘汰策略，完善缓冲池。仍不需要实现事务和锁。 可以使用提供的SQL解析器对数据库运行SQL查询。 实现Filter和Join操作符。这些操作符的Javadoc注释中包含了其工作细节。Project和OrderBy已实现，这可能有助于您理解其他操作符的工作方式。 实现IntegerAggregator和StringAggregator。需要编写逻辑来计算在一系列输入元组中，跨多个分组计算特定字段的聚合结果。由于SimpleDB仅支持整数，所以在计算平均值时请使用整数除法。StringAggregator仅需要支持COUNT聚合操作，因为其他操作对于字符串没有意义。 实现Aggregate操作符。和其他运算符一样，聚合运算符实现了 OpIterator 接口，这样它们就可以放在 SimpleDB 查询计划中。注意Aggregate运算符的输出是每次调用next()时整个组的聚合值，并且聚合构造器需要聚合和分组字段。 在 BufferPool 中实现与元组插入、删除和页面驱逐有关的方法。在这一点上，你不需要担心 transactions 的问题。 实现插入和删除操作符。像所有的操作符一样，Insert和Delete实现了OpIterator，接受一个要插入或删除的 tuple 流，并输出一个带有整数字段的单一 tuple ，表示插入或删除的 tuple 数量。这些操作者将需要调用BufferPool中的适当方法，这些方法实际上是修改磁盘上的页面。检查插入和删除 tuple 的测试是否正常工作。 P.S. 请注意，SimpleDB没有实现任何类型的一致性或完整性检查，所以有可能在文件中插入重复的记录，也没有办法强制执行主键或外键约束。 1. Filter and Joina. 要修改的文件 src/java/simpledb/execution/Predicate.java src/java/simpledb/execution/JoinPredicate.java src/java/simpledb/execution/Filter.java src/java/simpledb/execution/Join.java b. 实现说明 SimpleDB OpIterator类实现了关系代数的操作，现在需要实现两个运算符，使你能够执行比表扫描更有趣的查询。 Filter: 这个操作符只返回满足 “谓词 “的 tuple ，”谓词 “是作为其构造函数的一部分指定的。因此，它过滤掉任何不符合谓词的 tuple 。 Join: 这个操作符根据作为其构造函数一部分传入的 “JoinPredicate “来连接其两个子代的 tuple 。我们只需要一个简单的嵌套循环连接，但你可以探索更有趣的连接实现。在你的实验报告中描述你的实现。 c. 实现目标 通过单元测试 PredicateTest、JoinPredicateTest、FilterTest 和 JoinTest 通过系统测试 FilterTest 和 JoinTest d. 设计思路 Predicate类，即“谓词”，是用来辅助实现Filter操作的。构造函数中需要三个参数：需要进行比较tuple中的field的编号field、比较的操作符op（等于、大于等）、进行比较的值operand。 举个例子，当需要过滤出第2列大于200的tuple时，可以创建Predicate(field=2, op=GREATER_THAN, operand=200) Predicate类的filter方法，传入一个tuple，返回该tuple是否满足“谓词条件”。 Filter类，继承了抽象类Operator。用来过滤出符合“谓词条件”的tuple，”谓词 “是作为其构造函数的一部分指定的。 可以看做一个自定义的迭代器，通过调用fetchNext()来获取符合要求的下一个tuple。 JoinPredicate类，与Predicate类类似，用来辅助Join操作。 JoinPredicate类的filter方法，传入两个tuple，返回这两个tuple是否满足“谓词条件”。 Join类，继承了抽象类Operator。用来将两张表进行连接。当且仅当表A与表B中的指定列的field的值相同时才连接。并且返回的tuple不去除重复的field值。 可以看做一个自定义的迭代器，通过调用fetchNext()来获取符合要求的下一个tuple。 e. 实现说明 参考OrderBy和Project类进行实现。 通过所有单元测试和系统测试。 2. Aggregatesa. 要修改的文件 src/java/simpledb/execution/IntegerAggregator.java src/java/simpledb/execution/StringAggregator.java src/java/simpledb/execution/Aggregate.java b. 实现说明 一个额外的SimpleDB操作符用GROUP BY子句实现了基本的SQL聚合。你应该实现五个SQL聚合（COUNT, SUM, AVG, MIN, MAX）并支持分组。你只需要支持单个字段的聚合，以及单个字段的分组。 为了计算聚合，我们使用一个Aggregator接口，将一个新元组合并到现有的聚合计算中。在构建过程中，Aggregator被告知它应该使用什么操作来进行聚合。随后，客户端代码应该为子迭代器中的每个元组调用Aggregator.mergeTupleIntoGroup()。在所有 tuple 被合并后，客户端可以检索到一个聚合结果的OpIterator。结果中的每个元组都是一对形式为(groupValue, aggregateValue)的元组，除非group by字段的值是Aggregator.NO_GROUPING，在这种情况下，结果是一个形式为(aggregateValue)的单一元组。 请注意，这个实现需要的空间与不同组的数量成线性关系。在本实验中，你不需要担心组的数量超过可用内存的情况。 c. 实现目标 通过单元测试IntegerAggregatorTest、StringAggregatorTest和AggregateTest 通过系统测试AggregateTest d. 设计思路 Aggregate用来实现聚合操作（COUNT, SUM, AVG, MIN, MAX）的，并支持分组。 构造函数中需要传入参数：tuple迭代器child（遍历表中的每个元组）、进行聚合的列号afield、需要分组的列号gfield和聚合的符号aop。 Aggregator是一个接口，有IntegerAggregator和StringAggregator两个实现 void mergeTupleIntoGroup(Tuple)将传入的tuple加入到当前的聚合中。 OpIterator iterator()返回聚合结果的迭代器 主要是通过Map&lt;Field, Tuple&gt;将group field值映射到tuple，也就是分组的每个值对应一个tuple。若没有进行分组，则将field值置为null，放入map中。 目前是在每次调用mergeTupleIntoGroup()时更新map。 也可以保存max、min、sum、count等中间结果，等到OpIterator的open()时再统一添加tuple。 IntegerAggregator的实现有点粗糙：为了实时更新AVG的结果，需要知道sum和count的结果，每次重新计算平均值，因此另外设计了两个Map，来存放每个分组的sum和count。 通过所有单元测试和系统测试。 3. HeapFile Mutabilitya. 要修改的文件 src/java/simpledb/storage/HeapPage.java src/java/simpledb/storage/HeapFile.java (Note that you do not necessarily need to implement writePage at this point). b. 实现说明 现在将开始实现支持修改表格的方法。我们从单个页面和文件的层面开始。有两组主要的操作：添加 tuple 和删除 tuple 。 删除 tuple：要删除一个 tuple ，你需要实现deleteTuple。元组包含记录ID，允许你找到它们所在的页面，所以这应该很简单，只要找到元组所属的页面并适当地修改页面的标题。 添加 tuple：HeapFile.java中的insertTuple方法负责向一个堆文件添加元组。要向HeapFile添加一个新元组，你必须找到一个有空槽的页面。如果HeapFile中没有这样的页面存在，你需要创建一个新的页面并将其追加到磁盘上的物理文件中。你将需要确保元组中的RecordID被正确地更新。 为了实现HeapPage，你需要为insertTuple()和deleteTuple()等方法修改标题位图。你可能会发现，我们在实验1中要求你实现的getNumEmptySlots()和isSlotUsed()方法可以作为有用的抽象方法。请注意，有一个markSlotUsed方法作为抽象，用来修改页眉中元组的填充或清除状态。 注意，重要的是，HeapFile.insertTuple()和HeapFile.deleteTuple()方法要使用BufferPool.getPage()方法访问页面；否则，你在下一个实验的事务实现将不能正常工作。 在src/simpledb/BufferPool.java中实现insertTuple()和deleteTuple()。 这些方法应该调用HeapFile中属于被修改的表的适当方法（这个额外的间接层次是需要的，以便在未来支持其他类型的文件（例如索引））。 c. 实现目标 通过单元测试HeapPageWriteTest、HeapFileWriteTest和BufferPoolWriteTest d. 实现说明 HeapPage中的插入与删除tuple insertTuple：寻找空闲的槽位，插入新的tuple，并更新这个tuple的recoedId，调用markSlotUsed更新Page信息。 deleteTuple：调用markSlotUsed更新Page信息。 HeapFile中的插入与删除tuple insertTuple：若有空闲的Page，则调用该Page的insertTuple插入；否则创建新的Page，再调用Page的insertTuple插入。返回更新过的Page（此处只修改了一个Page）。 deleteTuple：根据tuple的recordId信息找到对应的Page，调用Page的deleteTuple删除，并返回返回更新过的Page（此处只修改了一个Page）。 BufferPool中的插入与删除tuple insertTuple：调用HeapFile中的insertTuple，并调用updateBufferPool()对BufferPool进行更新。 deleteTuple：调用HeapFile中的deleteTuple，并调用updateBufferPool()对BufferPool进行更新。 updateBufferPool：自己写的私有函数，用于更新BufferPool中指定的Page信息。对传入的List，调用markDirty标记为脏页（之后需要写回磁盘）。若BufferPool中没有该页，则加入BufferPool。更新BufferPool中该页为最新传入的Page。 参考BTreeFile，实现了writePage() 测试BufferPoolWriteTest的handleManyDirtyPages中，首先创建了一个有一页的空Page的HeapFile，之后再加入10页，每页插入一条数据。然后测试文件中是否能读出十条数据。问题在于，HeapFileDuplicates的insertTuple()中是每次在文件中写入一个空页，然后创建一个新的HeapPage，再往HeapPage中插入数据，也就是数据没有写回文件中，仅仅保存在返回值List中。 因此在BufferPool的insertTuple和deleteTuple里加一步更新BufferPool的操作，也就是将修改后发生变化的Page重新更新到BufferPool（但是可以不写回磁盘） 但是有个新的问题是，如果更新操作在BufferPool中执行，那么单独调用HeapFile的insertTuple就无法读到最新的Page信息。测试BufferPool的insertTuple中，是先在file中写入新的一页，再插入tuple，因此在HeapFile的insertTuple中对文件进行读写是可行的。因此直接在HeapFile的insertTuple操作中，若之前的Page都满了，则写入新的Page，并直接将新的Page写入磁盘。 发现之前的BufferPool有误，更正插入的第一页PageNo为0. 通过单元测试HeapPageWriteTest、HeapFileWriteTest和BufferPoolWriteTest 4. Insertion and deletiona. 要修改的文件 src/java/simpledb/execution/Insert.java src/java/simpledb/execution/Delete.java b. 实现说明 现在你已经写好了所有用于添加和删除 tuple 的HeapFile机器，你将实现Insert和Delete操作。对于实现 “插入 “和 “删除 “查询的计划，最上面的运算符是一个特殊的 “插入 “或 “删除 “运算符，它修改了磁盘上的页面。这些操作符返回受影响 tuple 的数量。这是通过返回一个带有一个整数字段的单一元组来实现的，其中包含计数。 Insert：这个操作符将它从其子操作符中读取的 tuple 添加到其构造函数中指定的tableid’。它应该使用BufferPool.insertTuple()`方法来做这件事。 Delete: 这个操作符从其构造函数中指定的tableid中删除它从其子操作符中读取的 tuple。它应该使用BufferPool.deleteTuple()`方法来做这件事。 c. 实现目标 通过单元测试 InsertTest 通过系统测试 InsertTest 和 DeleteTest d. 设计思路 操作符Insert和Delete的fetchNext()通过调用BufferPool中的insertTuple()和deleteTuple()实现。返回值为单个Tuple，TD为INT_TYPE，值为修改的tuple的数量。 fetchNext()只能调用一次，第二次便返回null。因此设置一个私有变量，标记是否已经完成操作。 5. Page evictiona. 要修改的文件 src/java/simpledb/storage/BufferPool.java b. 实现说明 在实验1中，我们没有正确观察到由构造参数numPages定义的缓冲池中最大页数的限制。现在，你将选择一个页面淘汰策略，并对以前任何读取或创建页面的代码进行编程，以实现你的策略。 当缓冲池中的页面超过numPages时，在加载下一个页面之前，应该将一个页面从缓冲池中淘汰。淘汰策略的选择由你决定；没有必要做一些复杂的事情。 注意BufferPool要求你实现flushAllPages()方法。这不是你在真正实现缓冲池时需要的东西。然而，我们需要这个方法用于测试。你不应该在任何真正的代码中调用这个方法。 由于我们实现ScanTest.cacheTest的方式，你需要确保你的flushPage和flushAllPages方法不从缓冲池中淘汰页面，以正确通过这个测试。 flushAllPages应该在BufferPool中的所有页面上调用flushPage，flushPage应该将任何脏页写入磁盘并标记为不脏，同时将其留在BufferPool中。 唯一应该从缓冲池中删除页面的方法是evictPage，它应该对它所淘汰的任何脏页面调用flushPage。 如果你没有在上面的HeapFile.java中实现writePage()，你也需要在这里实现它。最后，你还应该实现discardPage()，以便从缓冲池中删除一个页面而不写入磁盘。我们不会在本实验中测试discardPage()，但它在未来的实验中是必要的。 c. 实现目标 通过系统测试 EvictionTest 由于我们不会检查任何特定的驱逐策略，这个测试通过创建一个有16页的BufferPool（注意：虽然DEFAULT_PAGES是50，但我们初始化的BufferPool更少！），扫描一个超过16页的文件，看看JVM的内存使用率是否增加了5MB以上。如果你没有正确地实施淘汰策略，你将无法淘汰足够多的页面，并将超过大小限制，从而导致测试失败。 d. 设计思路 flushPage()：将脏页写入磁盘，并标记为不脏。（不需要从BufferPool中淘汰该页） flushAllPages()：对BufferPool中的所有页面调用flushPage()。 discardPage()：从BufferPool中删除一个页面，并且不写入磁盘。 evictPage()：从BufferPool中淘汰一个页面。若为脏页，调用flushPage()将脏页写入磁盘；否则调用discardPage()直接删除页面。 e. 实现说明 更新了BufferPool，将把PageId映射到BufferPageId的Map更改为LinkedHashMap实现，这样就可以直接按照访存顺序获取到最近最久未访问的页面，便于页面淘汰。 相应地，将空页面的获取方式更改为了Queue实现。初始时，在队列中加载全部页面，之后每次需要时取出队列的第一个元素，将页面写入该位置的缓存。淘汰页面时，需要更新Queue，将淘汰页面的bpid重新加入Queue。 6. 小结 由于打包前要通过测试，所以一些各个Lab中通过打包实现的一些测试就先略过，最后再统一测试。","link":"/2023/11/05/SimpleDB-Lab2/"},{"title":"SimpleDB-Lab3","text":"0.实验介绍在这个实验中，你将在SimpleDB之上实现一个查询优化器。主要任务包括实现一个选择性估计框架和一个基于成本的优化器。你可以自由选择具体的实现方式，但我们建议使用类似于课堂上讨论的Selinger基于成本的优化器（第9讲）。 实现TableStats类中的方法，使其能够使用直方图（IntHistogram类提供的骨架）或你设计的其他形式的统计数据来估计过滤器的选择性和扫描的成本。 实现JoinOptimizer类中的方法，使其能够估计 join 的成本和选择性。 编写JoinOptimizer中的orderJoins方法。这个方法必须为一系列的连接产生一个最佳的顺序（可能使用Selinger算法），给定前两个步骤中计算的统计数据。 Optimizer outline 基于成本的优化器的主要思想是：使用关于表的统计数据来估计不同查询计划的 “成本”。通常情况下，一个计划的成本与中间连接和选择的cardinalities（产生的 tuple 数量），以及过滤器和连接谓词的选择性有关。 利用这些统计数据，以最佳方式排列连接和选择，并从几个备选方案中选择连接算法的最佳实现。 在本实室中，你将实现代码以执行这两项功能。 优化器将从simpledb/Parser.java调用。在开始这个实验之前，你可能希望回顾一下实验2的解析器练习。简而言之，如果你有一个描述你的表的目录文件catalog.txt，你可以通过输入java -jar dist/simpledb.jar parser catalog.txt来运行解析器。 当解析器被调用时，它将对所有的表进行统计计算（使用你提供的统计代码）。当一个查询被发出时，解析器将把查询转换成逻辑计划表示，然后调用你的查询优化器来生成一个最佳计划。 SimpleDB优化器的整体结构。分析器和优化器的SimpleDB模块的整体控制流程如图1所示。 需要实现带有双边框的组件。这些类和方法将在后面的文字中得到更详细的解释（你可能希望回过头来看看这个图），但基本操作如下： Parser.java在初始化时构建了一组表的统计数据（存储在statsMap容器中）。然后它等待一个查询的输入，并对该查询调用parseQuery方法。 parseQuery首先构建一个代表解析查询的LogicalPlan，然后在它构建的LogicalPlan实例上调用physicalPlan方法。physicalPlan方法返回一个DBIterator对象，可用于实际运行查询。 在接下来的exercise中，你将实现帮助物理计划（physicalPlan）设计出最优计划的方法。 成本估计。准确地估计计划成本是相当棘手的。在这个Lab中，我们将只关注连接序列和基本表访问的成本。我们不会担心访问方法的选择（因为我们只有一种访问方法，即表扫描），也不会担心额外运算符（如聚合）的成本。在这个Lab中，你只需要考虑left-deep的计划。接下来会了解你可能实现的额外的 “奖励 “优化器特性，包括处理杂乱计划的方法。 我们将以p=t1 join t2 join … tn的形式来写连接计划，这表示一个左深连接，其中t1是最左边的连接（树中最深的）。给定一个像p这样的计划，其成本可以表示为： 123scancost(t1) + scancost(t2) + joincost(t1 join t2) +scancost(t3) + joincost((t1 join t2) join t3) +... 这里，scancost(t1)是扫描表t1的I/O成本，joincost(t1,t2)是连接t1和t2的CPU成本。为了使I/O和CPU成本具有可比性，通常使用一个恒定的比例系数，例如： 12cost(predicate application) = 1cost(pageScan) = SCALING_FACTOR x cost(predicate application) 在这个实验中，你可以忽略缓存的影响（例如，假设对表的每一次访问都会产生全部的扫描成本）–同样，这也是你可以作为一个可选的额外扩展添加到实验中的东西。因此，scancost(t1)只是t1的页数x SCALING_FACTOR。 当使用嵌套循环连接时，记得两个表t1和t2（其中t1是外表）之间的连接成本是简单的。 12joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) //IO cost + ntups(t1) x ntups(t2) //CPU cost 此处，ntups(t1)是表t1中 tuples 的数量。 ntups可以通过扫描一个基表直接计算出来。对于一个有一个或多个选择谓词的表来说，估计ntups可能比较棘手–这就是过滤器的选择性估计问题。下面是你可能使用的一种方法，基于计算表中的值的直方图。 计算表中每个属性的最小值和最大值（通过扫描一次）。 为表中的每个属性构建一个直方图。一个简单的方法是使用一个固定数量的桶NumB，每个桶代表直方图属性领域的固定范围内的记录数。例如，如果一个字段f的范围是1到100，有10个桶，那么桶1可能包含1到10之间的记录数，桶2包含11到20之间的记录数，以此类推。 再次扫描该表，选择出所有 tuples 的所有字段，用它们来填充每个直方图中的桶的计数。 为了估计一个平等表达式f=const的选择性，计算包含值const的桶。假设桶的宽度（值的范围）是w，高度（ tuples 的数量）是h，而表中 tuples 的数量是ntups。那么，假设值在整个桶中是均匀分布的，表达式的选择性大致为(h/w)/ntups，因为(h/w)代表的是桶中含有值常数的 tuples 的预期数量。 为了估计一个范围表达式f&gt;const的选择性，计算const所在的桶b，其宽度为w_b，高度为h_b。那么，b包含了全部 tuples 中的一部分b_f = h_b / ntups。假设 tuples 均匀地分布在整个b中，b中大于const的部分b_part是（b_right - const）/ w_b，其中b_right是b的桶的右端点。因此，b桶对谓词贡献了（b_f x b_part）的选择性。此外，b+1…NumB-1桶贡献了它们所有的选择性（可以用类似于上面b_f的公式来计算）。将所有桶的选择性贡献相加，将产生表达式的整体选择性。图2说明了这个过程。 涉及小于的表达式的选择性可以类似于大于的情况下进行，看下到0的桶。 在接下来的两个练习中，你将用代码来执行连接和过滤器的选择性估计。 1. IntHistogram.javaa. 要修改的文件 src/java/simpledb/optimizer/IntHistogram.java b. 实现说明 你将需要实现一些方法来记录表的统计数据，以便进行选择性估计。我们提供了一个骨架类，IntHistogram，它可以做到这一点。我们的目的是让你使用上面描述的基于桶的方法来计算直方图，但你也可以自由地使用其他方法，只要它能提供合理的选择性估计。 我们提供了一个StringHistogram类，它使用IntHistogram来计算字符串谓词的选取。如果你想实现一个更好的估计器，你可以修改StringHistogram，尽管你不需要为了完成这个实验而修改。 c. 实现目标 通过单元测试 IntHistogramTest（如果你选择不实现基于直方图的选择性估计，你不需要通过这个测试） d. 实现说明 基本按照讲解实现。除了用List保存直方图外，还保存了min_value， max_value、bucket_width和num_tuples，用于计算。 当加入或估计的值在min_value和max_value范围之外时，单独进行判断。 2. TableStats.javaa. 要修改的文件 src/java/simpledb/optimizer/TableStats.java b. 实现说明 TableStats类包含了计算一个表中 tuples 和页数的方法，以及估计该表字段上的谓词的选择性的方法。我们创建的查询分析器为每个表创建一个TableStats的实例，并将这些结构传递给你的查询优化器（在后面的练习中你会需要它）。 你应该在TableStats中填写以下方法和类： 实现TableStats构造函数。一旦你实现了跟踪统计的方法，如直方图，你应该实现TableStats构造函数，添加代码来扫描表（可能是多次）以建立你需要的统计。 实现 estimateSelectivity(int field, Predicate.Op op, Field constant)。使用你的统计数据（例如，根据字段的类型，使用IntHistogram或StringHistogram），估计predicate字段op常量对表的选择性。 实现 estimateScanCost()。这个方法估计顺序扫描文件的成本，考虑到读取一个页面的成本是costPerPageIO。你可以假设没有寻道，也没有页面在缓冲池中。这个方法可以使用你在构造函数中计算的成本或大小。 实现 estimateTableCardinality(double selectivityFactor)。该方法返回关系中 tuples 的数量，考虑到应用了具有选择性的selectivityFactor的谓词。这个方法可以使用你在构造函数中计算的成本或大小。 c. 实现目标 通过单元测试 TableStatsTest d. 实现说明 基本参照说明实现。 （from chatgpt）setStatsMap()使用反射机制的原因可能是为了绕过 statsMap 字段的访问权限，以便在类的内部方法中直接替换整个 statsMap 对象。通过反射，可以将私有字段的访问权限设置为可访问，然后使用 set() 方法来替换 statsMap 对象，而不是通过普通的字段访问操作符来逐个修改字段的值。 TableStats构造函数：先扫描一遍所有tuple得到Field的最大最小值，根据最值创建直方图Histogram。再扫描第二遍，往Histogram中加入value，用于相应的估计。 estimateScanCost()：page数量乘上每页的cost。 estimateTableCardinality()：tuple数量乘上选择因子。 avgSelectivity()：均值没有测试，因此不确定实现的正确性。 estimateSelectivity()：根据构造函数创建的直方图，返回估计结果。 通过单元测试 TableStatsTest。 3. Join Cost Estimationa. 要修改的文件 src/java/simpledb/optimizer/JoinOptimizer.java b. 实现说明 观察一下，上面的连接计划p的成本包括形式为joincost((t1 join t2) join t3)的表达。为了评估这个表达式，你需要一些方法来估计t1 join t2的大小（ntups）。这个连接cardinality估计问题比过滤器的选择性估计问题更难。在这个实验中，你不需要为此做任何花哨的事情，尽管第2.4节中的一个可选的练习包括一个基于直方图的连接选择性估计的方法。 在实施你的简单解决方案时，你应该牢记以下几点： 对于等价连接，当其中一个属性是主键时，由连接产生的 tuples 的数量不能大于非主键属性的cardinality。 对于没有主键的等价连接，很难说输出的大小是什么–它可能是表的cardinalities的乘积的大小（如果两个表的所有 tuples 都有相同的值）–或者它可能是0。 对于范围扫描，同样也很难对尺寸说得准确。输出的大小应该与输入的大小成正比。假设交叉产物的一个固定部分是由范围扫描发出的（比如，30%），是可以的。一般来说，范围连接的成本应该大于相同大小的两个表的非主键平等连接的成本。 JoinOptimizer.java类包括所有用于排序和计算连接成本的方法。在这个练习中，你将写出用于估计 join 的 selectivity 和 cost 的方法，特别是： 实现 estimateJoinCost(LogicalJoinNode j, int card1, int card2, double cost1, double cost2) 。这个方法估计了连接j的成本，考虑到左边的输入是cardinality card1，右边的输入是cardinality card2，扫描左边输入的成本是cost1，访问右边输入的成本是card2。你可以假设这个连接是一个NL连接，并应用前面提到的公式。 实现 estimateJoinCardinality(LogicalJoinNode j, int card1, int card2, boolean t1pkey, boolean t2pkey) 。这个方法估计了j连接输出的 tuples 数，给定左边的输入是大小为card1，右边的输入是大小为card2，以及指示左边和右边（分别）字段是否唯一（主键）的标志t1pkey和t2pkey。 c. 实现目标 通过单元测试JoinOptimizerTest中的 estimateJoinCostTest 和 estimateJoinCardinality d. 实现说明 estimateJoinCost()通过公式计算连接的成本。其中，cost1为scancost(t1)，ntups(t1)为card1（表1中tuple与影响因子的乘积） 12joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) //IO cost + ntups(t1) x ntups(t2) //CPU cost estimateJoinCardinality()看文档有点没明白具体实现的算法，参考MIT 6.830 数据库系统实现。 通过测试。 4. Join Cost Estimationa. 要修改的文件 src/java/simpledb/optimizer/JoinOptimizer.java b. 实现说明 现在你已经实现了估计成本的方法，你将实现Selinger优化器。对于这些方法，连接被表达为一个连接节点的列表（例如，对两个表的谓词），而不是课堂上描述的连接关系的列表。将讲座中给出的算法转化为上述的连接节点列表形式，伪代码的概要是： 1234567891011j = set of join nodesfor (i in 1...|j|): for s in {all length i subsets of j} bestPlan = {} for s' in {all length d-1 subsets of s} subplan = optjoin(s') plan = best way to join (s-s') to subplan if (cost(plan) &lt; cost(bestPlan)) bestPlan = plan optjoin(s) = bestPlan return optjoin(j) 为了帮助你实现这个算法，我们提供了几个类和方法来帮助你。 首先，JoinOptimizer.java中的enumerateSubsets(List v, int size)方法将返回一个大小为v的所有子集的集合。这个方法对于大型集合来说效率非常低；你可以通过实现一个更有效的枚举器来获得额外的分数（提示：考虑使用原地生成算法和懒惰迭代器（或流）接口来避免物化整个幂集）。 第二，我们提供了方法computeCostAndCardOfSubplan。 123456private CostCard computeCostAndCardOfSubplan(Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; filterSelectivities, LogicalJoinNode joinToRemove, Set&lt;LogicalJoinNode&gt; joinSet, double bestCostSoFar, PlanCache pc) 给出一个连接的子集（joinSet），以及一个要从这个子集中移除的连接（joinToRemove），这个方法计算出将joinToRemove连接到joinSet-{joinToRemove}的最佳方法。它在一个CostCard对象中返回这个最佳方法，其中包括成本、cardinality和最佳连接顺序（作为一个列表）。如果找不到计划（因为，例如，没有可能的左深连接），或者如果所有计划的成本都大于bestCostSoFar参数，computeCostAndCardOfSubplan可能返回null。该方法使用了一个叫做pc（上面的psuedocode中的optjoin）的先前连接的缓存来快速查找joinSet的最快方式–{joinToRemove}。其他参数（stats和filterSelectivities）被传递到你必须实现的orderJoins方法中，作为练习4的一部分，下面会有解释。这个方法基本上是执行前面描述的假代码的第6-8行。 第三，我们提供了方法printJoins。 1234private void printJoins(List&lt;LogicalJoinNode&gt; js, PlanCache pc, Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; selectivities) 这种方法可以用来显示连接计划的图形表示（例如，当通过优化器的”-explain “选项设置 “explain “标志时）。 第四，我们提供了一个PlanCache类，可以用来缓存到目前为止在你的Selinger实现中所考虑的连接子集的最佳方式（使用computeCostAndCardOfSubplan需要这个类的一个实例）。 在JoinOptimizer.java中，实现方法orderJoins。 123List&lt;LogicalJoinNode&gt; orderJoins(Map&lt;String, TableStats&gt; stats, Map&lt;String, Double&gt; filterSelectivities, boolean explain) 这个方法应该在joins类成员上操作，返回一个新的List，这个List指定了应该进行的连接的顺序。这个列表中的第0项表示左深计划中最左、最底的连接。返回的列表中相邻的连接应该至少共享一个字段，以确保计划是左深的。这里stats是一个对象，让你找到出现在查询的FROM列表中的给定表名的TableStats。 filterSelectivities让你找到表的任何谓词的选择性；它保证在FROM列表中的每个表名有一个条目。最后，explain指定了你应该输出一个连接顺序的表示，以供参考。 你可能希望使用上面描述的辅助方法和类来帮助你实现。大致上，你的实现应该遵循上面的假设代码，通过子集大小、子集和子集的子计划进行循环，调用computeCostAndCardOfSubplan并建立一个PlanCache对象来存储执行每个子集连接的最小成本方式。 c. 实现目标 通过单元测试 JoinOptimizerTest 通过系统测试 QueryTest 5. *Bonus Exercisesa. 添加代码以执行更高级的连接心率估计 与其使用简单的启发式方法来估计连接的cardinality，不如设计一个更复杂的算法。 一种选择是在每对表t1和t2中的每对属性a和b之间使用联合直方图。这个想法是创建a的桶，对于a的每个桶A，创建一个与A中a值共同出现的b值的直方图。 另一种估计连接的cardinality的方法是假设小表中的每个值在大表中都有一个匹配的值。那么连接选择性的公式将是。1/(Max(num-distinct(t1, column1), num-distinct(t2, column2))）。这里，列1和列2是连接属性。连接的cardinality是t1和t2的cardinality乘以选择性的产物。 b. 改进子集迭代器 我们对enumerateSubsets的实现是相当低效的，因为它在每次调用时都会创建大量的Java对象。 在这个奖励练习中，你将提高enumerateSubsets的性能，这样你的系统就可以对有20个或更多连接的计划进行查询优化（目前这样的计划需要几分钟或几小时来计算）。 c. 一个考虑到缓存的成本模型 估计扫描和连接成本的方法没有考虑到缓冲池中的缓存。你应该扩展成本模型以考虑到缓存效应。这很棘手，因为由于迭代器模型，多个连接是同时运行的，所以可能很难预测使用我们在以前的实验中实现的简单缓冲池，每个人可以获得多少内存。 d. 改进的连接算法和算法选择 我们目前的成本估算和连接运算符选择算法（见JoinOptimizer.java中的instantiateJoin()）只考虑嵌套循环的连接。扩展这些方法以使用一个或多个额外的连接算法（例如，使用HashMap的某种形式的内存散列）。 e. Bushy plans 改进所提供的orderJoins()和其他辅助方法，以生成bushy joins。我们的查询计划生成和可视化算法完全能够处理繁忙的计划；例如，如果orderJoins()返回列表(t1 join t2; t3 join t4; t2 join t3)，这将对应于一个繁忙的计划，(t2 join t3)节点在顶部。","link":"/2023/12/04/SimpleDB-Lab3/"},{"title":"SimpleDB-Lab4","text":"0.实验目标在这个实验中，你将在SimpleDB中实现一个简单的基于锁的事务系统。你将需要在代码中的适当位置添加锁和解锁调用，以及跟踪每个事务所持有的锁的代码，并在需要时授予事务锁。 本文档的其余部分描述了添加事务支持所涉及的内容，并提供了一个关于如何将这种支持添加到你的数据库的基本概要。 Transactions outline事务事务是一组以原子方式执行的数据库操作(例如插入、删除和读取)，也就是说，要么所有的动作都完成了，要么一个动作都没有完成，而数据库的外部观察者并不清楚这些动作不是作为单个不可分割动作的一部分完成的。 ACID特性为了理解在SimpleDB中事务管理是如何工作的，接下来简要介绍它是如何满足ACID特性的： Atomicity：严格的两阶段锁以及缓冲区管理将确保原子性 Consistency：通过原子性来保证事务的一致性，在SimpleDB中并未使用其他一致性方法（如键约束） Isolation：严格的两阶段提交保证隔离性 Durability：强制缓冲区管理策略可确保持久性 两阶段锁通过上述ACID特性可以得知两阶段锁在其中扮演重要的角色，那么首先来了解下什么是两阶段锁。两阶段锁协议的主要内容如下： 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。在对任何数据进行读操作之前要申请获得S锁，在进行写操作之前要申请获得X锁。加锁不成功事务进入等待状态，直到加锁成功才成功继续执行。 在释放一个封锁之后，事务不再获得任何其他封锁；事务进入解锁阶段，在该阶段进行解锁操作不能再进行加锁操作。 两段锁的含义是事务分为两个阶段： 第一阶段是获得封锁，称为扩展阶段。 第二阶段称为释放阶段，也成为收缩阶段。 有如下三种两阶段锁： Basic 2PL：在事务过程中，分为获得锁和释放锁两个阶段 Strict 2PL：直到事务结束为止，都不释放获得的锁 Static 2PL：在事务开始前，获得所需的全部锁 两段封锁法可以这样来实现：事务开始后就处于加锁阶段，一直到执行ROLLBACK和COMMIT之前都是加锁阶段。ROLLBACK和COMMIT使事务进入解锁阶段，即在ROLLBACK和COMMIT模块中DBMS释放所有封锁。 Recovery and Buffer Management为了简化你的工作，建议实现一个非强制缓冲区管理策略： 如果页面被未提交的事务锁住，你不应该从缓冲池中丢弃脏页(更新脏页)。 事务提交后，应该强制将脏页刷新至磁盘(这就是强制策略)。 为了进一步简化实现，可以假设SimpleDB在处理“transactionComplete”命令时不会崩溃。注意本次实验不需要实现基于日志的崩溃恢复，也不需要撤销(undo)任何工作(不必丢弃脏页)并且也不需要重做(redo)任何工作(在提交时强制更新并且在提交事务期间不会崩溃)。 1. Granting Locksa. 要修改的文件 src/simpledb/BufferPool.java b. 实现说明 我们需要添加对SimpleDB的调用(例如在BufferPool中)，以允许调用方代表特定事务请求或释放特定对象上的(共享或独占)锁。 我们建议在页面粒度上锁，为了简化测试，不要实现表级锁定(即使可能)，本文档的其余部分和我们的单元测试假设页面级锁定。 我们需要创建数据结构来跟踪每个事务持有哪些锁，并检查是否应在请求时向事务授予锁。 我们需要实现共享锁和独占锁。回顾一下，这些锁的工作方式如下： 在事务进行读操作之前，它必须获得共享锁 在事务进行写操作之前，它必须获得独占锁 多个事务可以获取同一对象的共享锁 只有一个事务能获取对象的独占锁 如果事务t是持有对象o共享锁的唯一事务，t能够将持有的对象o的共享锁升级为独占锁(锁升级) 如果事务请求的锁不能立即被授予，你的代码应该锁住，直到锁可用(锁被不同线程的其他事务释放)；在锁实现中要注意争用条件——想想对锁的并发调用会如何影响行为。 c. 实现目标 编写BufferPool中获取和释放锁的方法。假设你使用的是页级锁，你将需要完成以下工作： 修改getPage()，使其在返回页面前阻塞并获得所需的锁。 实现unsafeReleasePage()。这个方法主要用于测试，以及在事务结束时使用。 实现 holdsLock()，以便练习2中的逻辑能够确定一个页面是否已经被事务锁定。 你可能会发现，定义一个LockManager类来负责维护事务和锁的状态是很有帮助的，但设计决定权在你。 通过单元测试LockingTest（需要完成下一个练习）。 务期间不会崩溃)。 2. Lock Lifetimea. 要修改的文件 src/simpledb/BufferPool.java b. 实现说明 你将需要实现严格的两阶段锁。这意味着事务在访问任何对象之前应该获得相应类型的锁，并且在事务提交之前不应该释放任何锁。 幸运的是，SimpleDB的设计是这样的：在你读取或修改页面之前，有可能在BufferPool.getPage()中获得页面的锁。因此，我们建议在getPage()中获取锁，而不是在你的每个操作中添加对锁程序的调用。根据你的实现，你有可能不需要在其他地方获取锁。这要靠你自己去验证! 你需要在读取任何页面（或元组）之前获得一个共享锁，你需要在写入任何页面（或元组）之前获得一个独占锁。你会注意到，我们已经在BufferPool中传递了许可对象；这些对象表明调用者希望对被访问对象拥有的锁的类型（我们已经给了你许可类的代码。） 请注意，你对HeapFile.insertTuple()和HeapFile.deleteTuple()的实现，以及HeapFile.iterator()返回的迭代器的实现应该使用BufferPool.getPage()访问页面。仔细检查这些getPage()的不同用法是否传递了正确的权限对象（例如，Permissions.READ_WRITE 或 Permissions.READ_ONLY）。你也可以仔细检查你实现的BufferPool.insertTuple()和BufferPool.deleteTupe()是否在它们访问的任何页面上调用markDirty()（你在实验2中实现这段代码时应该这样做，但我们没有测试这种情况）。 在你获得锁之后，你也需要考虑何时释放它们。很明显，你应该在一个事务提交或中止后释放所有与之相关的锁，以确保严格的2PL。然而，在其他情况下，在事务结束前释放锁可能是有用的。例如，你可以在扫描页面找到空槽后释放一个共享锁（如下所述）。 确保你在整个SimpleDB获得和释放锁。一些（但不一定是全部）你应该验证的操作正常工作： 在SeqScan过程中从页面上读取 tuple（如果你在BufferPool.getPage()中实现了锁定，只要你的HeapFile.iterator()使用BufferPool.getPage()，这应该可以正确工作。） 通过BufferPool和HeapFile方法插入和删除图元（如果你在BufferPool.getPage()中实现了锁，只要HeapFile.insertTuple()和HeapFile.deleteTuple()使用BufferPool.getPage()，这应该能正确工作。） 你还需要特别考虑在以下情况下获取和释放锁的问题： 向HeapFile添加一个新的页面。你什么时候把这个页面写到磁盘上？是否存在与其他事务（在其他线程上）的竞赛条件，可能需要在HeapFile级别上特别注意，而不考虑页级锁定？ 寻找一个可以插入图元的空槽。大多数实现都会扫描页面，寻找一个空槽，并且需要一个READ_ONLY锁来完成这个工作。然而，令人惊讶的是，如果一个事务t发现页面p上没有空槽，t可以立即释放p上的锁。虽然这显然与两阶段锁的规则相矛盾，但它是可以的，因为t没有使用页面上的任何数据，这样，一个更新p的并发事务t’不可能影响t的答案或结果。 c. 实现目标 通过单元测试LockingTest。 3. Implementing NO STEALa. 要修改的文件 src/simpledb/BufferPool.java b. 实现说明 一个事务的修改只有在它提交之后才会被写入磁盘。这意味着我们可以通过丢弃脏页并从磁盘重读来中止一个事务。因此，我们必须不驱逐脏页。这个策略被称为NO STEAL。 你将需要修改BufferPool中的evictPage方法。特别是，它必须永远不驱逐一个脏页。如果你的驱逐策略倾向于驱逐一个脏页，你将不得不找到一种方法来驱逐一个替代页。在缓冲池中的所有页面都是脏的情况下，你应该抛出一个DbException。如果你的驱逐策略驱逐了一个干净的页面，要注意事务可能已经持有被驱逐的页面的任何锁，并在你的实现中适当地处理它们。 需要在BufferPool的evictPage方法中实现必要的页面驱逐逻辑，而不驱逐脏页。 c. 实现目标4. Transactionsa. 要修改的文件 src/simpledb/BufferPool.java b. 实现说明 在SimpleDB中，每次查询开始时都会创建一个TransactionId对象。这个对象被传递给每个参与查询的操作者。当查询完成后，BufferPool方法 transactionComplete被调用。 调用此方法可以提交或中止事务，由参数标志commit指定。在其执行过程中的任何时候，操作者都可以抛出一个TransactionAbortedException异常，这表明发生了内部错误或死锁。我们为你提供的测试案例创建了适当的TransactionId对象，以适当的方式将它们传递给你的操作者，并在查询完成后调用 transactionComplete。我们还实现了TransactionId。 需要在BufferPool中实现transactionComplete()方法。 请注意，transactionComplete有两个版本，一个是接受额外的布尔提交参数，另一个是不接受。没有额外参数的版本应该总是提交，所以可以简单地通过调用 transactionComplete(tid, true) 来实现。 当commit时，你应该将与事务相关的脏页冲到磁盘上。当abort的时候，你应该通过恢复页面到磁盘上的状态来恢复事务所做的任何改变。 无论事务是提交还是中止，你都应该释放BufferPool保存的关于该事务的任何状态，包括释放该事务持有的任何锁。 c. 实现目标 通过单元测试TransactionTest和AbortEvictionTest TransactionTest需要下一个练习完成 5. Deadlocks and Abortsa. 要修改的文件 src/simpledb/BufferPool.java b. 实现说明 SimpleDB中的事务有可能出现死锁（如果你不明白为什么，我们建议阅读Ramakrishnan &amp; Gehrke中关于死锁的内容）。你需要检测这种情况并抛出一个TransactionAbortedException。 有很多死锁检测的方法，例如，实现一个简单的超时策略，如果事务在给定时间段后还没有完成，它将中止事务。 对于真实的场景，我们可以在依赖关系图数据结构中实现循环检测。在这个方案中，我们将定期或每当尝试授予新锁时检查依赖关系图中的周期，如果存在周期，则中止某些操作。如果检测到死锁的存在，我们必须解决死锁。假设当事务t等待锁时检测到死锁的存在，中止t正在等待的所有事务；这可能导致大量工作被撤销，但可以保证t会取得进展。或者，我们可以中止t，以使其他事务有机会取得进展。这意味最终用户必须重试事务t。 另一种方法是使用事务的全局排序来避免建立等待图。出于性能方面的考虑，这有时是首选，但是在这种方案下，本来可以成功的事务可能会被错误地中止。例子包括WAIT-DIE和WOUND-WAIT方案。 现死锁检测或预防。对于你的死锁处理系统，你有很多设计决定，但没有必要做一些非常复杂的事情。我们希望你能做得比每个事务的简单超时更好。一个好的起点是在每个锁请求前的等待图中实现周期检测，这样的实现将得到全额奖励。请在实验报告中描述你的选择，并列出你的选择与其他选择相比的优点和缺点。 你应该通过抛出TransactionAbortedException异常来确保你的代码在发生死锁时正确中止事务。这个异常将被执行事务的代码所捕获（例如，TransactionTest.java），它应该调用 transactionComplete() 来清理事务。我们不期望你自动重启一个因死锁而失败的事务–你可以假设更高级别的代码会处理这个问题。 我们在test/simpledb/DeadlockTest.java中提供了一些（不是单元的）测试。它们实际上有点复杂，所以它们可能需要超过几秒钟的时间来运行（取决于你的策略）。如果它们似乎无限期地挂起，那么你可能有一个未解决的死锁。这些测试构建了简单的死锁情况，你的代码应该能够逃脱。 注意，在DeadLockTest.java的顶部附近有两个计时参数；这些参数决定了测试检查是否已经获得锁的频率，以及中止的事务被重新启动前的等待时间。如果你使用基于超时的检测方法，你可以通过调整这些参数观察到不同的性能特征。测试将把解决死锁对应的TransactionAbortedExceptions输出到控制台。 在这一点上，你应该有一个可恢复的数据库，也就是说，如果数据库系统崩溃（在 transactionComplete() 以外的地方），或者如果用户显式地中止一个事务，那么在系统重新启动（或者事务中止）之后，任何正在运行的事务的影响将不可见。 你可能希望通过运行一些事务和显式地杀死数据库服务器来验证这一点。 c. 实现目标 通过TransactionTest系统测试（根据实现，它也可能运行相当长的时间） 小结 参考MIT 6.830数据库系统，将等待时间修改为原本十分之一 execution中Delete和Insert原本没有正确使用TransactionId，做更正 BufferPool中加入LockManager类型（自定义）的lockManager，用于管理锁，提供加锁、解锁等方法；加入Map&lt;TransactionId, List&lt;Page&gt;&gt;类型的tidToPagesMap，将事务id映射到对应的Page。 在getPage()中，根据Permissions来判断需要加锁的类型，并调用lockManager进行获取锁。若类型为Permissions.READ_WRITE，则将该Page添加到tid事务相关的PageList中。 unsafeReleasePage()调用lockManager的对应方法。 transactionComplete()中，若commit事务，则将事务涉及的Page都刷新到磁盘；否则，回滚事务，重新从磁盘中读取对应的Page。 在insertTuple()和deleteTuple()中，更新tidToPagesMap，将涉及到的Page加入到对应事务id。 flushPages()通过tidToPagesMap，将传入的事务id对应的Page刷新到磁盘。 更新evictPage()方法，每次淘汰不脏的Page。若均为脏页，则抛出异常。 测试结果截图：","link":"/2023/12/08/SimpleDB-Lab4/"},{"title":"SimpleDB-Lab5","text":"0.实验目标在这个实验中，你将实现一个B+树形索引，用于高效的查找和范围扫描。我们为你提供了实现树形结构所需的所有底层代码。你将实现搜索、拆分页面、在页面之间重新分配 tuple 以及合并页面。 B+树的内部节点拥有多条记录，每个节点的内容包括节点当前值、以及左右子树的指针；相邻键之间共享一个孩子指针，所以拥有m个键的内部节点通常拥有m+1个孩子指针。叶子节点可以包括数据记录或者指向其他数据库文件的指针。为了简单起见，我们实现的B+树的叶子节点只包括数据记录。相邻的叶子页通过左右同级指针链接在一起，因此范围扫描只需要通过根节点和内部节点进行一次初始搜索即可找到第一个叶子页，后续叶子页通过右(或者左)指针找到。 B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。 B+树相邻的叶子节点之间是通过链表指针连起来的 B+树中，内部节点与其父节点的key值不能重复，叶子节点与其父节点的key值可以重复 下面这幅图是SimpleDB B+ tree这部分整体架构组织图（来源：MIT 6.830数据库系统）磁盘上Header Page是懒初始化的，因此出现的位置是不固定的，Internal Page和Leaf Page同样如此，之所以可以这样，是因为存在一个root ptr page,它起到的作用就类似文件系统中的超级块: 我们应该在lab4的基础上开始本次实验代码的编写，此外，报告中还为本次实验提供了额外的源码和测试文件 搜索B+树的单值查询 当查询key=70的节点时，首先从读取根节点，判断得key&lt;75； 然后读取根节点的左孩子节点，将70依次与左孩子节点中的值进行比较，判断得key&gt;66； 则读取66的右孩子节点，key存储于该叶节点中，读取其中的数据。 B+树的范围查询 当要读取[68,100]范围内的数据时，首先找到第一个大于等于68的节点，然后在叶节点中向后遍历。 查看index目录下的BTreeFile.java文件，这是实现B+树的核心文件，你将会在该文件为本次实验编写所有代码。不像HeapFile，BTreeFile包含四种不同的页。正如你期望的那样，树的结点有两种不同类型的页面：叶子节点和非叶子节点。 非叶子节点在BTreeInternalPage.java中实现，叶子节点在BTreeLeafPage.java中实现。为了方便起见，BTreePage.java中已经创建了包含叶子节点和非叶子结点共同特性的抽象类。此外，header pages在BTreeHeaderPage.java中实现并且追踪文件中的哪个页面是被使用的。 最后，在每个BTreeFile开始都有一个指向树的根页和第一个header page的页；该单独的页在BTreeRootPtrPage.java中被实现。熟悉这些类的接口，尤其是BTreePage、BTreeInternalPage和BTreeLeafPage。在实现B+树的过程中需要使用它们。 1. BTreeFile.findLeafPage()a. 要修改的文件 src/simpledb/index/BTreeFile.java b. 实现说明 我们的第一个任务就是实现BTreeFile.java中的findLeafPage()函数，该函数通过给定的键查找合适的叶子页，主要用于搜索和插入。例如，假设我们提供了包含两个叶子页的B+树(如图1所示)，根节点是一个包含一个键和两个孩子结点指针的内部结点。给定键值1，该函数应该返回第一个叶子结点；同样地，给定键值8，该函数应该返回第二个结点。不太明显的情况是，我们给定键值6，可能存在重复的键，因此两个页结点上可能都包含键6对应的元组。在这种情况下，函数应该返回第一个叶子节点。 我们实现的findLeafPage()函数应该递归的搜索内部节点，直到它到达给定键值对应的叶子页。为了在每阶段找到合适的叶子页，我们应该迭代遍历内部节点的记录斌给比较记录与给定的键值的大小，以确定下一步往哪个方向走。BTreeInternalPage.iterator（）使用在BTreeEntry.java中定义的接口提供对内部页面中条目的访问。该迭代器允许我们遍历内部节点的键值，并且访问每个键的左右孩子页指针。当传入的BTreePageId的pgcateg()方法返回值与BTreePageId.LEAF相等时，表明这是一个叶子页。在这种情况下，我们仅需要从缓冲池中获取该页并返回它即可，不需要确保它实际上包含提供的键值f。 当提供的键值是null时，findLeafPage()方法必须处理这种情况。如果给定的值是空的，那么在递归的过程中就遍历最左侧的孩子节点，最终返回最左侧的叶子页。查找最左侧的叶子也对于扫描记录文件非常有用。当查找到正确的叶子页时，我们应该返回它。正如上面提到的那样，我们可以通过pgcateg()方法检查叶子也的类型。我们可以假设只有叶子页和内部节点才会被传递给该函数。 与其直接调用BufferPool.getPage()方法来获取每个内部页面和叶子页，建议调用代码中的包装函数BTreeFile.getPage()。它像BufferPool.getPage()那样工作，但是提供额外的参数去追踪脏页。在接下来的两个练习中，该函数非常重要，在这两个练习中，我们需要实际更新数据，因此需要追踪脏页。 findLeafPage()实现访问的每个内部（非叶）页面都应使用只读权限获取，但返回的叶页面除外，返回的叶页面应使用作为函数参数提供的权限获取。这些权限级别对于本实验室来说并不重要，但对于代码在未来的实验室中正常运行来说，它们将非常重要。 c. 实现目标 通过BTreeFileReadTest.java中的所有单元测试 通过BTreeScanTest.java中的系统测试。 d. 实现记录 查找值为field的元组所在的叶子Page：findLeafPage() 若为叶子Page则直接返回。若field为空，则查找最左的叶子Page。递归查找，非叶子Page访问均加读锁，叶子Page访问加写锁。 2. Splitting Pagesa. 要修改的文件 src/simpledb/index/BTreeFile.java b. 实现说明 为了保证B+树中存储元组的顺序性并且保持B+树的完整性，我们必须将元组插入到包含键范围的叶子页中。正如我们上面提到的，findLeafPage()方法被用于寻找我们应该插入元组的正确的叶子页。但是，每个页都有槽数的限制，即使对应的叶子页已满我们也需要能向其中插入元组。 尝试向已满的叶子页插入元组会导致页分裂，以便元组平均地分布到两个新页中。叶子页的每次分裂，都需要将第二页中的第一个元组对应的新条目添加到父节点。有时，内部节点也可能已满，无法接受新条目。在这种情况下，父节点应该分裂并且向它的父节点添加一个新纪录。这可能导致递归地分裂并且最终创建一个新的根节点 在本次练习中，我们需要实现BTreeFile.java中的splitLeafPage()和splitInternalPage()方法。如果被分裂的页是根节点，我们需要创建一个新的内部节点作为新的根节点，并且更新BTreeRootPtrPage。否则，我们需要通过READ_WRITE权限读取父页面，如果有必要就递归地进行分裂，并且添加新记录。你会发现getParentWithEmptySlots()函数对于处理这些不同的情况非常有用。在splitLeafPage()方法中我们应该将键复制到父页，而在splitInternalPage()方法中，应该将键推到父页(如图2所示)。记住根据需要更新新页的父指针(为了简单起见，图2没有展示父指针)。 分裂叶节点时，节点中的key值复制到父节点中（即叶节点和内部节点可以有相同的值） 当一个内部节点被分裂时，我们需要更新被移动的孩子页的父指针。你会发现updateParentPointers()对于这非常有用。此外，记住更新被分裂的叶子页的兄弟指针。最后，返回应该插入新元组或记录的页面，如提供的键字段所示。(提示：不必担心提供的键实际上可能位于要拆分的元组/条目的正中心。应该在拆分期间忽略该键，只使用它来确定返回两个页面中的哪一个) 分裂内部节点时，是将节点中的key值“挤到”父节点中（即内部节点之间的key值不能重复） 无论何时创建新页面，无论是因为拆分页面还是创建新的根页面，都可以调用getEmptyPage()来或取新页面。这个函数是一个抽象函数，它允许我们重用由于合并而被删除的页面。 我们期望使用BtreeAppPage.iterator()和BTreeInternalPage.iterator()与叶和内部页面交互，以迭代每个页面中的元组/条目。为了方便起见，源码中提供了这两种类型页面的反向迭代器： BTreeLeafPage.reverseIterator() 和 BTreeInternalPage.reverseIterator()。 对于将页中元组/条目的子集移动到其右侧兄弟节点的任务来说，这些反向迭代器非常有用。 如上所述，内部页面迭代器使用BTreeEntry.java中定义的接口，该接口有一个键和两个孩子指针。它也包含一个recordId，用于标识基础页面上键和孩子指针的位置。我们认为一次处理一个条目是与内部页面交互的自然方式，但重要的是要记住，底层页面实际上并不存储条目列表，而是存储m键和m+1子指针的有序列表。由于BTreeEntry只是一个接口，而不是实际存储在页面上的对象，因此更新BTreeEntry的字段不会修改底层页面。为了修改页面上的数据，需要调用BTreeInternalPage.updateEntry()方法。另外，删除一个记录实际上仅仅删除了键和孩子指针，因此源码提供了BTreeInternalPage.deleteKeyAndLeftChild()和BTreeInternalPage.deleteKeyAndRightChild()函数来实现这一点。记录的recordId用于查找被删除的键和孩子指针。插入记录也仅仅插入键和孩子指针(除非它是第一条记录)，所以BTreeInternalPage.insertEntry()检查所提供的记录中的一个孩子指针是否与页面上现有的孩子指针重叠，并且在该位置插入条目将使键保持排序顺序 在splitLeafPage()和splitINternalPage()方法中，需要使用任何新创建的页面以及由于新指针或新数据而修改的页面来更新dirtypages集合。这是BTreeFile.getPage()派上用场的地方，每次获取页面时，BTreeFile.getPage()都会检查页面是否已经存储在本地缓存中，如果本地缓存中找不到请求的页面，则会从缓冲池中获取该页面。BTreeFile.getPage()如果使用读写权限获取页面，也会将页面添加到dirtypages缓存中，因为它们可能很快就会被弄脏。这种方法的一个优点是，如果在一个元组插入或删除过程中多次访问相同的页面，则可以防止更新丢失。 请注意，与HeapFile.insertTuple()不同的是，BTreeFile.insertTuple()可能会返回大量脏页，特别是在拆分任何内部页的情况下。您可能还记得以前的实验，返回脏页集是为了防止缓冲池在刷新脏页之前逐出脏页 Warning:B+树是一种复杂的数据结构，在修改B+树之前了解每个合法的B+树的必要属性很有帮助： 如果一个父节点指向孩子节点，那么孩子节点必须指向同一个父节点 如果叶子节点指向右侧兄弟节点，那么右侧兄弟节点也需要指向左边这个兄弟节点 第一个叶子和最后一个叶子节点必须分别指向null 记录ID必须与它们实际属于的页匹配 具有非叶子节点的节点中key必须大于左子节点中的任何key，小于右子节点中的任何key 具有叶子节点的节点中key必须大于等于左孩子的所有key，小于等于右孩子的所有key 节点孩子或为非叶子节点、或为叶子节点 每个节点最多只有m个子节点，非叶子节点具有至少⌈m/2⌉子节点 在BTreeChecker.java中已经实现了检查上述属性的机制，该方法也用于在 systemtest/BTreeFileDeleteTest.java中测试我们的B+树实现，可以随意添加对该函数的调用，以帮助调试 注意 checker方法应始终在树初始化之后、开始和完成对键插入或删除的完整调用之前和之后通过，但不一定在内部方法中通过。 树可能格式正确(因此通过checkRep())，但仍然可能不正确。例如，空树始终会通过checkRep()方法，但可能并不总是正确的(如果刚刚插入元组,则树不应该为空) c. 实现目标 通过BTreeFileInsertTest.java中的单元测试。 通过 systemtest/BTreeFileInsertTest.java 中的系统测试。 系统测试可能要花费几秒钟才能完成，这些文件会测试我们代码中插入元组和分裂也的正确性，并且处理重复的元组。 d. 实现记录 分裂Page：splitLeafPage()和splitInternalPage() 为了保证增加节点后，B+树的高度不会太高，当Page中节点超过阈值时需要将Page中的元组分裂到一个新的Page中。方法返回加入的filed所在的Page。 使用倒序遍历，将原本Page中右边一半的元组加入到新的Page中。叶子Page需要更新左右兄弟指针，并向父Page插入新Page中的第一个元组；非叶子Page需要将分裂后左边Page的最后一个元组挤入父Page。之后更新脏页中的孩子指针，并记录脏页。 3. Redistributing pagesa. 要修改的文件 src/simpledb/index/BTreeFile.java b. 实现说明 为了保持树的平衡并且不浪费不必要的空间，B+树的删除操作可能会导致页重新分配元组，最终导致页合并: 如果试图从小于半满的叶子页中删除元组的话，则会导致该页面从其兄弟节点中窃取元组或与其兄弟节点中的一个合并。如果页面的兄弟节点有多余的元组，则元组应该均匀分布在两个页面之间，并且父级条目应该进行更新(如图3)。但是，如果兄弟节点也是半满(如图4)，那么应该合并两个页，并且删除父节点的记录。反过来，从父节点中删除记录也可能导致父节点半满，在这种情况下，父节点应该从它的兄弟节点中窃取记录或者与他的兄弟节点合并。这可能会导致递归地合并，如果根节点的最后一个记录被删除的话，那么最终会删除根节点。 在接下来的练习中我们需要实现BTreeFile.java中stealFromLeafPage(),stealFromLeftInternalPage(), stealFromRightInternalPage(),mergeLeafPages() 和mergeInternalPages() 方法。在前三个函数中，如果兄弟节点有多余的元组/记录，那么我们需要实现均匀地再分布元组/记录。记住更新父节点中相应的key(仔细看图3).在stealFromLeftInternalPage()/stealFromRightInternalPage()方法中，我们需要更新已经被移动的孩子的父节点。我们可以重用updateParentPointers()方法。 c. 实现目标 通过BTreeFileDeleteTest.java中的一些单元测试（如testStealFromLeftLeafPage和testStealFromRightLeafPage）。 d. 实现记录 使兄弟Page的元组数均分：stealFromLeafPage()和stealFromLeftInternalPage()和stealFromRightInternalPage() 是为了删除节点后，若当前节点不满足Page中最小元组数，则需要看兄弟是否有多余的，如果有，可以直接向兄弟节点借；若没有，则需要合并结点。 从兄弟节点中借siblingNumTuples - (pageNumTuples + siblingNumTuples) / 2个元组。若向左兄弟借，则对左兄弟进行倒序遍历；右兄弟则进行正向遍历。最后需要更新entry中的key值，并调用parent.updateEntry()、updateParentPointers()更新。 void stealFromLaefPage() 计算要steal的元组数（使其和兄弟Page中最终的元组数一致） 左兄弟从最后开始遍历，右兄弟从最左开始遍历 不断从兄弟Page中取出元组，插入到本Page 更新entry中的key值为较右Page中的第一个元组 调用parent.updateEntry(entry)更新parent信息 BTreeEntry中有一个Field类型的key和两个BTreePageId类型的child，以及一个RecordId类型的rid，可以看做B+树中非叶子节点的一个单元，每个单元保存key值并且指向两个孩子节点。BTreeEntry为InternalPageIterator遍历的单位，实际Page中没有保存这样一个结构。BTreeInternalPage中保存的是keys和children。 updateEntry()是通过传入的BTreeEntry来更新本Page中的keys和children信息。 stealFromLaefPage()中传入的参数entry代表的是兄弟节点和本节点所对应的父节点的entry，也就是其key为父节点中的key，两个child分别指向兄弟和自己。因此，steal完成后，对entry进行更新，指针和对应的rid（即PageId和该entry在该Page的位置）都不需要改变，只需要更新key。 void stealFromLeftInternalPage() 计算要steal的元组数（使其和兄弟Page中最终的元组数一致） 左兄弟从最后开始遍历 先将父Page中的entry插入本Page，更新孩子节点指针 不断从兄弟Page中取出元组，插入到本Page 之后更新父Page的entry，将左Page中的最后一个元组的key给父entry，调用parent.updateEntry(entry)更新parent信息 最后调用updateParentPointers，更新本Page中所有entry的父节点信息，保证子节点的parent都指向本Page。 void stealFromRightInternalPage() 基本与上相同，右兄弟从头开始遍历 4. Merging pagesa. 要修改的文件 src/simpledb/index/BTreeFile.java b. 实现说明 在mergeLeafPages()和mergeInternalPages()方法中，我们需要编写合并页的代码，有效地执行splitLeafPage()和splitInternalPage()相反操作。deleteParentEntry方法在处理不同的递归情况时非常有用。确保在删除页时调用setEmptyPage()方法以使它们可以被重用。与前面的练习相似，这推荐使用BTreeFile.getPage()方法获取页面并使脏页列表保持最新。 实现BTreeFile.mergeLeafPages()和BTreeFile.mergeInternalPages()。 c. 实现目标 通过BTreeFileDeleteTest.java中的所有单元测试。 通过systemtest/BTreeFileDeleteTest.java中的系统测试。 d. 实现记录 合并两个Page：mergeLeafPages()和mergeInternalPages() 将左Page中的元组全部加入到右Page，修改左右Page的兄弟指针，最后调用setEmptyPage()将右Page置空，并删除parentEntry。 void mergeLeafPages() 将rightPage中的所有元组插入到leftPage中 修改leftPage和rightPage右边的Page的兄弟指针 调用setEmptyPage()将rightPage置空 调用deleteParentEntry()删除父entry void mergeInternalPages() 先将父entry插入到leftPage 再将rightPage中的所有元组插入到leftPage中 调用setEmptyPage()将rightPage置空 调用deleteParentEntry()删除父entry 最后调用updateParentPointers，更新leftPage中所有entry的父节点信息 5. 事务 通过next-key lock，B+树可以防止在两次连续范围扫描之间出现幻读的问题。由于SimpleDB使用页面级、严格的两阶段锁定，因此如果B+树实现正确的话，那就可以有效地防止幻读发生。因此，我们的B+树实现代码应该通过BTreeNextKeyLockingTest测试. 此外，如果我们在B+树代码中正确地实现锁，那么我们的代码也应该通过单元测试test/simpledb/BTreeDeadlockTest.java 如果所有练习都正确地实现，那么我们应该能够通过BTreeTest系统测试。通过该测试可能需要几分钟的时间。 6. Bonus Exercise 创建并实现一个名为BTreeReverseScan的类，该类在给定一个可选的IndexPredicate后，反向扫描BTreeFile。 你可以使用BTreeScan作为起点，但你可能需要在BTreeFile中实现一个反向迭代器。你也可能需要实现一个单独的BTreeFile.findLeafPage()版本。我们已经在BTreeLeafPage和BTreeInternalPage上提供了反向迭代器，你可能会发现它很有用。你还应该编写代码来测试你的实现是否正常工作。BTreeScanTest.java是一个寻找思路的好地方。 小结 BTreePage中有4种Page，分别为BTreeRootPtrPage、BTreeHeaderPage、BTreeLeafPage和BTreeInternalPage。其中，BTreeLeafPage为叶子节点，BTreeInternalPage为非叶子结点。 一个表中一个Field对应一个B+树，BTreeRootPtrPage中的root指向根节点。BTreeRootPtrPage只保存9个字节的信息，共3个属性：root为根节点对应的page number，rootCategory为根节点的类型（中间节点或叶子节点），header为BTreeHeaderPage对应的page number。 getParentWithEmptySlots中，若parentId.pgcateg()为ROOT_PTR，说明是根节点需要访问其父节点，也就是parentId无法直接获取到对应的Page，因此需要新建一个空节点，作为根节点的父节点，再返回这个新的节点。 BTreeHeaderPage为Header，多个Header组成一个Header链表，通过prevPage和prevPage可以获取到下一个HeaderPage。BTreeRootPtrPage中的header指向第一个HeaderPage的page number。Header除了指向上一个和下一个HeaderPage的指针外，其余空间全部用于位图，与HeapPage相同，每一bit都指明该tuple是否为空。 位图中tuple的顺序是物理存储的顺序，但是不是查找时的逻辑顺序。 原本BufferPool、TableStats等文件中，会将Page强转为HeapPage（或DbFile强转为HeapFile），在使用B+树存储时不适用。因此取消强转，需要时直接调用B+树的相关方法。 测试结果：","link":"/2023/12/14/SimpleDB-Lab5/"},{"title":"SimpleDB-Lab6","text":"0.实验目标在本实验中，我们将要实现基于日志的中止回滚和崩溃恢复。源码中提供了定义日志格式的代码，并在事务期间的适当时间将记录附加到日志文件中。我们将使用日志文件的内容完成回滚和恢复。 源码中提供的日志代码产生了用于物理上整页undo和redo的记录。当页是首次读入时，代码记住了整页的原始内容做为前置镜像。当事务更新页时，相应的日志记录包含已存储的前置镜像以及修改后的页面做为后置镜像。我们将使用前置镜像在中止期间进行回滚，在recovery期间undo丢失的事务，后置镜像用于在recovery期间redo成功的事务。 我们可以不做整个页面的物理撤销(那么ARIES必须做逻辑撤销)，因为我们正在做页面级别的锁定，并且因为我们没有索引，在撤销时索引的结果可能与最初编写日志时的结构不同。页面级锁定简化事情的原因是，如果一个事务修改了一个页面，那么它一定有一个排他锁，这意味着没有其他事务同时修改它，因此我们可以通过覆盖整个页面来撤销对它的修改。 BufferPool已经实现了通过删除脏页来中止事务，并且通过强制在提交时将脏页刷新至磁盘来假装实现原子提交。日志允许更加灵活的缓冲区管理(STEAL &amp; NO-FORCE)，测试代码会在特定的时机调用BufferPool.flushAllPages()方法来验证这种灵活性。 1. LogFile.rollback()a. 要修改的文件 src/simpledb/storage/LogFile.java b. 实现说明 steal/no-force策略 lab6要实现的是simpledb的日志系统，以支持回滚和崩溃恢复；在lab4事务中，我们并没有考虑事务执行过程中，如果机器故障或者停电了数据丢失的问题，bufferpool采用的是no-steal/force的策略，而这个实验我们实现的是steal/no-force策略，两种策略的区别如下: steal/no-steal: 是否允许一个uncommitted的事务将修改更新到磁盘 如果是steal策略，那么此时磁盘上就可能包含uncommitted的数据，因此系统需要记录undo log，以防事务abort时进行回滚（roll-back）。 如果是no steal策略，就表示磁盘上不会存在uncommitted数据，因此无需回滚操作，也就无需记录undo log。 force/no-force: force策略表示事务在committed之后必须将所有更新立刻持久化到磁盘，这样会导致磁盘发生很多小的写操作（更可能是随机写）。 no-force表示事务在committed之后可以不立即持久化到磁盘， 这样可以缓存很多的更新批量持久化到磁盘，这样可以降低磁盘操作次数（提升顺序写），但是如果committed之后发生crash，那么此时已经committed的事务数据将会丢失（因为还没有持久化到磁盘），因此系统需要记录redo log，在系统重启时候进行前滚（roll-forward）操作。 日志格式和检查点 simpleDB日志相关逻辑主要集中在LogFile中，本节我们来看看simpleDB中几种日志格式和checkpoint机制。 log file的格式如下所述: 开头checkpoint指向最新的CHECK_POINT类型的记录。之后均为记录。记录共有五种类型，分别为BEGIN_RECORD、UPDATE_RECORD、COMMIT_RECORD、ABORT_RECORD和CHECK_POINT。 所有记录都有type、tid和offset这三个字段。UPDATE_RECORD还有前置镜像before image和后置镜像after image，分别用于回滚和更新磁盘中的Page。CHECK_POINT中还有记录活跃事务的数量，并记录每个活跃事务的tid和该事务第一条记录的偏移量。（活跃事务指的是截至当前CHECK_POINT时刻，还没有成功commit或abort的事务） 注：图片参考MIT 6.830数据库系统，对原图进行一些修正。 c. 实现目标 通过LogTest系统测试的TestAbort和TestAbortCommitInterleaved子测试。 d. 实现记录 回滚：rollback(tid) LogFile中有成员变量tidToFirstLogRecord，将tid映射到该事务第一条记录的偏移量。因此可以获取到事务第一条记录。遍历之后的所有记录，若为UPDATE_RECORD，并且是该事物的记录，则将before image写入磁盘对应Page（将最后一条更新记录写入）。 2. LogFile.recover()a. 要修改的文件 src/simpledb/storage/LogFile.java b. 实现说明 redo log与undo log 为了支持steal/no-force策略，即我们可以将未提交事务的数据更新到磁盘，也不必在事务提交时就一定将修改的数据刷入磁盘，我们需要用日志来记录一些修改的行为。在simpledb中，日志不区分redo log和undo log，格式较为简单，也不会记录事务执行过程中对记录的具体修改行为。 对于redo log，为确保事务的持久性，redo log需要事务操作的变化，simpledb中用UPDATE格式的日志来保存数据的变化，在每次将数据页写入磁盘前需要用logWrite方法来记录变化： 1public synchronized void logWrite(TransactionId tid,Page before,Page after) 这样，对于这些脏页，即使断电丢失数据了，我们也可以通过事务id来判断事务是否已经提交（这里提交事务会记录另一种格式的日志），如果事务已经提交，则重启时根据日志的内容就可以把数据恢复了；总而言之，通过这样的方式，可以让simpledb支持崩溃恢复； 对于undo log，我们采用的是在page中使用一个变量oldData保存一份当前页旧的快照数据： 1234567891011121314public abstract class BTreePage implements Page { ... protected byte[] oldData;}public class BTreeRootPtrPage implements Page { ... private byte[] oldData;}public class HeapPage implements Page { ... byte[] oldData;} 数据页一开始的旧数据是空的，那什么时候会对旧数据进行更新呢？答案是事务提交时，当事务提交时，就意味着这个修改已经是持久化到磁盘了，新的事务修改后就数据页的数据就是脏数据了，而在新事务回滚时，由于我们采用的是steal策略，脏页可能已经在页面淘汰时被写入磁盘中了，那么该如何进行恢复呢？答案是before-image，即oldData，通过上一次成功事务的数据，我们可以恢复到事务开始前的样子，这样，就可以实现了事务的回滚了。 c. 实现目标 通过所有的LogTest系统测试。 d. 实现记录 恢复：recover() 从开头checkpoint获取最新的CHECK_POINT，遍历之后的所有记录（checkpoint为-1就从头遍历）。COMMIT_RECORD中记录着提交的tid，UPDATE_RECORD中记录着前置镜像before image和后置镜像after image。若事务已提交（出现在COMMIT_RECORD），则将磁盘Page更新为after image；否则回滚为before image。 活跃事务需要另外处理，若活跃事务没有提交，则需要将其回滚为before image。 小结 测试结果：","link":"/2023/12/22/SimpleDB-Lab6/"},{"title":"SimpleDB项目总览","text":"背景 课程：6.830/6.814: Database Systems Lab：simple-db-hw-2021 实现说明 添加了中文文档 将项目改为使用maven构建 master分支下为实验源代码，dev分支下为自己实现代码 github链接：https://github.com/0Heeee/SimpleDB/ 具体实现过程可见博客： SimpleDB项目总览 SimpleDB-Lab1 SimpleDB-Lab2 SimpleDB-Lab3 SimpleDB-Lab4 SimpleDB-Lab5 SimpleDB-Lab6 所有测试均通过： SimpleDB 项目总览1. 组成部分 代表字段（fields）、元组（tuples）和元组模式（tuple schemas）的类。 对Tuple应用谓词和条件的类。 一个或多个访问方法（例如，堆文件），能够将关系存储在磁盘上，并可以遍历这些关系的Tuple。 一个操作者类的集合（例如，选择、连接、插入、删除等），用于处理Tuple。 一个缓冲池，用于缓存内存中的active Tuple和Page，并且处理并发控制和事务（在实验1中不需要担心这两点）。 一个 catalog ，用于存储关于可用表和它们的模式的信息。 （在实验1中不包含）SQL前端或分析器 SQL前端或分析器能够允许你直接向SimpleDB输入查询 SimpleDB的查询是通过将一组运算符串联到一个手工建立的查询计划中来建立的。SimpleDB中已经提供了一个简单的解析器，在后面的实验中使用。 （在实验1中不包含）查询优化器 （在实验1中不包含）索引 2. 不包含的部分 视图（Views） 除了整数和固定长度的字符串以外的数据类型 3. Database类Database类提供了对静态对象集合的访问，这些对象是数据库的全局状态。 特别是，这包括访问 catalog （数据库中所有表的列表）、缓冲池（当前驻留在内存中的数据库文件页的集合）和日志文件的方法。 在实验1中不需要担心日志文件的问题，Database类中已经实现完成了相关方法。 4. Field 和 TupleSimpleDB中的Tuple是非常基本的。 它们由Field的集合组成，由一组字段（Filed）组成，每个字段对应一个元组。 Field是一个接口，不同的数据类型（如整数、字符串）实现了该接口。Tuple对象是由底层访问方法（如堆文件或B树）创建的。Tuple还具有称为元组描述符（Tuple Descriptor）的类型（或模式），由TupleDesc对象表示。该对象由一组Type对象组成，每个字段对应一个Type对象，每个Type对象描述了相应字段的类型。 5. Catalog类Catalog类包含当前数据库中的表和表的模式列表。每个表都关联一个TupleDesc对象，使操作者能够确定表中字段的类型和数量。全局目录是Catalog的一个单一实例，为整个SimpleDB进程分配。可以通过方法Database.getCatalog()获取全局目录，全局缓冲池也是如此（使用Database.getBufferPool()）。 6. BufferPool类BufferPool类负责将最近从磁盘读取的页面缓存到内存中。所有操作符通过缓冲池从磁盘上的各个文件读取和写入页面。缓冲池由固定数量的页面组成，这个数量由BufferPool构造函数的numPages定义。后续实验中将会实现一种淘汰页面的策略。 在实验1中，只需要实现构造函数和SeqScan操作符使用的BufferPool中的getPage()方法。BufferPool应该最多存储numPages个页面。在实验1中，如果请求了超过numPages个不同页面的请求，您可以抛出DbException，而无需实现淘汰页面策略。Database类提供了一个静态方法Database.getBufferPool()，用于返回整个SimpleDB进程的单个BufferPool实例的引用。 7. HeapFile 和 HeapPageHeapFile访问方法提供了一种按特定方式从磁盘读取或写入数据的方式。常见的访问方法包括堆文件（未排序的Tuple文件）和B树。 HeapFile对象被组织成一组页面，每个页面包含一定数量的字节用于存储元组（由常量BufferPool.DEFAULT_PAGE_SIZE定义），包括一个头部。在SimpleDB中，每个表在数据库中都有一个HeapFile对象。HeapFile中的每个页面都被组织成一组槽位（slots），每个槽位可以容纳一个元组（SimpleDB中给定表的元组大小相同）。除了这些槽位之外，每个页面还有一个头部，其中包含一个位图，每个元组槽位对应一个位。如果位图中特定元组对应的位为1，则表示该元组是有效的；如果为0，则表示该元组无效（例如已被删除或从未初始化）。HeapFile对象的页面的类型是HeapPage，它实现了Page接口。页面存储在缓冲池中，但由HeapFile类进行读取和写入操作。 SimpleDB将堆文件以几乎相同的格式存储在磁盘上，就像它们在内存中存储的方式一样。每个文件在磁盘上连续排列的页面数据组成。每个页面由表示头部的一个或多个字节组成，后跟实际页面内容的页面大小字节。每个元组需要元组大小 * 8 位用于其内容，并且需要 1 位用于头部。因此，单个页面可以容纳的元组数量为： tuples per page = floor((page size * 8) / (tuple size * 8 + 1)) 其中，元组大小是页面中元组的大小（以字节为单位）。这里的想法是每个元组在头部需要额外的一位存储空间。我们通过将页面大小乘以8来计算页面中的位数，并将这个数量除以元组中的位数（包括这个额外的头部位），从而得到每个页面的元组数量。floor操作将结果向下取整，得到最接近整数的元组数量。 一旦知道了每个页面的元组数量，存储头部所需的字节数就简单了： headerBytes = ceiling(tuples per page / 8) ceiling操作将结果向上取整，得到最接近整数的字节数。 每个字节的低位（最低有效位）表示文件中较早的槽位的状态。因此，第一个字节的最低位表示页面中的第一个槽位是否正在使用。第一个字节的第二个最低位表示页面中的第二个槽位是否正在使用，依此类推。此外，请注意最后一个字节的高位可能不对应实际存在于文件中的槽位，因为槽位的数量可能不是8的倍数。还请注意，所有的Java虚拟机都是大端序（big-endian）的。 8. Operators操作符负责执行查询计划的实际操作。它们实现了关系代数的操作。在SimpleDB中，操作符是基于迭代器的，每个操作符都实现了DbIterator接口。 将低级操作符传递到高级操作符的构造函数中，就能够连接操作符。叶子节点处的特殊访问方法操作符负责从磁盘读取数据（因此它们下面没有任何操作符）。 查询计划开始执行时，与SimpleDB交互的程序只需调用根操作符的getNext方法。然后，该操作符调用其子操作符的getNext方法，依此类推，直到调用这些叶子操作符。它们从磁盘获取元组并将其传递给上层的操作符（作为getNext方法的返回参数）。元组以这种方式按照查询计划向上传播，直到在根部输出或与另一个操作符组合（或拒绝）。在实验1中，只需要实现一个SimpleDB操作符。 9. A simple query本节的目的是说明这些不同组件如何连接在一起来处理一个简单的查询。假设你有一个名为”some_data_file.txt”的数据文件，其内容如下： 123451,1,12,2,2 3,4,4 你可以将其转换为SimpleDB可以查询的二进制文件，方法如下所示： 1java -jar dist/simpledb.jar convert some_data_file.txt 3 这里，参数”3”告诉conver输入有3列。 以下代码实现了对该文件的简单选择查询： 12345678910111213141516171819202122232425262728293031323334353637package simpledb;import java.io.*;public class test { public static void main(String[] argv) { // construct a 3-column table schema Type types[] = new Type[]{ Type.INT_TYPE, Type.INT_TYPE, Type.INT_TYPE }; String names[] = new String[]{ &quot;field0&quot;, &quot;field1&quot;, &quot;field2&quot; }; TupleDesc descriptor = new TupleDesc(types, names); // create the table, associate it with some_data_file.dat // and tell the catalog about the schema of this table. HeapFile table1 = new HeapFile(new File(&quot;some_data_file.dat&quot;), descriptor); Database.getCatalog().addTable(table1, &quot;test&quot;); // construct the query: we use a simple SeqScan, which spoonfeeds // tuples via its iterator. TransactionId tid = new TransactionId(); SeqScan f = new SeqScan(tid, table1.getId()); try { // and run it f.open(); while (f.hasNext()) { Tuple tup = f.next(); System.out.println(tup); } f.close(); Database.getBufferPool().transactionComplete(tid); } catch (Exception e) { System.out.println (&quot;Exception : &quot; + e); } }} 以上这段代码相当于SQL语句： 1SELECT * FROM some_data_file 我们创建的表具有三个整数字段。为了表示这一点，我们创建了一个TupleDesc对象，并传递给它一个Type对象的数组，以及一个可选的String字段名数组。创建了这个TupleDesc之后，我们初始化了一个表示存储在some_data_file.dat中的表的HeapFile对象。创建完表之后，将其添加到目录中。如果这是一个已经在运行的数据库服务器，那么目录信息已经加载。为了使这段代码自包含（self-contained），我们需要显式地加载它。 一旦初始化了数据库系统，我们就创建一个查询计划。我们的计划只包含从磁盘扫描元组的SeqScan操作符。通常情况下，这些操作符的实例化需要引用相应的表（对于SeqScan来说）或通过子操作符引用（对于例如Filter）。然后，测试程序会重复调用SeqScan操作符的hasNext和next方法。当元组从SeqScan中输出时，它们会在命令行上打印出来。 我们强烈建议你尝试这个有趣的端到端测试，这将帮助你获得编写自己的SimpleDB测试程序的经验。你应该在src/java/simpledb目录下创建一个名为”test.java”的文件，其中包含上述代码，并在代码上方添加一些”import”语句，将some_data_file.dat文件放在顶级目录中，然后运行该测试。 使用maven构建项目 根据搜索引擎以及MIT 6.830 数据库系统的实现，将ant构建项目改为maven构建，需要实现两步： 迁移源代码 源代码位于src/main/java 资源文件位于src/main/resources 测试代码位于src/test/java 测试资源文件位于src/test/resources 添加pom.xml文件 根据build.xml（ant配置文件）来添加依赖和插件 出现报错 Could not find artifact org.apache.mina:mina-core:bundle:2.0.7 in nexus-aliyun... 查阅不到相关内容，根据报错信息猜测查找不到需要的依赖，推测是之前修改中央仓库为阿里云 查找maven配置文件settings.xml，添加中央仓库，重启IDEA（又重启了电脑），最终成功构建 项目解析 Field是数据类型，SimpleDB中只有两种数据类型：整数类型和定长字符串。因此确定了表的结构之后，每个元组的长度是固定的。 TupleDesc是元组描述，包括tdItemList。List中的每个元素都是TDItem类型，存储各个field的类型与名称。 Tuple是元组，也就是单条记录。包括元组描述td，记录编号rid和存储具体数据的fieldList。 Catalog中存储当前数据库的表。对于SimpleDB，只有一个全局Catalog。 BufferPool是缓冲池，存储固定数量的Page。对于SimpleDB，只有一个全局BufferPool。 DbFile是表述单张表的数据结构，能够获取到表在磁盘上存储的具体Pages，并且遍历表的元组。每个DbFile都是通过缓存池获取。 在SimpleDB中，表用数据结构DbFile表示，表中的数据存储在Page上，每个PageId对应一个Page。BufferPool的设计类似于cache，将一部分Page存储在内存中，其余存储在磁盘上。这种设计能在存储速度和存储空间上都较优。当PageId对应的Page不在BufferPool中时，从磁盘中读取对应的Page，并加入到BufferPool中。若BufferPool已满，则需要淘汰Page（采用淘汰策略决定被淘汰的Page，如最近最久未使用等），然后将新读入的Page放在被淘汰的Page的位置。因此，BufferPool中需要映射集合，将PageId映射到BPageId（BPageId是Page在BufferPool中的位置，通过BPageId能够直接在BufferPool中获取到Page）。 HeapFile实现了接口DbFile。 HeapPage实现了接口Page，是用堆文件的方式存储Tuple。包括PageId pid，Tuple描述td、指明当前位置是否为空的header（类似位图）、Tuple集合tuples、槽位数量numSlots，还有用于恢复数据的oldData和oldDataLock。 RecordID包括两部分：PageId和tupleNumber。 PageId是个接口，说明所在的Page。例如HeapPageId中只需包含两个变量，tableId和pageNumber，说明该Page位于哪张表的哪一页上。 tupleNumber说明是该页的第几个元组。","link":"/2023/10/15/SimpleDB%E9%A1%B9%E7%9B%AE%E6%80%BB%E8%A7%88/"},{"title":"SpringBoot笔记","text":"SpringBoot简介Spring介绍Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 什么是SpringBoot？SpringBoot是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 Spring开发-HelloWord项目创建Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析：通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml 更改端口号在 application.properties文件中加入Server.port=8081。 更改Banner如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案； 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ pom.xml这里我们在引入一些SpringBoot依赖的时候,不需要指定版本,就因为父依赖有这些版本仓库，也就是核心依赖在父工程中。 其中它主要依赖一个父项目spring-boot-starter-parent，主要管理项目的资源过滤及插件。 点进去，发现还有一个父依赖spring-boot-dependencies。这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 启动器 spring-boot-starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 启动器：说白了就是SpringBoot的启动场景 比如spring-boot-starter-web,会帮我们自动导入web环境所有的依赖 springboot会将所有功能场景,都变成一个个的启动器 我们要是用什么功能，就需要找到一个个启动器就可以了 主启动类123456789101112131415package com.example.springboot01helloworld;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//标注这个类是一个SpringBoot的应用@SpringBootApplicationpublic class Springboot01HelloworldApplication { public static void main(String[] args) { //通过这个方法将springboot启动 SpringApplication.run(Springboot01HelloworldApplication.class, args); }} @SpringBootConfiguration：SpringBoot的配置 @Configuration： spring配置类 @Component：说明这也是一个spring的组件 123456789- @EnableAutoConfiguration：自动配置 - ```java @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})：导入了选择器 @Import({AutoConfigurationImportSelector.class})：自动配置选择器 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); //获取所有的配置 获取候选的配置 123456protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; }12345 META-INF/spring.factories：自动配置的核心文件 SpringBoot所有的自动配置，都在启动类中被扫描并加载：所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的starter们就有对应的启动器了，有了启动器，我们的自动装配就会生效，然后就配置成功了 SpringBoot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值 将这些自动配置的类导入容器，自动配置类就会生效，帮我们进行自动配置 以前我们需要自动配置的东西，现在不需要了 整合javaEE，解决方案和自动配置的东西都在Spring-boot-autoconfigure下 它会把所有需要导入的组件，以类名的方式返回这些组件，这些组件就会被添加到容器 容器中也会存在非常多的XXXAutoConfigure的文件（@Bean），就是这个类给容器导入了这个场景所需要的所有组件并自动配置 SpringApplication开启了一个服务。 SpringApplication.run：分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； SpringApplication主要做了以下四件事情： 推断应用的类型是普通的项目还是Web项目 查找并加载所有可用初始化器 ， 设置到initializers属性中 找出所有的应用程序监听器，设置到listeners属性中 推断并设置main方法的定义类，找到运行的主类 查看构造器： 1234567public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass();} run方法流程分析 关于SpringBoot，谈谈你的理解： 自动装配：如何加载 run方法：如何启动 全面接管SpringMVC的配置！ yaml配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据作为中心，而不是以标记语言为重点！ 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： 123&lt;server&gt; &lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 yaml基础语法123456789101112131415161718# k-v键值对name: xiaoqi#相当于name=xiaoqi# 存对象student: name: xiaoqi age: 12 # 行内写法student1: {name: xiaoqi,age: 13}#数组pets: - cat - dog - pygpets1: [cat,dog] 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； 1k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） 1234#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: qinjiang age: 3 行内写法 1student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； 12server: port: 8082 可以注入到我们的配置类当中 注入配置文件yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; yaml注入配置文件1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； 1234567891011package com.example.springboot02configure.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component//添加到spring组件中public class Dog { private String name; private Integer age;} 3、编写一个person类 12345678910111213141516171819202122package com.example.springboot02configure.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;} 4、 在yaml中写入对象 123456789101112Person: name: xiaoqi age: 13 happy: false birth: 2009/01/15 maps: {k1: v1,k2: v2} lists: - code - dog dog: name: qq age: 1 5、 在测试程序中测试 12345678910111213141516171819202122package com.example.springboot02configure;import com.example.springboot02configure.pojo.Dog;import com.example.springboot02configure.pojo.Person;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.swing.*;@SpringBootTestclass SpringBoot02ConfigureApplicationTests { @Autowired private Person person; @Test void contextLoads() { System.out.println(person); }} 加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 1name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 123456@PropertySource(value = &quot;classpath:person.properties&quot;)@Component //注册beanpublic class Person { @Value(&quot;${name}&quot;) private String name; ...... } 配置文件占位符配置文件还可以编写占位符生成随机 123456789101112Person: name: xiaoqi${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2009/01/15 maps: {k1: v1,k2: v2} lists: - code - dog dog: name: ${person.hello:other}_旺财 #如果hello没有那么就默认值hello+旺财 age: 1 对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 JSR303检验12345678910111213141516171819202122232425262728293031323334空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY.Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) Validates that the annotated string is between min and max included.日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 @Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。数值检查 建议使用在String,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为”“,Integer为null @Min 验证 Number 和 String 对象是否大等于指定的值 @Max 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 @DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 @Digits 验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 @Range(min=, max=) 被指定的元素必须在合适的范围内 @Range(min=10000,max=50000,message=”range.bean.wage”) @Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) @CreditCardNumber信用卡验证 @Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 @ScriptAssert(lang= ,script=, alias=) @URL(protocol=,host=, port=,regexp=, flags=)]()]() 结论：配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 多环境切换profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： 123#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev yaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! 123456789101112server: port: 8081 ---server: port: 8082Spring: profiles: dev #命名 ---server: port: 8083 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ 官方外部配置文件说明参考文档 springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 1234优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 自动配置原理配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 分析自动配置原理我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；@Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中@EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnWebApplication( type = Type.SERVLET)//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnClass({CharacterEncodingFilter.class})//判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；@ConditionalOnProperty( prefix = &quot;spring.http.encoding&quot;, value = {&quot;enabled&quot;}, matchIfMissing = true)public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; }} 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 12345//从配置文件中获取指定的值和bean的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;) public class HttpProperties { // .....} 这就是自动装配的原理！ 精髓1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 使用debug=true可以查看哪些自动配置类生效，哪些没有生效。 MVC配置原理官网阅读在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration 12345678910111213141516171819202122232425262728293031323334353637383940Spring MVC Auto-configuration// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。Spring Boot provides auto-configuration for Spring MVC that works well with most applications.// 自动配置在Spring默认设置的基础上添加了以下功能：The auto-configuration adds the following features on top of Spring’s defaults:// 包含视图解析器Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.// 支持静态资源文件夹的路径，以及webjarsSupport for serving static resources, including support for WebJars // 自动注册了Converter：// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】Automatic registration of Converter, GenericConverter, and Formatter beans.// HttpMessageConverters// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；Support for HttpMessageConverters (covered later in this document).// 定义错误代码生成规则的Automatic registration of MessageCodesResolver (covered later in this document).// 首页定制Static index.html support.// 图标定制Custom Favicon support (covered later in this document).// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document)./*如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。*/If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.123456789101112131415161718192021222324252627282930313233343536373839 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ ViewResolver 视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ 1234567891011@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;}12345678910 自定义ViewResolverhttps://mp.weixin.qq.com/s/9AY48uLjR9bI9TUlulcBNA 转换器和格式化器修改SpringBoot的默认配置这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； 123456789101112//应为类型要求为WebMvcConfigurer，所以我们实现其接口//可以使用自定义类扩展MVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(&quot;/test&quot;).setViewName(&quot;test&quot;); }}123456789101112 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： 1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 123456789101112public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } }}1234567891011 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 1234protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry);}123 5、我们点进去看 123456789public void addViewControllers(ViewControllerRegistry registry) {Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); }}12345678 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 @EnableWebMvc 就是导入了一个 DelegatingWebMvcConfiguration 类，从容其中获取所有的webmvcconfig 在SpringBoot中由非常多的xxxConfiguration，会帮助我们进行扩展，只要看见了这个东西我们就要注意了 页面国际化https://mp.weixin.qq.com/s/e4Jd3xIMF4C4HBzPQfakvg 自定义starterhttps://mp.weixin.qq.com/s/2eB2uT088BvzaqRULezdsw 参考文章【狂神说】SpringBoot笔记整理","link":"/2023/09/15/SpringBoot%E7%AC%94%E8%AE%B0/"},{"title":"Spring笔记","text":"Spring概述简介 Spring是一个开源免费的框架 , 容器 . Spring是一个轻量级的框架 , 非侵入式的 . 控制反转 IoC , 面向切面 Aop 对事物的支持 , 对框架的支持 一句话概括：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 组成Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . Spring4.x 版本： Spring5.x 版本： Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 其他所有的功能基本都需要依赖于该模块。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。 Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 IOC 控制反转简介控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。Spring中的IoC是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。 为什么叫控制反转？ 控制：指的是对象创建（实例化、管理）的权力 反转：控制权交给外部环境（Spring 框架、IoC 容器） 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。 Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。 Bean的作用域在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所 采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Singleton当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; Prototype当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt; 或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt; Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 通过XML文件配置Bean无参构造 编写一个Hello实体类 123456789101112public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&quot;Hello,&quot;+ name ); }} 编写我们的spring文件 , 这里我们命名为beans.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 我们可以去进行测试了 . 12345678@Testpublic void test(){ //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show();} 有参构造 UserT . java 123456789101112public class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(&quot;name=&quot;+ name ); }} beans.xml 有三种方式编写 1234567891011121314&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt;&lt;!-- 第三种根据参数类型设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuangshen2&quot;/&gt;&lt;/bean&gt; 测试 123456@Testpublic void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserT user = (UserT) context.getBean(&quot;userT&quot;); user.show();} 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ set注入1. 常量注入123&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 2. bean注入1234567&lt;bean id=&quot;addr&quot; class=&quot;com.kuang.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt; 注意点：这里的值是一个引用，ref 3. 数组注入1234567891011&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 4. List注入1234567&lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 5. Map注入123456&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt;&lt;/property&gt; 6. set注入1234567&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; 7. Null注入1&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt; 8. Properties注入1234567&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; Bean的自动装配简介 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 在xml中显式配置手动配置xml新建两个实体类，Cat Dog 都有一个叫的方法 12345678910public class Cat { public void shout() { System.out.println(&quot;miao~&quot;); }}public class Dog { public void shout() { System.out.println(&quot;wang~&quot;); }} 新建一个用户类 User 12345public class User { private Cat cat; private Dog dog; private String str;} 编写Spring配置文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); user.getCat().shout(); user.getDog().shout(); }} Autowire自动装配1. byName由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。采用自动装配将避免这些错误，并且使配置简单化。 修改bean配置，增加一个属性 autowire=”byName”，其余不变，则仍可以成功运行。 123&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 当一个bean节点带有 autowire byName的属性时： 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 2. byType使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常NoUniqueBeanDefinitionException。 修改bean配置，改为 autowire=”byType”，则仍可以成功运行。 再注册一个cat的bean对象，则会出现报错NoUniqueBeanDefinitionException. 123456&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt;&lt;/bean&gt; 注解自动装配jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作： 利用注解的方式注入属性。 在spring配置文件中引入context文件头 123xmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 开启属性注解支持！ 1&lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 示例程序：将User类中的set方法去掉，使用@Autowired注解。 12345678910111213141516public class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; }} 配置文件： 1234&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配。 @Qualifier不能单独使用。 配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234&lt;bean id=&quot;dog1&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 没有加Qualifier测试，直接报错。在属性上添加Qualifier注解。 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User { //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String str;} beans.xml： 1234&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 实体类上只保留注解。 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 先进行byName查找，失败；再进行byType查找，成功。 @Autowired与@Resource异同 @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用。 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 使用注解开发准备工作 在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 注解实现Bean 配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt; 在指定包下编写类，增加注解 12345@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User { public String name = &quot;秦疆&quot;;} 测试 1234567@Testpublic void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user = (User) applicationContext.getBean(&quot;user&quot;); System.out.println(user.name);} 属性注入使用注解注入属性。 可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User { @Value(&quot;秦疆&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt; public String name;} 如果提供了set方法，在set方法上添加@value(“值”); 12345678@Component(&quot;user&quot;)public class User { public String name; @Value(&quot;秦疆&quot;) public void setName(String name) { this.name = name; }} 衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 作用域@scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User { @Value(&quot;秦疆&quot;) public String name;} XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 示例程序：编写一个实体类，Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog { public String name = &quot;dog&quot;;} 新建一个config配置包，编写一个MyConfig配置类 1234567@Configuration //代表这是一个配置类public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog dog(){ return new Dog(); }} 测试，成功输出结果！ 1234567@Testpublic void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;); System.out.println(dog.name);} 导入其他的配置类 我们再编写一个配置类！ 123@Configuration //代表这是一个配置类public class MyConfig2 {} 在之前的配置类中我们来选择导入这个配置类 12345678@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig { @Bean public Dog dog(){ return new Dog(); }} 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ AOP底层机制AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 示例程序Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent { public void rent();} Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(&quot;房屋出租&quot;); }} Proxy . java 即代理角色 12345678910111213141516171819202122//代理角色：中介public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(&quot;带房客看房&quot;); } //收中介费 public void fare(){ System.out.println(&quot;收中介费&quot;); }} Client . java 即客户 1234567891011//客户类，一般客户都会去找代理！public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); }} 分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的优缺点优点： 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成，实现了业务的分工。 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! AOP中最核心的思想：在不改变原来的代码的情况下，实现了对原有功能的增强 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理——JDK动态代理 基于类的动态代理—cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！ JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy。 【InvocationHandler：调用处理程序】 12345Object invoke(Object proxy, 方法 method, Object[] args)；//参数 //proxy - 调用该方法的代理实例 //method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 //args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 12345//生成代理类public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this);} 示例程序抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 1234//抽象角色：租房public interface Rent { public void rent();} Host . java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent{ public void rent() { System.out.println(&quot;房屋出租&quot;); }} ProxyInvocationHandler. java 即代理角色 1234567891011121314151617181920212223242526272829public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(&quot;带房客看房&quot;); } //收中介费 public void fare(){ System.out.println(&quot;收中介费&quot;); }} Client . java 123456789101112//租客public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); }} 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口 动态代理的好处静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ AOPAOP简介AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 1. 通过 Spring API 实现首先编写我们的业务接口和实现类 123456public interface UserService { public void add(); public void delete(); public void update(); public void search();} 123456789101112131415161718public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(&quot;增加用户&quot;); } @Override public void delete() { System.out.println(&quot;删除用户&quot;); } @Override public void update() { System.out.println(&quot;更新用户&quot;); } @Override public void search() { System.out.println(&quot;查询用户&quot;); }} 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 123456789public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); }} 123456789101112public class AfterLog implements AfterReturningAdvice { //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); }} 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 12345678public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.search(); }} Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 2. 自定义类来实现Aop目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 12345678public class DiyPointcut { public void before(){ System.out.println(&quot;---------方法执行前---------&quot;); } public void after(){ System.out.println(&quot;---------方法执行后---------&quot;); }} 去spring中配置 123456789101112&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.kuang.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试： 12345678public class MyTest { @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.add(); }} 3. 使用注解实现第一步：编写一个注解实现的增强类 1234567891011121314151617181920212223242526package com.kuang.config;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut { @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void before(){ System.out.println(&quot;---------方法执行前---------&quot;); } @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void after(){ System.out.println(&quot;---------方法执行后---------&quot;); } @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); }} 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=”true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 MyBatis-Spring引入Spring之前需要了解mybatis-spring包中的一些重要类； 什么是 MyBatis-Spring？MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 在 MyBatis-Spring 中，可使用 SqlSessionFactoryBean来创建 SqlSessionFactory。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 注意：SqlSessionFactory 需要一个 DataSource（数据源）。 这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。 而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt;settings&gt; 或 &lt;typeAliases&gt; 元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;environments&gt;），数据源（&lt;DataSource&gt;）和 MyBatis 的事务管理器（&lt;transactionManager&gt;）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 123&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： 123456789public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper...; }} 按下面这样，注入 SqlSessionTemplate： 123&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt; 示例程序引入Spring配置文件beans.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 配置数据源替换mybaits的数据源 1234567&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 配置SqlSessionFactory，关联MyBatis 1234567&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/dao/*.xml&quot;/&gt;&lt;/bean&gt; 注册sqlSessionTemplate，关联sqlSessionFactory； 12345&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 增加Dao接口的实现类；私有化sqlSessionTemplate 1234567891011public class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); }} 注册bean实现 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 示例程序2mybatis-spring1.2.3版以上的才有这个 . 官方文档截图 : dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 将我们上面写的UserDaoImpl修改一下 123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { public List&lt;User&gt; selectUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); }} 修改bean的配置 123&lt;bean id=&quot;userDao&quot; class=&quot;com.kuang.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 总结 : 整合到spring中以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ Spring事务事务事务简介 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务的属性 原子性（atomicity）：事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency）：一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation）：可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability）：事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 Spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx 123xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 123456789101112&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 示例程序 配置AOP，导入aop的头文件！ 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.kuang.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 进行测试 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user);} 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 参考文章Spring常见面试题总结 狂神SSM教程-Spring","link":"/2023/09/12/Spring%E7%AC%94%E8%AE%B0/"},{"title":"SpringMVC笔记","text":"什么是MVC？ MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 架构变迁Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 什么是SpringMVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 为什么要学SpringMVC?Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 中心控制器Spring的web框架围绕DispatcherServlet设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:808hello 如上url拆分成三部分： http://localhost:8080/ 服务器域名 SpringMVC 部署在服务器上的web站点 hello 表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 SpringMVC实现（注解版）1. 建立包结构 com.kuang.controller由于Maven可能存在资源过滤的问题，我们将配置完善 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 2. 配置web.xml注意点： 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; / *&lt;/ url-pattern &gt; 会匹配* .jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 3. 添加Spring MVC配置文件 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 4. 创建Controller编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范 12345678910111213141516package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; }} @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 5. 创建视图层在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ${msg}&lt;/body&gt;&lt;/html&gt; 6. 配置Tomcat运行配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置。 Controller 及 RestFul控制器Controller简介 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;} 示例程序 新建一个Moudle，springmvc-04-controller 。 将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 1234567891011//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt; ${msg}&lt;/body&gt;&lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; 增加一个ControllerTest2类，使用注解实现； 123456789101112//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2{ //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; }} 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！除了这两种之外还有其他的方式，可以参考：https://www.cnblogs.com/hellokuangshen/p/11270742.html @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 1234567@Controllerpublic class TestController { @RequestMapping(&quot;/h1&quot;) public String test(){ return &quot;test&quot;; }} 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 12345678@Controller@RequestMapping(&quot;/admin&quot;)public class TestController { @RequestMapping(&quot;/h1&quot;) public String test(){ return &quot;test&quot;; }} 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能资源：互联网所有的事物都可以被抽象为资源资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询。 与传统方式对比传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET​ http://127.0.0.1/item/saveItem.action 新增,POST​ http://127.0.0.1/item/updateItem.action 更新,POST​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET​ http://127.0.0.1/item 新增,POST​ http://127.0.0.1/item 更新,PUT​ http://127.0.0.1/item/1 删除,DELETE 示例代码 在新建一个类 RestFulController 123@Controllerpublic class RestFulController {} 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 123456789101112@Controllerpublic class RestFulController { //映射访问路径 @RequestMapping(&quot;/commit/{p1}/{p2}&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; }} 我们来测试请求查看下，成功！ 使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 使用method属性指定请求类型用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等。 我们来测试一下： 增加一个方法 123456//映射访问路径,必须是POST请求@RequestMapping(value = &quot;/hello&quot;,method = {RequestMethod.POST})public String index2(Model model){ model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;} 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； 123456//映射访问路径,必须是Get请求@RequestMapping(value = &quot;/hello&quot;,method = {RequestMethod.GET})public String index2(Model model){ model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;); return &quot;test&quot;;} 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个： 组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 平时使用的会比较多！ 结果跳转方式1. ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} 12345678&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 对应的controller类 123456789public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 2. ServletAPI通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发 1234567891011121314151617@Controllerpublic class ResultGo { @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); } @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(&quot;/index.jsp&quot;); } @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); }} 3. SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 123456789101112131415161718@Controllerpublic class ResultSpringMVC { @RequestMapping(&quot;/rsm/t1&quot;) public String test1(){ //转发 return &quot;/index.jsp&quot;; } @RequestMapping(&quot;/rsm/t2&quot;) public String test2(){ //转发二 return &quot;forward:/index.jsp&quot;; } @RequestMapping(&quot;/rsm/t3&quot;) public String test3(){ //重定向 return &quot;redirect:/index.jsp&quot;; }} 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . 1234567891011121314@Controllerpublic class ResultSpringMVC2 { @RequestMapping(&quot;/rsm2/t1&quot;) public String test1(){ //转发 return &quot;test&quot;; } @RequestMapping(&quot;/rsm2/t2&quot;) public String test2(){ //重定向 return &quot;redirect:/index.jsp&quot;; //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ }} 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : 12345@RequestMapping(&quot;/hello&quot;)public String hello(String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : 123456//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name){ System.out.println(name); return &quot;hello&quot;;} 后台输出 : kuangshen 3、提交的是一个对象要求提交的表单域和对象的属性名一致 , 参数使用对象即可 实体类 12345678public class User { private int id; private String name; private int age; //构造 //get/set //tostring()} 提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 处理方法 : 12345@RequestMapping(&quot;/user&quot;)public String user(User user){ System.out.println(user); return &quot;hello&quot;;} 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView123456789public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 第二种 : 通过ModelMap12345678@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;hello&quot;;} 第三种 : 通过Model12345678@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;} 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 乱码问题测试步骤： 我们可以在首页编写一个提交的表单 1234&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 后台编写对应的处理类 12345678@Controllerpublic class Encoding { @RequestMapping(&quot;/e/t&quot;) public String test(Model model,String name){ model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 }} 输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 . 处理方法 : 修改tomcat配置文件 ： 设置编码！ 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 自定义过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/** * 解决get和post请求 全部乱码的过滤器 */public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { }}//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(&quot;get&quot;)) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; }} 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 整合SSM框架的练习参考SpringMVC07、整合SSM P.S. 安装Tomcat参考Tomcat 的安装与环境配置教程（超详细） Json什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： 123{&quot;name&quot;: &quot;QinJiang&quot;}{&quot;age&quot;: &quot;3&quot;}{&quot;sex&quot;: &quot;男&quot;} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的var json = '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify({a: 'Hello', b: 'World'});//结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}' Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； 12345678910111213package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private String name; private int age; private String sex;} 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； 123456789101112131415@Controllerpublic class UserController { @RequestMapping(&quot;/json1&quot;) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 123456789101112131415@RestControllerpublic class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; }} 启动tomcat测试，结果都正常输出！ RestController示例测试集合输出增加一个新的方法 123456789101112131415161718@RequestMapping(&quot;/json2&quot;)public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;} 运行结果 : 十分完美，没有任何问题！ 输出时间对象增加一个新的方法 123456789@RequestMapping(&quot;/json3&quot;)public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;} 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 12345678910111213@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;} 运行结果 : 成功的输出了时间！ 抽取为工具类如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 12345678910111213141516171819202122232425package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils { public static String getJson(Object object) { return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; }} 我们使用工具类，代码就更加简洁了！ 123456@RequestMapping(&quot;/json5&quot;)public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json;} FastJson fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; fastjson 三个主要的类： 【JSONObject 代表 json 对象 】 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 【JSONArray 代表 json 对象数组】 内部是有List接口中的方法来完成操作的。 【JSON 代表 JSONObject和JSONArray的转化】 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 12345678910111213141516171819202122232425262728293031323334package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;); User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;); User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;); User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); }} 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ 拦截器概述SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器想要自定义拦截器，必须实现 HandlerInterceptor 接口。 新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器 12345678910111213141516171819202122package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(&quot;------------处理前------------&quot;); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { System.out.println(&quot;------------处理后------------&quot;); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(&quot;------------清理------------&quot;); }} 在springmvc的配置文件中配置拦截器 1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 1234567891011121314package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//测试拦截器的控制器@Controllerpublic class InterceptorController { @RequestMapping(&quot;/interceptor&quot;) @ResponseBody public String testFunction() { System.out.println(&quot;控制器中的方法执行了&quot;); return &quot;hello&quot;; }} 前端 index.jsp 1&lt;a href=&quot;${pageContext.request.contextPath}/interceptor&quot;&gt;拦截器测试&lt;/a&gt; 启动tomcat 测试一下！ 应用&amp;示例：验证用户是否登录 (认证用户)","link":"/2023/09/21/SpringMVC%E7%AC%94%E8%AE%B0/"},{"title":"python笔记","text":"基础 采用缩进（不用“；”隔开） 空值：None 注释# print absolute value of an integer: Python的整数没有大小限制，浮点数也没有，但超出一定范围就直接表示为inf（无限大） 动态语言：同一个变量可以反复赋值，而且可以是不同类型的变量 1234a = 123 # a是整数print(a)a = 'ABC' # a变为字符串print(a) bytes类型和str类型转化 1234567891011&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文'#如果只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中' 布尔值1234&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse 与、或、非123456&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; not TrueFalse 除法 无论整数、浮点数，/除法计算结果是浮点数 12&gt;&gt;&gt; 9 / 33.0 整数，//地板除计算结果是整数（只取结果的整数部分）浮点数，//地板除计算结果是浮点数（只取结果的整数部分） 1234&gt;&gt;&gt; 10 // 33&gt;&gt;&gt; 20.8 // 210.0 条件判断和循环 if语句12345678910age = 3if age &gt;= 18: print('your age is', age) print('adult')elif age &gt;= 6: print('your age is', age) print('teenager')else: print('your age is', age) print('kid') tuple 一种有序列表：元组 tuple的每个元素，指向永远不变，但指向的list本身可变 创建list123&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')&gt;&gt;&gt; classmates('Michael', 'Bob', 'Tracy') 获取元素的方法和list一样 没有改变元素方法 list 是内置的一种数据类型:列表 list里面的元素的数据类型可以不同 &gt;&gt;&gt; L = ['Apple', 123, True, ['asp', 'php']] 创建list123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 获得list元素的个数12&gt;&gt;&gt; len(classmates)3 用索引来访问list中元素1234&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[-1]'Tracy' 添加、删除、替换元素12345678910111213141516171819202122#追加元素到末尾&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam']#把元素插入到指定的位置&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']#删除list末尾的元素&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']#删除指定位置的元素&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']#把某个元素替换成别的元素&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] 字符串 字符串的输出 依次打印每个字符串，遇到逗号“,”会输出一个空格 12&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')The quick brown fox jumps over the lazy dog 输出格式化字符串:%方法 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' format（）方法 12&gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 多行字符串 交互式命令行： 123&gt;&gt;&gt; print('''line1... line2... line3''') .py文件： 123print('''line1line2line3''') 字符串不转义用r’’表示’’内部的字符串默认不转义1234&gt;&gt;&gt; print('\\\\\\t\\\\')\\ \\&gt;&gt;&gt; print(r'\\\\\\t\\\\')\\\\\\t\\\\ 字符编码转换123456&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; chr(25991)'文'&gt;&gt;&gt; '\\u4e2d\\u6587''中文' 字符串的长度 len计算str类型字符数 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2 len也可计算bytes类型字节数 123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6 输入输出 输出 1&gt;&gt;&gt; print('hello, world') 输入 1234&gt;&gt;&gt; name = input()Michael&gt;&gt;&gt; name'Michael' 文件示例 12name = input('please enter your name: ')print('hello,', name) 123C:\\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael 文件运行 命令行模式和交互模式 命令行模式： 1C:\\&gt; 交互模式：命令行模式下输入python，进入交互模式输入exit（），退出交互模式 123456C:\\Users\\cjq2061&gt;pythonPython 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; exit()C:\\&gt; 运行.py文件 1C:\\work&gt;python xxx.py","link":"/2019/04/20/python%E7%AC%94%E8%AE%B0/"},{"title":"windows生成私钥并配置到github","text":"一、 在.ssh目录下生成私钥 在C:\\Users\\{UserName}\\.ssh目录下打开终端或git bash 输入命令： 1ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; -f &quot;key_name&quot; -C后面跟的参数是邮箱，可省略 -f后面跟的参数是私钥的名字，可省略 若要生成多个私钥，为了防止私钥被覆盖，需要使用不同的私钥名字 回车确定，会提示你设置密码和再次输入密码。为了简化操作，这里不建议设置密码，直接回车确定。 二、 将生成的 key 添加到 github 打开生成的 github_id_rsa.pub 文件，全选并复制内容 登录你的 github ，点击 右上角头像 —&gt; Setttings –&gt; SSH and GPG keys –＞New SSH keys Titile 随意起名， Key 中粘贴上刚刚拷贝的公钥 点击 Add SSH key ，就成功啦！ 三、配置 config 文件在.ssh文件夹中手动创建config文件或者输入命令touch config生成，并按下面的模板填写，该文件用于配置私钥对应的服务器。 1234567891011121314151617# gitlabHost gitlab.ylwnl.com HostName gitlab.xxx.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa # githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa 配置说明： Host：自定义别名，会影响git相关命令 HostName：真实的服务器地址（域名） User：之前配置的用户名可以省略（xxx@xxx.com） PreferredAuthentications：权限认证（publickey,password publickey,keyboard-interactive）一般直接设为publickey IdentityFile：rsa文件地址","link":"/2021/08/12/windows%E7%94%9F%E6%88%90%E7%A7%81%E9%92%A5%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%88%B0github/"},{"title":"《求合体》小游戏项目报告","text":"项目链接https://github.com/0Heeee/Join_game 开发背景《求合体》以合体为主题的全新游戏,每一株草丛、每一幢房屋、每一只猫咪都时时刻刻哭喊着求合体，一切都取决于玩家的旨意,一切都决定于玩家的安排。玩家的每一位子民,都在等待英明的合体决定。 在本次的课程设计中，依照该背景对游戏进行了一定的改编。支持鼠标操作，并且包含“彩虹”、“炸弹”、“猫”等多样玩法。界面上有显示下一个可放置物品的提示以及玩家当前的分数、剩余步数、获得金币。根据玩家不同的物品类型以及玩家所点击的不同位置，将作出不同的回应。 系统功能设计系统功能模块图 系统业务流程图 项目创建系统开发环境要求本项目的开发及运行环境要求： 操作系统： Windows 开发工具：dev c++和vc++ 开发语言：c 语言 项目创建过程 寻找合适的项目主题，确定项目为游戏项目《求合体》。 找到构建项目的方法，确定使用easyx库，学习该库的使用。 考虑项目的各个模块，并完成系统功能模块图。 确认游戏的业务流程，并完成系统业务流程图。 思考并编写各个模块的具体实现。 修改bug，完善游戏页面与逻辑。 完成设计报告。 项目模块设计游戏欢迎界面概述：首先使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。 游戏规则界面概述：使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。 游戏界面概述：首先使用Photoshop获得背景图片。运用easyx库中的putimage（）函数，放置背景图片，并通过GetMouseMsg（）函数监视鼠标动作，当点击到对应区域时，作出相应回应。并且每次点击时判断游戏是否结束，结束则返回游戏欢迎界面。 生成随机地图模块概述：首先将地图所有位置初始化为空地，将盘子信息初始化为空，再随机放置石头，随机放置猫，随机放置物品，最后初始化玩家信息。 游戏操作模块概述：首先判断下一物品类型，再判断放置位置的信息，根据两者进行下一步操作。 放置物品模块概述：根据要放置的位置以及要放置的物品类型，调用putimage（）函数。 合并同类型物品模块概述：判断放下物品的四周是否有与刚放置物品同类型的物品，若有则合并升级，没有则放置。若放下物品为彩虹则可与任何物品进行合并，若其周围无满足条件物品，则彩虹变为随机物品放置。 猫咪移动模块概述：每放下一个物品时，所有可移动猫咪移动一格。若猫咪四周均有障碍物，则猫咪无路可走，变为墓。 生成随机物品模块概述：每放下一个物品后，生成新的随机物品并显示在屏幕上方正中央。 放置物品到盘子模块概述：当盘子为空时，可将物品暂时放入盘子。也可以随时取回盘子中的物品。 玩家信息变更模块概述：每放下一个物品后，玩家步数减1。合并物品后，根据所放置的物品等级进行加分。根据用户的分数可以获得相应的金币。 游戏结束模块概述：若地图中没有空地，则游戏结束，统计玩家分数。 项目创新点该项目只是根据本人玩游戏所大致了解的背景进行一定程度的改编，所有功能的实现与完善均为自己所想。 猫的移动算法在判断猫的移动时，同时要考虑到猫碰到全包围时会变成墓。然而，猫咪移动的同时，有可能会阻碍其他猫咪的移动，致使其他猫咪遇到全包围的情况，但这种情况不是玩家所致，不应该变成墓。并且，在所有猫咪移动时，原本被猫咪阻挡了所有移动方向的猫咪在该阻挡猫咪移开后，也理应可以移动。 再有，刚被玩家放置的猫不能马上移走。考虑到这几种复杂情况，我设计算法如下： （1）遍历地图，找到全部的猫，将被猫全包围且四周没有猫的猫变成墓，将被全包围且四周有猫的猫放入暂存栈。 （2）随机移动可以自由移动的猫（不包括刚放下的猫），并记录移动前的位置，加入猫栈。将移动的猫类型type变为newCAT，加入新猫栈。 （3）检测可移动的猫移动前的位置四周是否有猫，若有猫（类型type为CAT且不为刚放下的猫），则将其移动至该可移动的猫移动前的位置（现在为空地），并从暂存栈中删除该猫，将其移动前的位置加入猫栈。将刚移动的猫类型type变为newCAT，加入新猫栈。若猫栈不空，则循环该步。 （4）检查剩余的暂存猫，若周围有新猫（类型type为newCAT），则不变墓，否则变墓。 （5）将类型type为newCAT的猫类型type改回CAT。 合并同类物品算法因三个物品便可以合并，故要判断是否需要合并最多只需两次四周判断即可。设计算法（不完全按照程序执行顺序）如下： （1）判断放下物品的四周是否有与刚放置物品同类型的物品。 （2）若有同类型物品，则统计数量加一，将其放入暂存栈。判断该同类型物品的四周（不包括刚放置物品的位置）是否还有与刚放置物品同类型的物品。 （3）若两次判断均有相同类型物品，则说明相同物品数一定大于等于2，则可运用栈，将除刚放置位置外其他所有经过判断的相同类型物品清除，并记录为可升级（upFlag = 1）。 （4）若判断为可升级，则将刚放置位置的类型升级。 （5）再次调用函数，看是否可连续升级。 彩虹合并同类物品算法彩虹可以和任意物品合并，因此，为找到其应变为的类型，先统计周围物品的类型及该类型对应物品的数量，在大于等于2的类型中选取等级最低的物品，将彩虹等效为该物品。此外，其判断的大致思路与合并同类物品算法类似，故与之合并。修改合并同类物品算法如下： （1）在判断周围是否有与刚放置物品同类型的物品时，若放置物品为彩虹，则也算是。除空地、猫、墓、石头类型外，统计剩余类型的数量。 （2）第二次四周判断同第一次。除空地、猫、墓、石头类型外，统计剩余类型的数量。 （3）统计周围相同物品，若所有可用类型数量均小于2，则不能合并。将彩虹变为随机类型（不包括彩虹、猫、石头）放置。 若有某类型数量大于等于2，则在所有可合并类型中进行判断，选出等级最低的物品，并将其类型type赋给彩虹所在位置。再次调用函数进行合并操作。 总结与收获我这次所做的项目是《求合体》，灵感来源于同名app。因为之前有玩过这款小游戏，觉得比较有意思，因此想到做这个项目。 在制作项目时，遇到了挺多问题。因为这游戏知名度比较低，在设计以前我也没有找到官方的游戏规则，因此游戏的基本逻辑主要是在玩游戏的体验中总结出来的，并且加入了我个人的想法。 在游戏算法的设计上，我修改了许多次。这让我懂得了在设计的时候要反复思考，许多的问题都是事先没有考虑完全导致的。因此要考虑好可能出现的各种情况。 除了基本的游戏算法外，我还对easyx这个库有了一定的了解。用于实现c语言编写的小游戏确实比较简单，交互界面也相对于控制台游戏更加友好。 因为之前有过团队协作完成项目的经历，再加上这次对项目有了一定的想法，因此尝试了一个人完成项目。相对于团队合作，一个人完成任务的负担会重很多，但也减少了相互磨合讨论的时间。总的来说，单独完成项目使得我对整体项目的把控更为清晰。 另外，这次完成项目使用了git进行项目管理。之前有学习和使用过几次，但却是第一次使用其辅助完成项目。使用后发现，git在管理方面非常方便，也有助于看到一次次的修改成果，对项目的整体走向更好地掌控。 总体而言，经过这次项目我收获了许多，也发现了自己的不足。在以后的项目中，也会不断吸取经验教训，争取完成地更好。","link":"/2019/12/10/%E3%80%8A%E6%B1%82%E5%90%88%E4%BD%93%E3%80%8B%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A/"},{"title":"基数排序问题与解决","text":"问题描述因为引理中提到， 对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，则Radix sort需要Θ(d(k+n))时间。 因此一开始想用Counting sort来进行一位的排序。代码如下： 1234567891011121314151617181920Array stableSort(Array A, int n, int d){ int k = 10;//因为排序的是位，最大值直接定为9 Array B = (ElemType*)malloc(k * sizeof(ElemType)); Array C = (ElemType*)malloc(n * sizeof(ElemType)); Array D = getSubArray(A, n, d); //第d位的数 for(int i = 0; i &lt; k; i++){ B[i] = 0; } for(i = 0; i &lt; n; i++){ B[D[i]]++; } for(i = 1; i &lt; k; i++){ B[i] += B[i - 1]; } for(i = 0; i &lt; n; i++){ B[D[i]]--; C[B[D[i]]] = A[i]; } return A;} 123456Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ A = stableSort(A, n, i); } return A;} 测试数据始终不对。后来意识到Counting sort中相同取值的数的输出顺序与输入顺序无关，因此不适用于Radix sort。第二次还是没想放弃效率较高的算法，采用了Quicksort。代码如下： 12345678910111213int PARTITION(Array &amp;A, Array &amp;D, int p, int r){ int j = p; for(int i = p; i &lt; r; i++){ if(D[i] &lt; D[r]){ exchange(A, i, j); exchange(D, i, j); j++; } } exchange(A, j, r); exchange(D, j, r); return j;} 123456void QUICKSORT(Array &amp;A, Array &amp;D, int p, int r){ if(p &gt;= r) return; int q = PARTITION(A, D, p, r); QUICKSORT(A, D, p, q - 1); QUICKSORT(A, D, q + 1, r);} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 QUICKSORT(A, D, 0, n - 1); } return A;} 发现测试数据仍不对。又意识到Quicksort其实也没有让相同取值的数的输出顺序与输入顺序相同。为了尽快完成任务，最后采用了效率低但是输出正确的冒泡排序。 12345678910void stableSort(Array &amp;A, Array D, int n){ for(int i = 0; i &lt; n - 1; i++){ for(int j = i; j &lt; n - 1; j++){ if(D[j] &gt; D[j + 1]){ exchange(A, j, j + 1); exchange(D, j, j + 1); } } }} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 stableSort(A, D, n); } return A;} 分析 对各个排序算法的适用性不太熟悉。 对各个算法的书写也没完全掌握，在写不同算法时，仍会有很多小bug。 总结因为对算法的不熟悉，导致耗费了大量时间在这一个简单的算法上。但从另一个角度说，也算是加深了对算法的理解，并且对vc++的调试更熟悉了。","link":"/2020/09/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"},{"title":"桶排序问题与解决","text":"问题描述看到书上的案例图，觉得是用链表+数组实现，于是一开始参考数据结构老师ppt。但发现实现不了（详见桶排序问题）。后来想结构直接用二维数组算了。本来对B[i]数据排序，想用QuickSort，但发现如果是数组B[i][1]至B[i][k]排序，原算法改动较大，遂作罢。 最终代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void BUCKET_SORT(Array &amp;A, int n){ bArray B = (Array*)malloc(n * sizeof(Array)); for(int i = 0; i &lt; n; i++){ B[i] = (ElemType*)malloc((n + 1) * sizeof(ElemType)); B[i][0] = 0;//开头存放大小 for(int j = 1; j &lt; n + 1; j++){ B[i][j] = -1; } } //将A分配到B中 for(i = 0; i &lt; n; i++){ int pos = (int)ceil(n * A[i]) - 1; int j = 1; while(B[pos][j] != -1 &amp;&amp; j &lt; n){ j++; } B[pos][j] = A[i]; B[pos][0]++; } //对B[i]数据排序 for(i = 0; i &lt; n; i++){ if(B[i][0] != 0 &amp;&amp; B[i][0] != 1){ for(int j = 1; j &lt; B[i][0] + 1; j++){ for(int k = j; k &lt; B[i][0]; k++){ if(B[i][k] &gt; B[i][k + 1]){ double tmp = B[i][k]; B[i][k] = B[i][k + 1]; B[i][k + 1] = tmp; } } } } } //将B中数据重新给A i = 0; int j = 0; int k = 1; while(i &lt; n &amp;&amp; j &lt; n){ if(B[j][0] != 0){ if(B[j][k] != -1 &amp;&amp; k &lt; n + 1){ A[i] = B[j][k]; B[j][k] = -1; B[j][0]--; k++; i++; } else{ j++; } } else{ j++; k = 1; } }} 总结自己从头写不仅非常耗费时间精力，而且算法效率也不高，体现不出原算法的精妙。或许以后应该直接参考别人的写法？这种完全靠自己实现算法的做法除了让我对调试越来越熟悉以外，其他好像也没什么帮助了吧。（也许还会让自己更有自知之明一些…）","link":"/2020/09/30/%E6%A1%B6%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"},{"title":"桶排序问题","text":"问题描述在用Bucket sort的时候，试了一下用链表数组的结构。编译通过了，但是不知道为什么next指针用不了。 代码12345678typedef double ElemType;typedef ElemType* Array;typedef struct CTNode{ ElemType data; struct CTNode *next;}*ChildPtr;typedef ChildPtr CTBox;typedef CTBox* CTree; 12345678910//得到最后一个元素 ChildPtr getRear(CTBox B){ ChildPtr p = B; if(B){ //while(p-&gt;next){ // p = p-&gt;next; //} } return p;} 1234567891011121314151617//链表中元素的排序void SortCTNode(CTBox &amp;Box){ ChildPtr p, q, head; head = p = Box; while(head){ head = head-&gt;next; q = Box; while(p-&gt;data &gt; q-&gt;next-&gt;data &amp;&amp; q-&gt;next){ q = q-&gt;next; } if(p != q){ p-&gt;next = q-&gt;next; q-&gt;next = p; } p = head; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344void BUCKET_SORT(Array &amp;A, int n){ CTree B = (CTBox*)malloc(n * sizeof(CTBox)); CTBox newBox; ChildPtr newChild, p; for(int i = 0; i &lt; n; i++){ B[i] = NULL; } for(i = 0; i &lt; n; i++){ if(!B[(int)ceil(n * A[i])]){ newBox = (CTNode*)malloc(sizeof(CTNode)); newBox-&gt;data = A[i]; newBox-&gt;next = NULL; B[(int)ceil(n * A[i])] = newBox; } else{ newChild = (CTNode*)malloc(sizeof(CTNode)); newChild-&gt;data = A[i]; newChild-&gt;next = NULL; p = getRear(B[(int)ceil(n * A[i])]); p-&gt;next = newChild; } } //依次给链表排序 for(i = 0; i &lt; n; i++){ if(B[i]){ SortCTNode(B[i]); } } //将链表连接起来 CTBox Final = (CTNode*)malloc(sizeof(CTNode)); p = Final; for(i = 0; i &lt; n; i++){ if(B[i]){ p-&gt;next = B[i]; p = getRear(B[i]); } } //依次赋值给Array p = Final-&gt;next; for(i = 0; i &lt; n; i++){ A[i] = p-&gt;data; p = p-&gt;next; }}","link":"/2020/09/25/%E6%A1%B6%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"title":"算法导论笔记","text":"第1章算法介绍 第2章 用扑克牌举例，介绍了一种插入排序123456789101112void InsertSort(ElemType *A){ printf(&quot;length:%d\\n&quot;, length); for(int j = 1; j &lt; MAXSIZE; j++){ int i = j - 1; int tmp = A[j]; while(tmp &lt; A[i] &amp;&amp; i &gt;= 0){ A[i + 1] = A[i]; i--; } A[i + 1] = tmp; }} 简单介绍了时间复杂度的计算 简单介绍了分治法，并举例 123456789101112131415161718192021222324void Merge(ElemType *A, int start1, int end1, int start2, int end2){ int length1 = end1 - start1; int length2 = end2 - start2; ElemType L[MAXSIZE], R[MAXSIZE]; int i, j, p1, p2; for(j = start1, i = 0; j &lt;= end1; j++, i++){ L[i] = A[j]; } L[i] = INT_MAX;//--注意跳出循环后i的值 for(j = start2, i = 0; j &lt;= end2; j++, i++){ R[i] = A[j]; } R[i] = INT_MAX; for(i = start1, p1 = 0, p2 = 0; i &lt;= end2; i++){ if(L[p1] &lt;= R[p2]){ A[i] = L[p1]; p1++; } else{ A[i] = R[p2]; p2++; } }} 123456789void MergeSort(ElemType *A, int start, int end){ if(end - start == 0) return;//--注意长度为1数组的表达 else{ int mid = (start + end) / 2; MergeSort(A, start, mid); MergeSort(A, mid + 1, end); Merge(A, start, mid, mid + 1, end); }} 分析算法T(n) = aT(n/b) + D(n) + C(n)分离的子问题T(n/b)，子问题之和aT(n/b) 第3章 时间复杂度记号Θ()：包括上下界O()：上界，常使用，最坏情况Ω()：下界o()：强上界，高阶无穷小w()：强下界，低阶无穷小 floors and ceilings⌈⌉：向上取整⌊⌋：向下取整 指数对数及其他数学表达式除对数lgn = log2n外，其余与数学相同。 第4章 最大的子数列问题 1234567891011121314151617181920212223242526int* FindMaxCrossing(ElemType *A, int start, int mid, int end){ int left_sum = -INT_MAX; int right_sum = -INT_MAX; int sum = 0; int fstart, fend; int result[3]; for(int i = mid; i &gt;= start; i--){ sum += A[i]; if(left_sum &lt; sum){ left_sum = sum; fstart = i; } } sum = 0; for(int i = mid + 1; i &lt;= end; i++){ sum += A[i]; if(right_sum &lt; sum){ right_sum = sum; fend = i; } } result[0] = left_sum + right_sum; result[1] = fstart; result[2] = fend; return result;} 12345678910111213141516171819202122int* FindMax(ElemType *A, int start, int end) { int result[3], LResult[3], RResult[3], CResult[3]; if(start == end){ result[0] = A[start];//result[0] : maxMoney result[1] = start;//result[1] : startPos result[2] = end;//result[2] : endPos return result; } else{ int mid = (start + end) / 2; ArrayTo(LResult, FindMax(A, start, mid), 3); ArrayTo(RResult, FindMax(A, mid + 1, end), 3); ArrayTo(CResult, FindMaxCrossing(A, start, mid, end), 3); if(LResult[0] &gt; RResult[0]) ArrayTo(result, LResult, 3); else ArrayTo(result, RResult, 3); if(CResult[0] &gt; result[0]) ArrayTo(result, CResult, 3); return result; }} 矩阵乘法简化算法 用代入法和递归树求时间复杂度（中文翻译为递归式） 主方法求时间复杂度T(n) = aT(n/b) + f(n)主定理： 第5章概率分析和随机算法 第6章堆 数组堆的两个属性：length（数组长）、heap-size（实际存放数据长度，堆顶）。 放在数组中储存，可根据下标判断左/右孩子（2i为左，2i+1为右）。 分为max-heap(最大堆)和min-heap(最小堆)，最大堆的每个父母结点的值都大于孩子结点。 基本算法 MAX-HEAPIFY比较父母结点与孩子结点的大小，并将最大值放在父母结点位置时间复杂度O(lgn) 123456789101112Status MAX_HEAPIFY(Heap &amp;A, int i){ if(i &gt;= A.heap_size || i &lt; 0) return ERROR; int left, right, max; left = A.node[i].lchild; right = A.node[i].rchild; max = A.node[left].data &gt; A.node[right].data ? left : right; if(A.node[max].data &gt; A.node[i].data){ Exchange(A, max, i); MAX_HEAPIFY(A, max); } return OK;} BUILD-MAX-HEAP利用前一算法构造max-heap(最大堆)时间复杂度O(n)1234567Status BUILD_MAX_HEAP(Heap &amp;A){ //A.heap_size = A.length; for(int i = A.length / 2 - 1; i &gt;= 0; i--){ MAX_HEAPIFY(A, i); } return OK;} HEAPSORT可能是利用堆排序，排完后解散堆123456789Status HEAP_SORT(Heap &amp;A){ BUILD_MAX_HEAP(A); for(int i = A.heap_size - 1; i &gt; 0; i--){ Exchange(A, 0, i); A.heap_size--; MAX_HEAPIFY(A, 0); } return OK;} HEAP-MAXIUM返回堆的最大值123ElemType HEAP_MAXIUM(Heap A){ return A.node[0].data;} HEAP-EXTRACT-MAX取出堆的最大值1234567ElemType HEAP_EXTRACT_MAX(Heap &amp;A){ ElemType dataMax = HEAP_MAXIUM(A); Exchange(A, 0, A.heap_size - 1); A.heap_size--; MAX_HEAPIFY(A, 0); return dataMax;} MAX-HEAP-INSERT增加堆中某位置的值123456789Status MAX_HEAP_INSERT(Heap &amp;A, int pos, ElemType key){ if(key &lt; A.node[pos].data) return ERROR; A.node[pos].data = key; while(pos != 0 &amp;&amp; A.node[A.node[pos].parent].data &lt; A.node[pos].data){ Exchange(A, A.node[pos].parent , pos); pos = A.node[pos].parent; } return OK;} HEAP-INCREMENT-KEY堆末尾插入新元素 123456Status HEAP_INCREMENT_KEY(Heap &amp;A, ElemType key){ if(++A.heap_size &gt; A.length) return ERROR; A.node[A.heap_size - 1].data = -INT_MAX; MAX_HEAP_INSERT(A, A.heap_size - 1, key); return OK;} 第7章概述将要排序的数分割为比A[q]大和比A[q]小的，再分别对A[p,q-1],A[q+1,r]进行分割，直到完成。 特点期望的时间复杂度为O(nlgn)，最坏情况为O(n)。通常为O(nlgn)。方法为分治法。 算法 QUICKSORT(A, p, r)1234567Status QUICKSORT(Array &amp;A, int p, int r){ if(p &gt;= r) return OK; int q = PARTITION(A, p, r); QUICKSORT(A, p, q - 1); QUICKSORT(A, q + 1, r); return OK;} PARTITION(A, p, r)1234567891011int PARTITION(Array &amp;A, int p, int r){ int j = p; for(int i = p; i &lt; r; i++){ if(A[i] &lt; A[r]){ Exchange(A, i, j); j++; } } Exchange(A, j, r); return j;} RANDOMIZED_QUICKSORT相当于输入足够大的数组？1234567Status RANDOMIZED_QUICKSORT(Array &amp;A, int p, int r){ if(p &gt;= r) return OK; int q = RANDOMIZED_PARTITION(A, p, r); RANDOMIZED_QUICKSORT(A, p, q - 1); RANDOMIZED_QUICKSORT(A, q + 1, r); return OK;} 第8章比较排序的最短时间: 通过决策树的深度，可以体现算法的时间复杂度的下界。 定理：任何排序算法的最坏情况都需要Ω(nlgn)的时间复杂度。 结论：Heapsort和Mergesort都是渐进最优排序算法。 线性时间算法 Counting sort概述：A中，有n个比x小的数，则将x放置在第n+1个位置。特点：适用于比较非负整数且数值较小的数。k为须比较的数的最大值，则时间复杂度为Θ(k+n)。使用该算法时，通常k=O(n)，则时间复杂度为Θ(n)。相同取值的数的输出顺序与输入顺序无关。代码： 12345678910111213141516171819Array COUNTING_SORT(Array A, int n){ int k = getMax(A, n); Array B = (ElemType*)malloc(k * sizeof(ElemType)); Array C = (ElemType*)malloc(n * sizeof(ElemType)); for(int i = 0; i &lt; k; i++){ B[i] = 0; } for(i = 0; i &lt; n; i++){ B[A[i] - 1]++; } for(i = 1; i &lt; k; i++){ B[i] += B[i - 1]; } for(i = 0; i &lt; n; i++){ B[A[i] - 1]--; C[B[A[i] - 1]] = A[i]; } return C;} Radix sort概述：根据位数d的重要性，从最不重要的一位开始排序，共排序d次。特点：引理：对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，则Radix sort需要Θ(d(k+n))时间。引理：对于n位数，单位数的最大值为k，若稳定排序需要Θ(k+n)时间，对于任意正数r≤b，Radix sort需要Θ((b/r)(n+2^r))时间。代码：12345678910void stableSort(Array &amp;A, Array D, int n){ for(int i = 0; i &lt; n - 1; i++){ for(int j = i; j &lt; n - 1; j++){ if(D[j] &gt; D[j + 1]){ exchange(A, j, j + 1); exchange(D, j, j + 1); } } }} 1234567Array RADIX_SORT(Array A, int n, int d){ for(int i = 1; i &lt;= d; i++){ Array D = getSubArray(A, n, i); //第d位的数 stableSort(A, D, n); } return A;} Bucket sort概述：有n个[0,1)之间的数，根据⌊nA[i]⌋将A中各数分配到B中，再对B[i]中各数进行排序。特点：要排序的各数均在[0,1)之间。B可运用链表。时间复杂度为Θ(n)。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void BUCKET_SORT(Array &amp;A, int n){ bArray B = (Array*)malloc(n * sizeof(Array)); for(int i = 0; i &lt; n; i++){ B[i] = (ElemType*)malloc((n + 1) * sizeof(ElemType)); B[i][0] = 0;//开头存放大小 for(int j = 1; j &lt; n + 1; j++){ B[i][j] = -1; } } //将A分配到B中 for(i = 0; i &lt; n; i++){ int pos = (int)ceil(n * A[i]) - 1; int j = 1; while(B[pos][j] != -1 &amp;&amp; j &lt; n){ j++; } B[pos][j] = A[i]; B[pos][0]++; } //对B[i]数据排序 for(i = 0; i &lt; n; i++){ if(B[i][0] != 0 &amp;&amp; B[i][0] != 1){ for(int j = 1; j &lt; B[i][0] + 1; j++){ for(int k = j; k &lt; B[i][0]; k++){ if(B[i][k] &gt; B[i][k + 1]){ double tmp = B[i][k]; B[i][k] = B[i][k + 1]; B[i][k + 1] = tmp; } } } } } //将B中数据重新给A i = 0; int j = 0; int k = 1; while(i &lt; n &amp;&amp; j &lt; n){ if(B[j][0] != 0){ if(B[j][k] != -1 &amp;&amp; k &lt; n + 1){ A[i] = B[j][k]; B[j][k] = -1; B[j][0]--; k++; i++; } else{ j++; } } else{ j++; k = 1; } }} 第9章找到最小值时间复杂度：比较n-1次。方法：常规做法。代码：略。 同时找到最小值和最大值时间复杂度：比较3⌊n/2⌋次。方法：将A分成两两一组，大的跟max比较，小的跟min比较。代码： 12345678void comparing(Array &amp;A, int i, int j){ ElemType tmp; if(A[i] &gt; A[j]){ tmp = A[i]; A[i] = A[j]; A[j] = tmp; }} 1234567891011121314151617181920void getMaxMin(Array A, int n, ElemType &amp;max, ElemType &amp;min){ if(n % 2){ max = min = A[0]; for(int i = 1; i &lt; n - 1; i = i + 2){ comparing(A, i, i + 1); if(A[i] &lt; min) min = A[i]; if(A[i + 1] &gt; max) max = A[i + 1]; } } else{ comparing(A, 0, 1); min = A[0]; max = A[1]; for(int i = 2; i &lt; n - 1; i = i + 2){ comparing(A, i, i + 1); if(A[i] &lt; min) min = A[i]; if(A[i + 1] &gt; max) max = A[i + 1]; } }} 随机挑选出第i个最小的数时间复杂度：Θ(n^2)? O(n)?不通过排序来选择，使算法效率较高。方法：运用随机分割，可得有k-1个数小于A[q]。若k！=i，则递归再次挑选。代码： 12345678ElemType RANDOMIZED_SELECT(Array A, int p, int r, int i){ if(p == r) return A[p]; int q = RANDOMIZED_PARTITION(A, p, r); int k = q - p + 1; if(k == i) return A[q]; else if(i &lt; k) return RANDOMIZED_SELECT(A, p, q - 1, i); else return RANDOMIZED_SELECT(A, q + 1, r, i - k);} 第10章Stacks特征last-in,first-out(LIFO) 先进后出基本操作 STACK-EMPTY PUSH POP Queue特征first-in,first-out(FIFO)先进先出基本操作 STACK-EMPTY ENQUEUE DEQUEUE Linked lists基本操作 LIST-SEARCH LIST-INSERT LIST-DELETE 静态指针和静态链表树第11章特征 search time: Θ(n), in the worst case O(1), in the average 用数组T[n]存储关键词的位置","link":"/2020/09/15/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"},{"title":"计算机网络知识点整理","text":"网络模型 Q：为什么要有 TCP/IP 网络模型？ A：对于同一台设备上的通信，有很多种方式，比如管道、消息队列、共享内存等；而对于不同设备上的进程间通信，就需要网络通信。为了兼容多种设备，就协商出了一套通用的网络协议。 TCP/IP 网络参考模型共有 4 层，其中需要我们熟练掌握的是应用层、传输层和网络层，至于网络接口层（数据链路层和物理层）我们只需要做简单的了解就可以了。 1. 应用层（Application Layer）应用层不关心数据是如何传输的，而是专注于为用户提供应用功能。常见的协议有HTTP、FTP、Telnet、DNS和SMTP等。应用层工作在操作系统的用户态。 2. 传输层（Transport Layer）传输层有两个传输协议，TCP和UDP。 TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。 UDP（User Datagram Protocol）只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，这需要把 TCP 的特性在应用层上实现。 当传输层的数据大小超过MSS（TCP 最大报文段长度）时，需要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，每个分块称为一个 TCP 段（TCP Segment）。 传输层需要将数据包传给应用，不同的应用通过端口号来进行区分。例如，80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。 3. 网络层（Internet Layer）网络层负责将数据从一个设备传输到另一个设备，一般使用IP地址给设备编号。对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。IP地址通过子网掩码分为两部分，分别是网络号和主机号： 网络号，负责标识该 IP 地址是属于哪个「子网」的； 主机号，负责标识同一「子网」下的不同主机。 网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。 IP协议包括路由能力和寻址能力： 路由：实际场景中，两台设备是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。路由器寻址工作中，就是要找到目标地址的子网，找到后把数据包转发给对应的网络内。 寻址：IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。 4. 网络接口层（Link Layer） Q：什么是以太网呢？ A：电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。 生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。 以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。 MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。 网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。 各层的封装格式网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。","link":"/2024/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"通过C#实现Xml的自动转换","text":"一、目的 通过给定的标准化xml schema文档，将非标准化的xml schema文档进行一定的转换，从而使所有的xml schema文档都遵循同一套格式，方便后续对xml文档的处理。 二、实现过程起初，我们对任务不太明确。不清楚给出的规划化文件和需要进行规范的文件是xml文档还是xml schema文档。因此，在多次讨论无果后，再次咨询了老师。得到确定答案后重新查阅了资料，才开始具体的实现。 前期，我们主要查询的方向为xml文档相似度的判定。了解到xml文档的相似度主要基于名称相似度以及结构相似度。而名称相似度又可以通过比较两个节点名称的编辑距离相似度、语义相似度、上下节点的相关性等得到。结构相似度除了节点的层次外，还包括了节点的数据类型相似度、生成的树的编辑距离、子树出现频率等。例如，《基于路径特征的xml文档结构相似性度量》中提出，可以通过比较节点的最长公共子序列的相似度、节点层次相似度、节点名称出现频率来得到两个xml文档的相似度。在明确任务目的后，我们又对xml的匹配、转换进行了相关查询。再加上自己的思考、不断测试更正，最终实现了所需的功能。 三、实现方法经过暑假的学习，我们已经对运用C#操作xml文档有了初步的认识，因此选择使用C#语言实现。运行环境为Microsoft Visual Studio2019。主要步骤如下： 用DOM将xml schema文件生成可视化模式图，结构为树。其中节点的属性和子节点用不同的符号进行区分。 遍历可视化模式图，计算节点的相似度。节点相似度由几个部分组成： 节点名称的语义相似度。主要通过WordNet得出。若WordNet不可直接解析，则将名称进行规范化后再按照权重进行计算。 名称间的编辑距离。 节点的数据类型相似度。参考《Computing simple and complex matching’s between XML schema for transforming XML documents》中提出的数据类型兼容表。 将符合条件的节点进行配对。节点的映射分为一对一、一对多、多对一这三种情况。按照一对多、多对一、一对一的顺序配对。 根据配对结果，对非标准化的文档进行修改转换，使其成为规范化的文档。 四、任务分配 可视化模式图的生成、节点名称的编辑距离计算、节点的数据类型相似度计算、文档的转换操作。 节点名称规范化、名称间的语义相似度、节点的配对。 五、具体实现由于可通过直接遍历得到节点的相似度以及实现转换，因此在正式实现过程中，没有生成可视化模式图，仅作为测试使用。（具体看代码）","link":"/2020/04/12/%E9%80%9A%E8%BF%87C#%E5%AE%9E%E7%8E%B0Xml%E7%9A%84%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2/"}],"tags":[{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"nexo","slug":"nexo","link":"/tags/nexo/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"C#","slug":"C","link":"/tags/C/"}],"categories":[{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"语言","slug":"语言","link":"/categories/%E8%AF%AD%E8%A8%80/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法导论","slug":"算法导论","link":"/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"pages":[]}